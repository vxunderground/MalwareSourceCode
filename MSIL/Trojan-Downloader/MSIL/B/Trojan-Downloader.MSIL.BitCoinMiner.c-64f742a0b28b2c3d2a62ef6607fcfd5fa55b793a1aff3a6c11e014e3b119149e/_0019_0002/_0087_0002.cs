// Decompiled with JetBrains decompiler
// Type: .
// Assembly: WindowsBC, Version=1.0.0.0, Culture=neutral, PublicKeyToken=9909ee17073e3364
// MVID: 658BFC85-36E1-493D-98E6-AE9127D73D60
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Trojan-Downloader.MSIL.BitCoinMiner.c-64f742a0b28b2c3d2a62ef6607fcfd5fa55b793a1aff3a6c11e014e3b119149e.exe

using \u0001\u0002;
using \u000E;
using \u000E\u0002;
using \u0017\u0002;
using \u0019\u0002;
using \u0093;
using ICSharpCode.SharpZipLib.Zip;
using System;
using System.Collections;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u0019\u0002
{
  internal sealed class \u0087\u0002 : IDisposable, IEnumerable
  {
    public \u0087\u0002.\u0088\u0002 \u0001;
    private bool \u0002;
    private string \u0003;
    private string \u0004;
    private Stream \u0005;
    private bool \u0006;
    private long \u0007;
    private \u0081\u0002[] \u0008;
    private byte[] \u000E;
    private bool \u000F;
    private \u001F\u0002 \u0010 = \u001F\u0002.\u0003;
    private ArrayList \u0011;
    private Hashtable \u0012;
    private \u0090\u0002 \u0013;
    private \u008F\u0002 \u0014;
    private int \u0015 = 4096;
    private \u001D\u0002 \u0016 = (\u001D\u0002) new \u0083\u0002();

    private void \u008C\u0005([In] string obj0)
    {
      if (this.\u0001 == null)
        return;
      \u0086\u0002 e = new \u0086\u0002(obj0, this.\u000E);
      this.\u0001((object) this, e);
      this.\u000E = e.get_Key();
    }

    [SpecialName]
    public void \u008D\u0005([In] string obj0)
    {
      switch (obj0)
      {
        case null:
          this.\u000E = (byte[]) null;
          break;
        default:
          if (\u0011\u0003.\u007E\u0004\u0002((object) obj0) != 0)
          {
            this.\u0004 = obj0;
            this.\u000E = \u009F.\u0096\u0003(\u0080\u0002.\u009C\u0004(obj0));
            break;
          }
          goto case null;
      }
    }

    [SpecialName]
    private bool \u008E\u0005() => this.\u000E != null;

    public \u0087\u0002([In] Stream obj0)
    {
      if (obj0 == null)
        throw new ArgumentNullException(\u0008.\u000E\u0003(752));
      this.\u0005 = \u0007\u0003.\u007E\u009F\u0004((object) obj0) ? obj0 : throw new ArgumentException(\u0008.\u000E\u0003(4426), \u0008.\u000E\u0003(752));
      this.\u0006 = true;
      if (\u007F\u0004.\u007E\u0003\u0005((object) this.\u0005) > 0L)
      {
        try
        {
          this.\u009C\u0005();
        }
        catch
        {
          this.\u0097\u0005(true);
          throw;
        }
      }
      else
      {
        this.\u0008 = new \u0081\u0002[0];
        this.\u000F = true;
      }
    }

    internal \u0087\u0002()
    {
      this.\u0008 = new \u0081\u0002[0];
      this.\u000F = true;
    }

    ~\u0087\u0002()
    {
      try
      {
        this.Dispose(false);
      }
      finally
      {
        \u0093\u0003.\u0096((object) this);
      }
    }

    public void Close()
    {
      this.\u0097\u0005(true);
      \u0093\u0003.\u007F\u0003((object) this);
    }

    [SpecialName]
    public bool \u008F\u0005() => this.\u0006;

    [SpecialName]
    public void \u0090\u0005([In] bool obj0) => this.\u0006 = obj0;

    [IndexerName("EntryByIndex")]
    public \u0081\u0002 this[[In] int obj0] => (\u0081\u0002) this.\u0008[obj0].Clone();

    public IEnumerator GetEnumerator()
    {
      if (this.\u0002)
        throw new ObjectDisposedException(\u0008.\u000E\u0003(4459));
      return (IEnumerator) new \u0087\u0002.\u008D\u0002(this.\u0008);
    }

    public int \u0092\u0005([In] string obj0, [In] bool obj1)
    {
      if (this.\u0002)
        throw new ObjectDisposedException(\u0008.\u000E\u0003(4459));
      for (int index = 0; index < this.\u0008.Length; ++index)
      {
        if (\u0015\u0005.\u0008\u0002(obj0, this.\u0008[index].\u0005\u0004(), obj1, \u0087\u0004.\u008F\u0004()) == 0)
          return index;
      }
      return -1;
    }

    public Stream \u0093\u0005([In] \u0081\u0002 obj0)
    {
      if (obj0 == null)
        throw new ArgumentNullException(\u0008.\u000E\u0003(4472));
      if (this.\u0002)
        throw new ObjectDisposedException(\u0008.\u000E\u0003(4459));
      long index = obj0.\u0003\u0005();
      if (index < 0L || index >= (long) this.\u0008.Length || \u0080\u0005.\u0002\u0002(this.\u0008[index].\u0005\u0004(), obj0.\u0005\u0004()))
      {
        index = (long) this.\u0092\u0005(obj0.\u0005\u0004(), true);
        if (index < 0L)
          throw new ZipException(\u0008.\u000E\u0003(4481));
      }
      return this.\u0093\u0005(index);
    }

    public Stream \u0093\u0005([In] long obj0)
    {
      if (this.\u0002)
        throw new ObjectDisposedException(\u0008.\u000E\u0003(4459));
      long num = this.\u009D\u0005(this.\u0008[obj0]);
      \u007F\u0002 obj = this.\u0008[obj0].\u001A\u0005();
      Stream stream = (Stream) new \u0087\u0002.\u008E\u0002(this, num, this.\u0008[obj0].\u0016\u0005());
      if (this.\u0008[obj0].\u009D\u0004())
      {
        stream = this.\u009E\u0005(stream, this.\u0008[obj0]);
        if (stream == null)
          throw new ZipException(\u0008.\u000E\u0003(4510));
      }
      switch (obj)
      {
        case \u007F\u0002.\u0001:
          return stream;
        case \u007F\u0002.\u0002:
          stream = (Stream) new \u0008\u0002(stream, new \u0013(true));
          goto case \u007F\u0002.\u0001;
        default:
          throw new ZipException(\u0002\u0005.\u001C\u0002((object) \u0008.\u000E\u0003(4551), (object) obj));
      }
    }

    private long \u0094\u0005([In] \u0081\u0002 obj0, [In] \u0087\u0002.\u0089\u0002 obj1)
    {
      Stream stream;
      \u0093\u0003.\u009B\u0003((object) (stream = this.\u0005));
      try
      {
        bool flag1 = (obj1 & \u0087\u0002.\u0089\u0002.\u0002) != (\u0087\u0002.\u0089\u0002) 0;
        bool flag2 = (obj1 & \u0087\u0002.\u0089\u0002.\u0001) != (\u0087\u0002.\u0089\u0002) 0;
        long num1 = \u0015\u0004.\u007E\u0008\u0005((object) this.\u0005, this.\u0007 + obj0.\u0005\u0005(), SeekOrigin.Begin);
        if (this.\u0099\u0005() != 67324752U)
          throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(4596), (object) (this.\u0007 + obj0.\u0005\u0005())));
        short num2 = (short) this.\u0098\u0005();
        short num3 = (short) this.\u0098\u0005();
        short num4 = (short) this.\u0098\u0005();
        short num5 = (short) this.\u0098\u0005();
        short num6 = (short) this.\u0098\u0005();
        uint num7 = this.\u0099\u0005();
        long num8 = (long) this.\u0099\u0005();
        long num9 = (long) this.\u0099\u0005();
        int length1 = (int) this.\u0098\u0005();
        int length2 = (int) this.\u0098\u0005();
        byte[] numArray1 = new byte[length1];
        \u009D.\u0093\u0003(this.\u0005, numArray1);
        byte[] numArray2 = new byte[length2];
        \u009D.\u0093\u0003(this.\u0005, numArray2);
        \u0084\u0002 obj = new \u0084\u0002(numArray2);
        if (obj.\u0087\u0005(1))
        {
          num9 = obj.\u0088\u0005();
          num8 = obj.\u0088\u0005();
          if (((int) num3 & 8) != 0)
          {
            if (num9 != -1L && num9 != obj0.\u0010\u0004())
              throw new ZipException(\u0008.\u000E\u0003(4645));
            if (num8 != -1L && num8 != obj0.\u0016\u0005())
              throw new ZipException(\u0008.\u000E\u0003(4682));
          }
        }
        else if (num2 >= (short) 45 && ((uint) num9 == uint.MaxValue || (uint) num8 == uint.MaxValue))
          throw new ZipException(\u0008.\u000E\u0003(4735));
        if (flag2 && obj0.\u0081\u0005())
        {
          if (!obj0.\u0082\u0005())
            throw new ZipException(\u0008.\u000E\u0003(4796));
          if (num2 > (short) 51 || num2 > (short) 20 && num2 < (short) 45)
            throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(4841), (object) num2));
          if (((int) num3 & 12384) != 0)
            throw new ZipException(\u0008.\u000E\u0003(4922));
        }
        if (flag1)
        {
          if (num2 <= (short) 63 && num2 != (short) 10 && num2 != (short) 11 && num2 != (short) 20 && num2 != (short) 21 && num2 != (short) 25 && num2 != (short) 27 && num2 != (short) 45 && num2 != (short) 46 && num2 != (short) 50 && num2 != (short) 51 && num2 != (short) 52 && num2 != (short) 61 && num2 != (short) 62 && num2 != (short) 63)
            throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(5023), (object) num2));
          if (((int) num3 & 49168) != 0)
            throw new ZipException(\u0008.\u000E\u0003(5100));
          if (((int) num3 & 1) != 0 && num2 < (short) 20)
            throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(5145), (object) num2));
          if (((int) num3 & 64) != 0)
          {
            if (((int) num3 & 1) == 0)
              throw new ZipException(\u0008.\u000E\u0003(5242));
            if (num2 < (short) 50)
              throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(5145), (object) num2));
          }
          if (((int) num3 & 32) != 0 && num2 < (short) 27)
            throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(5319), (object) num2));
          if ((int) num3 != obj0.\u0001\u0005())
            throw new ZipException(\u0008.\u000E\u0003(5384));
          if (obj0.\u001A\u0005() != (\u007F\u0002) num4)
            throw new ZipException(\u0008.\u000E\u0003(5441));
          if (obj0.\u0019\u0004() != (int) num2)
            throw new ZipException(\u0008.\u000E\u0003(5518));
          if (((int) num3 & 64) != 0 && num2 < (short) 62)
            throw new ZipException(\u0008.\u000E\u0003(5551));
          if (((int) num3 & 8192) != 0 && (num5 != (short) 0 || num6 != (short) 0))
            throw new ZipException(\u0008.\u000E\u0003(5624));
          if (((int) num3 & 8) == 0 && (int) num7 != (int) (uint) obj0.\u0018\u0005())
            throw new ZipException(\u0008.\u000E\u0003(5689));
          if (num9 == 0L && num8 == 0L && num7 != 0U)
            throw new ZipException(\u0008.\u000E\u0003(5746));
          if (\u0011\u0003.\u007E\u0004\u0002((object) obj0.\u0005\u0004()) > length1)
            throw new ZipException(\u0008.\u000E\u0003(5783));
          string str = \u0080\u0002.\u009B\u0004((int) num3, numArray1);
          if (\u0080\u0005.\u0002\u0002(str, obj0.\u0005\u0004()))
            throw new ZipException(\u0008.\u000E\u0003(5820));
          if (obj0.\u0080\u0005())
          {
            if (num9 > 0L)
              throw new ZipException(\u0008.\u000E\u0003(5889));
            if (obj0.\u009D\u0004())
            {
              if (num8 > 14L)
                throw new ZipException(\u0008.\u000E\u0003(5926));
            }
            else if (num8 > 2L)
              throw new ZipException(\u0008.\u000E\u0003(5926));
          }
          if (!\u0093\u0002.\u0005\u0006(str, true))
            throw new ZipException(\u0008.\u000E\u0003(5971));
        }
        if (((int) num3 & 8) == 0 || num9 > 0L || num8 > 0L)
        {
          if (num9 != obj0.\u0010\u0004())
            throw new ZipException(\u001D\u0003.\u001A\u0002(\u0008.\u000E\u0003(5992), (object) obj0.\u0010\u0004(), (object) num9));
          if (num8 != obj0.\u0016\u0005() && num8 != (long) uint.MaxValue && num8 != -1L)
            throw new ZipException(\u001D\u0003.\u001A\u0002(\u0008.\u000E\u0003(6077), (object) obj0.\u0016\u0005(), (object) num8));
        }
        int num10 = length1 + length2;
        return this.\u0007 + obj0.\u0005\u0005() + 30L + (long) num10;
      }
      finally
      {
        \u0093\u0003.\u009C\u0003((object) stream);
      }
    }

    private void \u0095\u0005()
    {
      this.\u0014 = (\u008F\u0002) null;
      this.\u0011 = (ArrayList) null;
      this.\u0012 = (Hashtable) null;
      if (this.\u0013 == null)
        return;
      this.\u0013.Dispose();
      this.\u0013 = (\u0090\u0002) null;
    }

    void IDisposable.\u0096\u0005() => this.Close();

    private void \u0097\u0005([In] bool obj0)
    {
      if (this.\u0002)
        return;
      this.\u0002 = true;
      this.\u0008 = new \u0081\u0002[0];
      if (this.\u008F\u0005() && this.\u0005 != null)
      {
        Stream stream;
        \u0093\u0003.\u009B\u0003((object) (stream = this.\u0005));
        try
        {
          \u0093\u0003.\u007E\u0006\u0005((object) this.\u0005);
        }
        finally
        {
          \u0093\u0003.\u009C\u0003((object) stream);
        }
      }
      this.\u0095\u0005();
    }

    protected virtual void Dispose([In] bool obj0) => this.\u0097\u0005(obj0);

    private ushort \u0098\u0005()
    {
      int num1 = \u0011\u0003.\u007E\u0010\u0005((object) this.\u0005);
      if (num1 < 0)
        throw new EndOfStreamException(\u0008.\u000E\u0003(6178));
      int num2 = \u0011\u0003.\u007E\u0010\u0005((object) this.\u0005);
      if (num2 < 0)
        throw new EndOfStreamException(\u0008.\u000E\u0003(6178));
      return (ushort) ((uint) (ushort) num1 | (uint) (ushort) (num2 << 8));
    }

    private uint \u0099\u0005() => (uint) this.\u0098\u0005() | (uint) this.\u0098\u0005() << 16;

    private ulong \u009A\u0005() => (ulong) this.\u0099\u0005() | (ulong) this.\u0099\u0005() << 32;

    private long \u009B\u0005([In] int obj0, [In] long obj1, [In] int obj2, [In] int obj3)
    {
      \u0092\u0002 obj = new \u0092\u0002(this.\u0005);
      try
      {
        return obj.\u009B\u0005(obj0, obj1, obj2, obj3);
      }
      finally
      {
        if (obj != null)
          \u0093\u0003.\u007E\u009E((object) obj);
      }
    }

    private void \u009C\u0005()
    {
      long num1 = \u0007\u0003.\u007E\u009F\u0004((object) this.\u0005) ? this.\u009B\u0005(101010256, \u007F\u0004.\u007E\u0003\u0005((object) this.\u0005), 22, (int) ushort.MaxValue) : throw new ZipException(\u0008.\u000E\u0003(6199));
      if (num1 < 0L)
        throw new ZipException(\u0008.\u000E\u0003(6244));
      ushort num2 = this.\u0098\u0005();
      ushort num3 = this.\u0098\u0005();
      ulong length1 = (ulong) this.\u0098\u0005();
      ulong num4 = (ulong) this.\u0098\u0005();
      ulong num5 = (ulong) this.\u0099\u0005();
      long num6 = (long) this.\u0099\u0005();
      uint length2 = (uint) this.\u0098\u0005();
      if (length2 > 0U)
      {
        byte[] numArray = new byte[(IntPtr) length2];
        \u009D.\u0093\u0003(this.\u0005, numArray);
        this.\u0003 = \u0080\u0002.\u009A\u0004(numArray);
      }
      else
        this.\u0003 = string.Empty;
      bool flag = false;
      if (num2 == ushort.MaxValue || num3 == ushort.MaxValue || length1 == (ulong) ushort.MaxValue || num4 == (ulong) ushort.MaxValue || num5 == (ulong) uint.MaxValue || num6 == (long) uint.MaxValue)
      {
        flag = true;
        if (this.\u009B\u0005(117853008, num1, 0, 4096) < 0L)
          throw new ZipException(\u0008.\u000E\u0003(6285));
        int num7 = (int) this.\u0099\u0005();
        ulong num8 = this.\u009A\u0005();
        int num9 = (int) this.\u0099\u0005();
        \u009F\u0004.\u007E\u0005\u0005((object) this.\u0005, (long) num8);
        if (this.\u0099\u0005() != 101075792U)
          throw new ZipException(\u008C\u0004.\u0019\u0002(\u0008.\u000E\u0003(6322), (object) num8));
        long num10 = (long) this.\u009A\u0005();
        int num11 = (int) this.\u0098\u0005();
        int num12 = (int) this.\u0098\u0005();
        int num13 = (int) this.\u0099\u0005();
        int num14 = (int) this.\u0099\u0005();
        length1 = this.\u009A\u0005();
        this.\u009A\u0005();
        num5 = this.\u009A\u0005();
        num6 = (long) this.\u009A\u0005();
      }
      this.\u0008 = new \u0081\u0002[length1];
      if (!flag && num6 < num1 - (4L + (long) num5))
      {
        this.\u0007 = num1 - (4L + (long) num5 + num6);
        if (this.\u0007 <= 0L)
          throw new ZipException(\u0008.\u000E\u0003(6391));
      }
      long num15 = \u0015\u0004.\u007E\u0008\u0005((object) this.\u0005, this.\u0007 + num6, SeekOrigin.Begin);
      for (ulong index = 0; index < length1; ++index)
      {
        if (this.\u0099\u0005() != 33639248U)
          throw new ZipException(\u0008.\u000E\u0003(6432));
        int num16 = (int) this.\u0098\u0005();
        int num17 = (int) this.\u0098\u0005();
        int num18 = (int) this.\u0098\u0005();
        int num19 = (int) this.\u0098\u0005();
        uint num20 = this.\u0099\u0005();
        uint num21 = this.\u0099\u0005();
        long num22 = (long) this.\u0099\u0005();
        long num23 = (long) this.\u0099\u0005();
        int num24 = (int) this.\u0098\u0005();
        int length3 = (int) this.\u0098\u0005();
        int num25 = (int) this.\u0098\u0005();
        int num26 = (int) this.\u0098\u0005();
        int num27 = (int) this.\u0098\u0005();
        uint num28 = this.\u0099\u0005();
        long num29 = (long) this.\u0099\u0005();
        byte[] numArray1 = new byte[\u0013\u0005.\u0083\u0003(num24, num25)];
        \u009D.\u0093\u0003(this.\u0005, numArray1, 0, num24);
        \u0081\u0002 obj = new \u0081\u0002(\u0080\u0002.\u009B\u0004(num18, numArray1, num24), num17, num16, (\u007F\u0002) num19);
        obj.\u0019\u0005((long) num21 & (long) uint.MaxValue);
        obj.\u0011\u0004(num23 & (long) uint.MaxValue);
        obj.\u0017\u0005(num22 & (long) uint.MaxValue);
        obj.\u0002\u0005(num18);
        obj.\u0013\u0005((long) num20);
        obj.\u0004\u0005((long) index);
        obj.\u0006\u0005(num29);
        obj.\u0008\u0005((int) num28);
        if ((num18 & 8) == 0)
          obj.\u009F\u0004((byte) (num21 >> 24));
        else
          obj.\u009F\u0004((byte) (num20 >> 8 & (uint) byte.MaxValue));
        if (length3 > 0)
        {
          byte[] numArray2 = new byte[length3];
          \u009D.\u0093\u0003(this.\u0005, numArray2);
          obj.\u001B\u0005(numArray2);
        }
        obj.\u001E\u0005(false);
        if (num25 > 0)
        {
          \u009D.\u0093\u0003(this.\u0005, numArray1, 0, num25);
          obj.\u007F\u0005(\u0080\u0002.\u009B\u0004(num18, numArray1, num25));
        }
        this.\u0008[index] = obj;
      }
    }

    private long \u009D\u0005([In] \u0081\u0002 obj0) => this.\u0094\u0005(obj0, \u0087\u0002.\u0089\u0002.\u0001);

    private Stream \u009E\u0005([In] Stream obj0, [In] \u0081\u0002 obj1)
    {
      CryptoStream cryptoStream;
      if (obj1.\u0019\u0004() < 50 || (obj1.\u0001\u0005() & 64) == 0)
      {
        \u0005\u0002 obj = new \u0005\u0002();
        this.\u008C\u0005(obj1.\u0005\u0004());
        if (!this.\u008E\u0005())
          throw new ZipException(\u0008.\u000E\u0003(6477));
        cryptoStream = new CryptoStream(obj0, \u008E\u0003.\u007E\u0005\u0006((object) obj, this.\u000E, (byte[]) null), CryptoStreamMode.Read);
        \u0087\u0002.\u009F\u0005(cryptoStream, obj1);
      }
      else
      {
        if (obj1.\u0019\u0004() != 51)
          throw new ZipException(\u0008.\u000E\u0003(6666));
        this.\u008C\u0005(obj1.\u0005\u0004());
        if (!this.\u008E\u0005())
          throw new ZipException(\u0008.\u000E\u0003(6534));
        int length = obj1.\u001D\u0005();
        byte[] numArray1 = new byte[length];
        int num1 = \u0089\u0005.\u007E\u000F\u0005((object) obj0, numArray1, 0, length);
        if (num1 != length)
        {
          object[] objArray = new object[4]
          {
            (object) \u0008.\u000E\u0003(6599),
            (object) length,
            (object) \u0008.\u000E\u0003(6624),
            (object) num1
          };
          throw new ZipException(\u008B\u0004.\u001E\u0002(objArray));
        }
        byte[] numArray2 = new byte[2];
        int num2 = \u0089\u0005.\u007E\u000F\u0005((object) obj0, numArray2, 0, 2);
        int num3 = obj1.\u001C\u0005() / 8;
        \u0007\u0002 obj = new \u0007\u0002(this.\u0004, numArray1, num3, false);
        byte[] numArray3 = obj.\u009A\u0003();
        if ((int) numArray3[0] != (int) numArray2[0] || (int) numArray3[1] != (int) numArray2[1])
          throw new Exception(\u0008.\u000E\u0003(6633));
        cryptoStream = (CryptoStream) new \u0006\u0002(obj0, obj, CryptoStreamMode.Read);
      }
      return (Stream) cryptoStream;
    }

    private static void \u009F\u0005([In] CryptoStream obj0, [In] \u0081\u0002 obj1)
    {
      byte[] numArray = new byte[12];
      \u009D.\u0093\u0003((Stream) obj0, numArray);
      if ((int) numArray[11] != (int) obj1.\u009E\u0004())
        throw new ZipException(\u0008.\u000E\u0003(6711));
    }

    internal delegate void \u0088\u0002(object sender, \u0086\u0002 e);

    [Flags]
    private enum \u0089\u0002
    {
      \u0001 = 1,
      \u0002 = 2,
    }

    private enum \u008A\u0002
    {
      \u0001,
      \u0002,
      \u0003,
    }

    private sealed class \u008B\u0002 : IComparer
    {
      public int Compare([In] object obj0, [In] object obj1)
      {
        \u0087\u0002.\u008C\u0002 obj2 = obj0 as \u0087\u0002.\u008C\u0002;
        \u0087\u0002.\u008C\u0002 obj3 = obj1 as \u0087\u0002.\u008C\u0002;
        int num1;
        if (obj2 == null)
          num1 = obj3 != null ? -1 : 0;
        else if (obj3 == null)
        {
          num1 = 1;
        }
        else
        {
          num1 = (obj2.\u0002\u0006() == \u0087\u0002.\u008A\u0002.\u0001 || obj2.\u0002\u0006() == \u0087\u0002.\u008A\u0002.\u0002 ? 0 : 1) - (obj3.\u0002\u0006() == \u0087\u0002.\u008A\u0002.\u0001 || obj3.\u0002\u0006() == \u0087\u0002.\u008A\u0002.\u0002 ? 0 : 1);
          if (num1 == 0)
          {
            long num2 = obj2.\u0001\u0006().\u0005\u0005() - obj3.\u0001\u0006().\u0005\u0005();
            num1 = num2 >= 0L ? (num2 != 0L ? 1 : 0) : -1;
          }
        }
        return num1;
      }
    }

    private sealed class \u008C\u0002
    {
      private \u0081\u0002 \u0001;
      private \u0087\u0002.\u008A\u0002 \u0002;

      [SpecialName]
      public \u0081\u0002 \u0001\u0006() => this.\u0001;

      [SpecialName]
      public \u0087\u0002.\u008A\u0002 \u0002\u0006() => this.\u0002;
    }

    private sealed class \u008D\u0002 : IEnumerator
    {
      private \u0081\u0002[] \u0001;
      private int \u0002 = -1;

      public \u008D\u0002([In] \u0081\u0002[] obj0) => this.\u0001 = obj0;

      [SpecialName]
      public object get_Current() => (object) this.\u0001[this.\u0002];

      public void Reset() => this.\u0002 = -1;

      public bool MoveNext() => ++this.\u0002 < this.\u0001.Length;
    }

    private sealed class \u008E\u0002 : Stream
    {
      private \u0087\u0002 \u0001;
      private Stream \u0002;
      private long \u0003;
      private long \u0004;
      private long \u0005;
      private long \u0006;

      public \u008E\u0002([In] \u0087\u0002 obj0, [In] long obj1, [In] long obj2)
      {
        this.\u0003 = obj1;
        this.\u0004 = obj2;
        this.\u0001 = obj0;
        this.\u0002 = this.\u0001.\u0005;
        this.\u0005 = obj1;
        this.\u0006 = obj1 + obj2;
      }

      public override int ReadByte()
      {
        if (this.\u0005 >= this.\u0006)
          return -1;
        Stream stream;
        \u0093\u0003.\u009B\u0003((object) (stream = this.\u0002));
        try
        {
          long num = \u0015\u0004.\u007E\u0008\u0005((object) this.\u0002, this.\u0005++, SeekOrigin.Begin);
          return \u0011\u0003.\u007E\u0010\u0005((object) this.\u0002);
        }
        finally
        {
          \u0093\u0003.\u009C\u0003((object) stream);
        }
      }

      public override void Close()
      {
      }

      public override int Read([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        Stream stream;
        \u0093\u0003.\u009B\u0003((object) (stream = this.\u0002));
        try
        {
          if ((long) obj2 > this.\u0006 - this.\u0005)
          {
            obj2 = (int) (this.\u0006 - this.\u0005);
            if (obj2 == 0)
              return 0;
          }
          long num1 = \u0015\u0004.\u007E\u0008\u0005((object) this.\u0002, this.\u0005, SeekOrigin.Begin);
          int num2 = \u0089\u0005.\u007E\u000F\u0005((object) this.\u0002, obj0, obj1, obj2);
          if (num2 > 0)
            this.\u0005 += (long) num2;
          return num2;
        }
        finally
        {
          \u0093\u0003.\u009C\u0003((object) stream);
        }
      }

      public override void Write([In] byte[] obj0, [In] int obj1, [In] int obj2) => throw new NotSupportedException();

      public override void SetLength([In] long obj0) => throw new NotSupportedException();

      public override long Seek([In] long obj0, [In] SeekOrigin obj1)
      {
        long num = this.\u0005;
        switch (obj1)
        {
          case SeekOrigin.Begin:
            num = this.\u0003 + obj0;
            break;
          case SeekOrigin.Current:
            num = this.\u0005 + obj0;
            break;
          case SeekOrigin.End:
            num = this.\u0006 + obj0;
            break;
        }
        if (num < this.\u0003)
          throw new ArgumentException(\u0008.\u000E\u0003(6736));
        this.\u0005 = num < this.\u0006 ? num : throw new IOException(\u0008.\u000E\u0003(6777));
        return this.\u0005;
      }

      public override void Flush()
      {
      }

      [SpecialName]
      public override long get_Position() => this.\u0005 - this.\u0003;

      [SpecialName]
      public override void set_Position([In] long obj0)
      {
        long num = this.\u0003 + obj0;
        if (num < this.\u0003)
          throw new ArgumentException(\u0008.\u000E\u0003(6736));
        this.\u0005 = num < this.\u0006 ? num : throw new InvalidOperationException(\u0008.\u000E\u0003(6777));
      }

      [SpecialName]
      public override long get_Length() => this.\u0004;

      [SpecialName]
      public override bool get_CanWrite() => false;

      [SpecialName]
      public override bool get_CanSeek() => true;

      [SpecialName]
      public override bool get_CanRead() => true;

      [SpecialName]
      public override bool get_CanTimeout() => \u0007\u0003.\u007E\u0001\u0005((object) this.\u0002);
    }
  }
}
