// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Monkey, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F37CDE57-2934-4BAC-94FE-68C4082667EF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.MSIL.Inject.aey-987a459213fe3739f0b3a9599a965c98fd7ffe48217cb7051649767b5815a87d.exe

using System;
using System.Collections;

internal sealed class \uE00A
{
  internal const int \uE000 = 32768;
  internal const int \uE001 = 258;
  internal const int \uE002 = 285;
  internal const int \uE003 = 287;
  internal const int \uE004 = 29;
  internal const int \uE005 = 31;
  internal const int \uE006 = 15;
  internal const int \uE007 = 256;
  internal const int \uE008 = 0;
  internal const int \uE009 = 1;
  internal const int \uE00A = 2;
  internal const int \uE00B = 16;
  internal const int \uE00C = 18;
  internal const int \uE00D = 16;
  internal const int \uE00E = 17;
  internal const int \uE00F = 18;
  private const int \uE010 = 257;
  internal static \uE00B[] \uE011 = new \uE00B[288];
  internal static \uE00B[] \uE012;
  internal static \uE00D \uE013;
  internal static readonly int[] \uE014;
  internal static readonly int[] \uE015;
  internal static readonly int[] \uE016;
  internal static readonly int[] \uE017;
  internal static readonly int[] \uE018;

  static \uE00A()
  {
label_2:
    int num1 = 46;
    int num2;
    int index1;
    while (true)
    {
      switch (num1)
      {
        case 0:
          \uE00A.\uE015 = new int[29];
          num1 = 53;
          continue;
        case 1:
          if (num2 != 0)
          {
            num1 = 54;
            continue;
          }
          goto label_59;
        case 2:
          \uE00A.\uE015[12] = 19;
          num1 = 29;
          continue;
        case 3:
          \uE00A.\uE015[20] = 67;
          num1 = 24;
          continue;
        case 4:
          \uE00A.\uE014[17] = 1;
          num1 = 36;
          continue;
        case 5:
          \uE00A.\uE014[10] = 11;
          num1 = 14;
          continue;
        case 6:
          index1 = 8;
          num1 = 40;
          continue;
        case 7:
          \uE00A.\uE015[23] = 115;
          num1 = 38;
          continue;
        case 8:
          \uE00A.\uE014[15] = 2;
          num1 = 25;
          continue;
        case 9:
          \uE00A.\uE015[25] = 163;
          num1 = 10;
          continue;
        case 10:
          \uE00A.\uE015[26] = 195;
          num1 = 35;
          continue;
        case 11:
          \uE00A.\uE015[11] = 17;
          num1 = 2;
          continue;
        case 12:
          \uE00A.\uE014[8] = 10;
          num1 = 30;
          continue;
        case 13:
          \uE00A.\uE015[22] = 99;
          num1 = 7;
          continue;
        case 14:
          \uE00A.\uE014[11] = 4;
          num1 = 22;
          continue;
        case 15:
          \uE00A.\uE016 = new int[29];
          num1 = 6;
          continue;
        case 16:
          \uE00A.\uE015[17] = 43;
          num1 = 41;
          continue;
        case 17:
          \uE00A.\uE014[1] = 17;
          num1 = 43;
          continue;
        case 18:
          \uE00A.\uE015[6] = 9;
          num1 = 42;
          continue;
        case 19:
          \uE00A.\uE014[14] = 13;
          num1 = 8;
          continue;
        case 20:
          \uE00A.\uE014[5] = 7;
          num1 = 50;
          continue;
        case 21:
          \uE00A.\uE015[15] = 31;
          num1 = 51;
          continue;
        case 22:
          \uE00A.\uE014[12] = 12;
          num1 = 44;
          continue;
        case 23:
          \uE00A.\uE014[7] = 6;
          num1 = 12;
          continue;
        case 24:
          \uE00A.\uE015[21] = 83;
          num1 = 13;
          continue;
        case 25:
          \uE00A.\uE014[16] = 14;
          num1 = 4;
          continue;
        case 26:
          \uE00A.\uE015[2] = 5;
          num1 = 47;
          continue;
        case 27:
          \uE00A.\uE015[1] = 4;
          num1 = 26;
          continue;
        case 28:
          \uE00A.\uE015[8] = 11;
          num1 = 48;
          continue;
        case 29:
          \uE00A.\uE015[13] = 23;
          num1 = 34;
          continue;
        case 30:
          \uE00A.\uE014[9] = 5;
          num1 = 5;
          continue;
        case 31:
          \uE00A.\uE015[10] = 15;
          num1 = 11;
          continue;
        case 32:
          \uE00A.\uE015[4] = 7;
          num1 = 49;
          continue;
        case 33:
          \uE00A.\uE014[4] = 8;
          num1 = 20;
          continue;
        case 34:
          \uE00A.\uE015[14] = 27;
          num1 = 21;
          continue;
        case 35:
          \uE00A.\uE015[27] = 227;
          num1 = 52;
          continue;
        case 36:
          \uE00A.\uE014[18] = 15;
          num1 = 0;
          continue;
        case 37:
          \uE00A.\uE014 = new int[19];
          num1 = 45;
          continue;
        case 38:
          \uE00A.\uE015[24] = 131;
          num1 = 9;
          continue;
        case 39:
          \uE00A.\uE015[19] = 59;
          num1 = 3;
          continue;
        case 40:
          num2 = 0;
          num1 = 1;
          continue;
        case 41:
          \uE00A.\uE015[18] = 51;
          num1 = 39;
          continue;
        case 42:
          \uE00A.\uE015[7] = 10;
          num1 = 28;
          continue;
        case 43:
          \uE00A.\uE014[2] = 18;
          num1 = 33;
          continue;
        case 44:
          \uE00A.\uE014[13] = 3;
          num1 = 19;
          continue;
        case 45:
          \uE00A.\uE014[0] = 16;
          num1 = 17;
          continue;
        case 46:
          \uE00A.\uE012 = new \uE00B[32];
          num1 = 37;
          continue;
        case 47:
          \uE00A.\uE015[3] = 6;
          num1 = 32;
          continue;
        case 48:
          \uE00A.\uE015[9] = 13;
          num1 = 31;
          continue;
        case 49:
          \uE00A.\uE015[5] = 8;
          num1 = 18;
          continue;
        case 50:
          \uE00A.\uE014[6] = 9;
          num1 = 23;
          continue;
        case 51:
          \uE00A.\uE015[16] = 35;
          num1 = 16;
          continue;
        case 52:
          \uE00A.\uE015[28] = 258;
          num1 = 15;
          continue;
        case 53:
          \uE00A.\uE015[0] = 3;
          num1 = 27;
          continue;
        case 54:
          goto label_58;
        default:
          goto label_2;
      }
    }
label_58:
    int num3 = 0;
    goto label_60;
label_59:
    num3 = 1;
label_60:
    if (num3 != 0)
      goto label_64;
label_61:
    if (index1 % 4 == 0)
      ++num2;
    \uE00A.\uE016[index1] = num2;
    ++index1;
label_64:
    if (index1 >= 28)
    {
      \uE00A.\uE017 = new int[30];
      \uE00A.\uE017[0] = 1;
      \uE00A.\uE017[1] = 2;
      \uE00A.\uE017[2] = 3;
      \uE00A.\uE017[3] = 4;
      \uE00A.\uE017[4] = 5;
      \uE00A.\uE017[5] = 7;
      \uE00A.\uE017[6] = 9;
      \uE00A.\uE017[7] = 13;
      \uE00A.\uE017[8] = 17;
      \uE00A.\uE017[9] = 25;
      \uE00A.\uE017[10] = 33;
      \uE00A.\uE017[11] = 49;
      \uE00A.\uE017[12] = 65;
      \uE00A.\uE017[13] = 97;
      \uE00A.\uE017[14] = 129;
      \uE00A.\uE017[15] = 193;
      \uE00A.\uE017[16] = 257;
      \uE00A.\uE017[17] = 385;
      \uE00A.\uE017[18] = 513;
      \uE00A.\uE017[19] = 769;
      \uE00A.\uE017[20] = 1025;
      \uE00A.\uE017[21] = 1537;
      \uE00A.\uE017[22] = 2049;
      \uE00A.\uE017[23] = 3073;
      \uE00A.\uE017[24] = 4097;
      \uE00A.\uE017[25] = 6145;
      \uE00A.\uE017[26] = 8193;
      \uE00A.\uE017[27] = 12289;
      \uE00A.\uE017[28] = 16385;
      \uE00A.\uE017[29] = 24577;
      \uE00A.\uE018 = new int[30];
      int index2 = 4;
      int num4 = 0;
      for (; index2 < 30; ++index2)
      {
        if (index2 % 2 == 0)
          ++num4;
        \uE00A.\uE018[index2] = num4;
      }
      for (int index3 = 0; index3 <= 143; ++index3)
      {
        \uE00A.\uE011[index3].\uE000 = 48 + index3;
        \uE00A.\uE011[index3].\uE001 = 8;
      }
      for (int index4 = 144; index4 <= (int) byte.MaxValue; ++index4)
      {
        \uE00A.\uE011[index4].\uE000 = 400 + index4 - 144;
        \uE00A.\uE011[index4].\uE001 = 9;
      }
      for (int index5 = 256; index5 <= 279; ++index5)
      {
        \uE00A.\uE011[index5].\uE000 = index5 - 256;
        \uE00A.\uE011[index5].\uE001 = 7;
      }
      for (int index6 = 280; index6 <= 287; ++index6)
      {
        \uE00A.\uE011[index6].\uE000 = 192 + index6 - 280;
        \uE00A.\uE011[index6].\uE001 = 8;
      }
      for (int index7 = 0; index7 <= 31; ++index7)
      {
        \uE00A.\uE012[index7].\uE000 = index7;
        \uE00A.\uE012[index7].\uE001 = 5;
      }
      \uE00A.\uE013 = \uE00A.\uE004(\uE00A.\uE011, \uE00A.\uE012);
    }
    else
      goto label_61;
  }

  internal static int \uE000(int[] _param0, int[] _param1)
  {
    int num1 = 0;
    int index = 0;
    if ((index == 0 ? 1 : 0) != 0)
      goto label_5;
    else
      goto label_2;
label_1:
    int num2;
    switch (num2)
    {
      case 0:
        goto label_3;
      case 1:
        ++index;
        goto label_5;
    }
label_2:
    num2 = 0;
    goto label_1;
label_3:
    num1 += _param0[index] * _param1[index];
    num2 = 1;
    goto label_1;
label_5:
    if (index >= _param0.Length)
      return num1;
    goto label_3;
  }

  internal static int \uE001(int[] _param0, int[] _param1)
  {
    int num1 = 0;
    int index1 = 0;
    if ((index1 == 0 ? 1 : 0) != 0)
      goto label_5;
    else
      goto label_2;
label_1:
    int num2;
    switch (num2)
    {
      case 0:
        goto label_3;
      case 1:
        ++index1;
        goto label_5;
    }
label_2:
    num2 = 0;
    goto label_1;
label_3:
    num1 += _param0[index1] * \uE00A.\uE011[index1].\uE001;
    num2 = 1;
    goto label_1;
label_5:
    if (index1 >= _param0.Length)
    {
      for (int index2 = 0; index2 < _param1.Length; ++index2)
        num1 += _param1[index2] * \uE00A.\uE012[index2].\uE001;
      return num1;
    }
    goto label_3;
  }

  internal static \uE00B[] \uE002(int[] _param0)
  {
    \uE00B[] objArray = new \uE00B[_param0.Length];
    int index = 0;
    if ((index == 0 ? 1 : 0) != 0)
      goto label_5;
    else
      goto label_2;
label_1:
    int num;
    switch (num)
    {
      case 0:
        goto label_3;
      case 1:
        ++index;
        goto label_5;
    }
label_2:
    num = 0;
    goto label_1;
label_3:
    objArray[index].\uE001 = _param0[index];
    num = 1;
    goto label_1;
label_5:
    if (index >= _param0.Length)
    {
      \uE00A.\uE003(objArray);
      return objArray;
    }
    goto label_3;
  }

  internal static void \uE003(\uE00B[] _param0)
  {
    int num1 = _param0[0].\uE001;
    int index1 = 1;
    if ((index1 == 0 ? 0 : 1) != 0)
      goto label_4;
label_1:
    if (num1 < _param0[index1].\uE001)
      num1 = _param0[index1].\uE001;
    ++index1;
label_4:
    if (index1 >= _param0.Length)
    {
      int[] numArray1 = new int[num1 + 1];
      for (int index2 = 0; index2 < _param0.Length; ++index2)
        ++numArray1[_param0[index2].\uE001];
      int[] numArray2 = new int[num1 + 1];
label_10:
      int num2 = 0;
      int num3;
      int index3;
      while (true)
      {
        switch (num2)
        {
          case 0:
            num3 = 0;
            num2 = 1;
            continue;
          case 1:
            numArray1[0] = 0;
            num2 = 2;
            continue;
          case 2:
            index3 = 1;
            num2 = 3;
            continue;
          case 3:
            goto label_16;
          default:
            goto label_10;
        }
      }
label_16:
      for (; index3 <= num1; ++index3)
      {
        num3 = num3 + numArray1[index3 - 1] << 1;
        numArray2[index3] = num3;
      }
      for (int index4 = 0; index4 < _param0.Length; ++index4)
      {
        int index5 = _param0[index4].\uE001;
        if (index5 != 0)
        {
          _param0[index4].\uE000 = numArray2[index5];
          ++numArray2[index5];
        }
      }
    }
    else
      goto label_1;
  }

  internal static \uE00D \uE004(\uE00B[] _param0, \uE00B[] _param1) => new \uE00D()
  {
    \uE000 = \uE00A.\uE005(_param0),
    \uE001 = \uE00A.\uE005(_param1)
  };

  internal static \uE00C \uE005(\uE00B[] _param0)
  {
    \uE00A.\uE008[] objArray = new \uE00A.\uE008[_param0.Length];
    int num1 = 0;
    int index = 0;
    if ((index == 0 ? 1 : 0) != 0)
      goto label_9;
label_1:
    if (_param0[index].\uE001 > 0)
    {
      \uE00A.\uE008 obj = new \uE00A.\uE008();
label_4:
      int num2 = 0;
      while (true)
      {
        switch (num2)
        {
          case 0:
            obj.\uE000 = _param0[index];
            num2 = 1;
            continue;
          case 1:
            obj.\uE001 = (ushort) index;
            num2 = 2;
            continue;
          case 2:
            goto label_7;
          default:
            goto label_4;
        }
      }
label_7:
      objArray[num1++] = obj;
    }
    ++index;
label_9:
    if (index >= _param0.Length)
    {
      if (_param0.Length < 1)
        throw new InvalidOperationException();
      return \uE00A.\uE006(objArray, num1, 0, 0);
    }
    goto label_1;
  }

  private static \uE00C \uE006(
    \uE00A.\uE008[] _param0,
    int _param1,
    int _param2,
    int _param3)
  {
    \uE00A.\uE008[] objArray1 = new \uE00A.\uE008[_param1];
    \uE00A.\uE008[] objArray2 = new \uE00A.\uE008[_param1];
    \uE00C obj1 = new \uE00C();
    obj1.\uE000 = false;
    int num1;
    int num2 = num1 = 0;
    int index = 0;
    if ((index == 0 ? 1 : 0) != 0)
      goto label_11;
label_1:
    \uE00A.\uE008 obj2 = _param0[index];
    if (obj2.\uE000.\uE001 == _param3 && obj2.\uE000.\uE000 == _param2)
    {
      obj1.\uE000 = true;
      obj1.\uE001 = obj2.\uE001;
    }
    else
    {
      bool flag = (obj2.\uE000.\uE000 >> obj2.\uE000.\uE001 - _param3 - 1 & 1) != 0;
label_5:
      int num3 = 0;
      while (true)
      {
        switch (num3)
        {
          case 0:
            if (flag)
            {
              num3 = 1;
              continue;
            }
            goto label_9;
          case 1:
            objArray2[num2++] = obj2;
            num3 = 2;
            continue;
          case 2:
            goto label_10;
          default:
            goto label_5;
        }
      }
label_9:
      objArray1[num1++] = obj2;
    }
label_10:
    ++index;
label_11:
    if (index >= _param1)
    {
      if (obj1.\uE000)
      {
        if (num2 > 0 || num1 > 0)
          throw new InvalidOperationException();
      }
      else
      {
        if (num1 > 0)
          obj1.\uE002 = \uE00A.\uE006(objArray1, num1, _param2 << 1, _param3 + 1);
        if (num2 > 0)
          obj1.\uE003 = \uE00A.\uE006(objArray2, num2, _param2 << 1 | 1, _param3 + 1);
      }
      return obj1;
    }
    goto label_1;
  }

  internal static void \uE007(int _param0, out int _param1, out int _param2)
  {
    _param1 = \uE00A.\uE015[_param0 - 257];
label_2:
    int num = 0;
    while (true)
    {
      switch (num)
      {
        case 0:
          _param2 = \uE00A.\uE016[_param0 - 257];
          num = 1;
          continue;
        case 1:
          goto label_4;
        default:
          goto label_2;
      }
    }
label_4:;
  }

  internal static void \uE008(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE00A.\uE015, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index + 257;
label_4:
    int num = 0;
    while (true)
    {
      switch (num)
      {
        case 0:
          _param2 = _param0 - \uE00A.\uE015[index];
          num = 1;
          continue;
        case 1:
          _param3 = \uE00A.\uE016[index];
          num = 2;
          continue;
        case 2:
          goto label_7;
        default:
          goto label_4;
      }
    }
label_7:;
  }

  internal static void \uE009(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE00A.\uE017, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index;
label_4:
    int num = 0;
    while (true)
    {
      switch (num)
      {
        case 0:
          _param2 = _param0 - \uE00A.\uE017[index];
          num = 1;
          continue;
        case 1:
          _param3 = \uE00A.\uE018[index];
          num = 2;
          continue;
        case 2:
          goto label_7;
        default:
          goto label_4;
      }
    }
label_7:;
  }

  internal static int[] \uE00A(int[] _param0, int _param1) => \uE00A.\uE000.\uE000(_param0, _param1);

  internal static int[] \uE00B(int[] _param0) => \uE00A.\uE000.\uE000(_param0, 15);

  internal static int \uE00C(int _param0)
  {
    int num1 = _param0;
label_2:
    int num2 = 0;
    while (true)
    {
      switch (num2)
      {
        case 0:
          switch (num1)
          {
            case 16:
              goto label_5;
            case 17:
              goto label_6;
            case 18:
              goto label_7;
            default:
              num2 = 1;
              continue;
          }
        case 1:
          goto label_8;
        default:
          goto label_2;
      }
    }
label_5:
    return 2;
label_6:
    return 3;
label_7:
    return 7;
label_8:
    return 0;
  }

  internal static int[] \uE00D(int[] _param0, int _param1, int _param2)
  {
    ArrayList arrayList = new ArrayList();
    int num1 = 0;
    if ((num1 == 0 ? 1 : 0) != 0)
      goto label_22;
label_1:
    if (_param0[_param1 + num1] == 0)
    {
      int num2 = 0;
      do
      {
        ++num2;
      }
      while (num1 + num2 < _param2 && num2 < 138 && _param0[_param1 + num1 + num2] == 0);
      if (num2 < 3)
      {
        if (num2 >= 1)
          arrayList.Add((object) 0);
        if (num2 >= 2)
          arrayList.Add((object) 0);
      }
      else if (num2 < 11)
      {
        arrayList.Add((object) 17);
        arrayList.Add((object) (num2 - 3));
      }
      else
      {
        arrayList.Add((object) 18);
        arrayList.Add((object) (num2 - 11));
      }
      num1 += num2;
    }
    else
    {
      int num3 = _param0[_param1 + num1++];
label_15:
      int num4 = 1;
      int num5;
      while (true)
      {
        switch (num4)
        {
          case 0:
            num5 = 0;
            num4 = 2;
            continue;
          case 1:
            arrayList.Add((object) num3);
            num4 = 0;
            continue;
          case 2:
            goto label_19;
          default:
            goto label_15;
        }
      }
label_19:
      while (num1 + num5 < _param2 && num5 < 6 && _param0[_param1 + num1 + num5] == num3)
        ++num5;
      if (num5 >= 3)
      {
        arrayList.Add((object) 16);
        arrayList.Add((object) (num5 - 3));
        num1 += num5;
      }
    }
label_22:
    if (num1 >= _param2)
      return (int[]) arrayList.ToArray(typeof (int));
    goto label_1;
  }

  private sealed class \uE000
  {
    internal static int[] \uE000(int[] _param0, int _param1)
    {
      int[] items = new int[_param0.Length];
      int[] numArray1 = new int[_param0.Length];
      int index1 = 0;
      if ((index1 == 0 ? 1 : 0) != 0)
        goto label_2;
label_1:
      items[index1] = index1;
      ++index1;
label_2:
      if (index1 >= items.Length)
      {
        Array.Copy((Array) _param0, (Array) numArray1, _param0.Length);
        Array.Sort<int, int>(numArray1, items);
        int sourceIndex = 0;
        while (sourceIndex < numArray1.Length && numArray1[sourceIndex] == 0)
          ++sourceIndex;
        int[] destinationArray = new int[numArray1.Length - sourceIndex];
label_8:
        int num = 1;
        int[] numArray2;
        while (true)
        {
          switch (num)
          {
            case 0:
              if (destinationArray.Length == 0)
              {
                num = 2;
                continue;
              }
              goto label_13;
            case 1:
              Array.Copy((Array) numArray1, sourceIndex, (Array) destinationArray, 0, destinationArray.Length);
              num = 0;
              continue;
            case 2:
              numArray2 = new int[0];
              num = 3;
              continue;
            case 3:
              goto label_16;
            default:
              goto label_8;
          }
        }
label_13:
        if (destinationArray.Length == 1)
          numArray2 = new int[1]{ 1 };
        else
          numArray2 = \uE00A.\uE000.\uE001(destinationArray, _param1);
label_16:
        int[] numArray3 = new int[_param0.Length];
        for (int index2 = 0; index2 < numArray2.Length; ++index2)
          numArray3[items[index2 + sourceIndex]] = numArray2[index2];
        return numArray3;
      }
      goto label_1;
    }

    private static int[] \uE001(int[] _param0, int _param1)
    {
      int length = _param0.Length;
label_2:
      int num1 = 3;
      int[][] numArray1;
      int index1;
      int[] numArray2;
      while (true)
      {
        switch (num1)
        {
          case 0:
            numArray1[0] = _param0;
            num1 = 2;
            continue;
          case 1:
            if (index1 != 0)
            {
              num1 = 5;
              continue;
            }
            goto label_10;
          case 2:
            numArray2 = new int[_param0.Length / 2];
            num1 = 4;
            continue;
          case 3:
            numArray1 = new int[_param1][];
            num1 = 0;
            continue;
          case 4:
            index1 = 0;
            num1 = 1;
            continue;
          case 5:
            goto label_9;
          default:
            goto label_2;
        }
      }
label_9:
      int num2 = 0;
      goto label_11;
label_10:
      num2 = 1;
label_11:
      if (num2 != 0)
        goto label_13;
label_12:
      numArray2[index1] = _param0[index1 * 2] + _param0[index1 * 2 + 1];
      ++index1;
label_13:
      if (index1 >= numArray2.Length)
      {
        for (int index2 = 1; index2 < _param1; ++index2)
        {
          int[] numArray3 = \uE00A.\uE000.\uE002(numArray2, _param0);
          numArray1[index2] = numArray3;
          numArray2 = new int[numArray3.Length / 2];
          for (int index3 = 0; index3 < numArray2.Length; ++index3)
            numArray2[index3] = numArray3[index3 * 2] + numArray3[index3 * 2 + 1];
        }
        int[] numArray4 = new int[length];
        int num3 = length - 1;
        for (int index4 = _param1 - 1; index4 >= 0; --index4)
        {
          int[] numArray5 = numArray1[index4];
          int num4 = 0;
          int index5 = 0;
          for (int index6 = 0; index6 < num3 * 2; ++index6)
          {
            if (index5 < _param0.Length && _param0[index5] == numArray5[index6])
            {
              ++numArray4[index5];
              ++index5;
            }
            else
              ++num4;
          }
          num3 = num4;
        }
        return numArray4;
      }
      goto label_12;
    }

    private static int[] \uE002(int[] _param0, int[] _param1)
    {
      int[] numArray = new int[_param0.Length + _param1.Length];
label_2:
      int num1 = 3;
      int index1;
      int num2;
      int index2;
      while (true)
      {
        switch (num1)
        {
          case 0:
            index1 = 0;
            num1 = 2;
            continue;
          case 1:
            if (num2 != 0)
            {
              num1 = 4;
              continue;
            }
            goto label_9;
          case 2:
            num2 = 0;
            num1 = 1;
            continue;
          case 3:
            index2 = 0;
            num1 = 0;
            continue;
          case 4:
            goto label_8;
          default:
            goto label_2;
        }
      }
label_8:
      int num3 = 0;
      goto label_10;
label_9:
      num3 = 1;
label_10:
      if (num3 != 0)
        goto label_12;
label_11:
      numArray[num2++] = _param0[index2] >= _param1[index1] ? _param1[index1++] : _param0[index2++];
label_12:
      if (index2 >= _param0.Length || index1 >= _param1.Length)
      {
        while (index2 < _param0.Length)
          numArray[num2++] = _param0[index2++];
        while (index1 < _param1.Length)
          numArray[num2++] = _param1[index1++];
        return numArray;
      }
      goto label_11;
    }
  }

  private struct \uE008
  {
    internal \uE00B \uE000;
    internal ushort \uE001;
  }
}
