// Decompiled with JetBrains decompiler
// Type: DirectX.Capture.SourceCollection
// Assembly: p, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 91D63E37-42E0-404C-97F4-07116ACD2D57
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.KillAV.ao-27eafab1bfbe5012a9dd5eb6a22a5e09a25b91a1b79c55ba29e0e7098dcc6f9f.exe

using DShowNET;
using System;
using System.Collections;
using System.Runtime.InteropServices;

namespace DirectX.Capture
{
  public class SourceCollection : CollectionBase, IDisposable
  {
    internal SourceCollection() => this.InnerList.Capacity = 1;

    internal SourceCollection(
      ICaptureGraphBuilder2 graphBuilder,
      IBaseFilter deviceFilter,
      bool isVideoDevice)
    {
      this.addFromGraph(graphBuilder, deviceFilter, isVideoDevice);
    }

    ~SourceCollection() => this.Dispose();

    public Source this[int index] => (Source) this.InnerList[index];

    internal Source CurrentSource
    {
      get
      {
        foreach (Source inner in this.InnerList)
        {
          if (inner.Enabled)
            return inner;
        }
        return (Source) null;
      }
      set
      {
        if (value == null)
        {
          foreach (Source inner in this.InnerList)
            inner.Enabled = false;
        }
        else if (value is CrossbarSource)
        {
          value.Enabled = true;
        }
        else
        {
          foreach (Source inner in this.InnerList)
            inner.Enabled = false;
          value.Enabled = true;
        }
      }
    }

    public new void Clear()
    {
      for (int index = 0; index < this.InnerList.Count; ++index)
        this[index].Dispose();
      this.InnerList.Clear();
    }

    public void Dispose()
    {
      this.Clear();
      this.InnerList.Capacity = 1;
    }

    protected void addFromGraph(
      ICaptureGraphBuilder2 graphBuilder,
      IBaseFilter deviceFilter,
      bool isVideoDevice)
    {
      foreach (IAMCrossbar crossbar in this.findCrossbars(graphBuilder, deviceFilter))
        this.InnerList.AddRange((ICollection) this.findCrossbarSources(graphBuilder, crossbar, isVideoDevice));
      if (isVideoDevice || this.InnerList.Count != 0)
        return;
      this.InnerList.AddRange((ICollection) this.findAudioSources(graphBuilder, deviceFilter));
    }

    protected ArrayList findCrossbars(
      ICaptureGraphBuilder2 graphBuilder,
      IBaseFilter deviceFilter)
    {
      ArrayList crossbars = new ArrayList();
      Guid upstreamOnly = FindDirection.UpstreamOnly;
      Guid pType = new Guid();
      Guid guid = typeof (IAMCrossbar).GUID;
      object ppint1 = (object) null;
      object ppint2 = (object) null;
      int num = graphBuilder.FindInterface(ref upstreamOnly, ref pType, deviceFilter, ref guid, out ppint1);
      while (num == 0 && ppint1 != null)
      {
        if (ppint1 is IAMCrossbar)
        {
          crossbars.Add((object) (ppint1 as IAMCrossbar));
          num = graphBuilder.FindInterface(ref upstreamOnly, ref pType, ppint1 as IBaseFilter, ref guid, out ppint2);
          ppint1 = ppint2;
        }
        else
          ppint1 = (object) null;
      }
      return crossbars;
    }

    protected ArrayList findCrossbarSources(
      ICaptureGraphBuilder2 graphBuilder,
      IAMCrossbar crossbar,
      bool isVideoDevice)
    {
      ArrayList crossbarSources = new ArrayList();
      int OutputPinCount;
      int InputPinCount;
      int pinCounts = crossbar.get_PinCounts(out OutputPinCount, out InputPinCount);
      if (pinCounts < 0)
        Marshal.ThrowExceptionForHR(pinCounts);
      for (int index1 = 0; index1 < OutputPinCount; ++index1)
      {
        for (int index2 = 0; index2 < InputPinCount; ++index2)
        {
          if (crossbar.CanRoute(index1, index2) == 0)
          {
            PhysicalConnectorType PhysicalType;
            int crossbarPinInfo = crossbar.get_CrossbarPinInfo(true, index2, out int _, out PhysicalType);
            if (crossbarPinInfo < 0)
              Marshal.ThrowExceptionForHR(crossbarPinInfo);
            CrossbarSource crossbarSource = new CrossbarSource(crossbar, index1, index2, PhysicalType);
            if (PhysicalType < PhysicalConnectorType.Audio_Tuner)
            {
              if (isVideoDevice)
                crossbarSources.Add((object) crossbarSource);
              else if (!isVideoDevice)
                crossbarSources.Add((object) crossbarSource);
            }
          }
        }
      }
      int index3 = 0;
      while (index3 < crossbarSources.Count)
      {
        bool flag = false;
        CrossbarSource crossbarSource1 = (CrossbarSource) crossbarSources[index3];
        for (int index4 = 0; index4 < crossbarSources.Count; ++index4)
        {
          CrossbarSource crossbarSource2 = (CrossbarSource) crossbarSources[index4];
          if (crossbarSource1.OutputPin == crossbarSource2.OutputPin && index3 != index4)
          {
            flag = true;
            break;
          }
        }
        if (flag)
          ++index3;
        else
          crossbarSources.RemoveAt(index3);
      }
      return crossbarSources;
    }

    protected ArrayList findAudioSources(
      ICaptureGraphBuilder2 graphBuilder,
      IBaseFilter deviceFilter)
    {
      ArrayList audioSources = new ArrayList();
      if (deviceFilter is IAMAudioInputMixer)
      {
        IEnumPins ppEnum;
        int num1 = deviceFilter.EnumPins(out ppEnum);
        ppEnum.Reset();
        if (num1 == 0 && ppEnum != null)
        {
          IPin[] ppPins = new IPin[1];
          int num2;
          do
          {
            num2 = ppEnum.Next(1, ppPins, out int _);
            if (num2 == 0 && ppPins[0] != null)
            {
              PinDirection pPinDir = PinDirection.Output;
              num2 = ppPins[0].QueryDirection(out pPinDir);
              if (num2 == 0 && pPinDir == PinDirection.Input)
              {
                AudioSource audioSource = new AudioSource(ppPins[0]);
                audioSources.Add((object) audioSource);
              }
              ppPins[0] = (IPin) null;
            }
          }
          while (num2 == 0);
          Marshal.ReleaseComObject((object) ppEnum);
          ppEnum = (IEnumPins) null;
        }
      }
      if (audioSources.Count == 1)
        audioSources.Clear();
      return audioSources;
    }
  }
}
