// Decompiled with JetBrains decompiler
// Type: CJnBzQT
// Assembly: test1, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E8116EE9-6C79-4180-A1B1-1330F6BC88B7
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.MSIL.Petun.a-47e879175f4baac8d24e5f7eba026a7e6b2e35fefbd029453110345a2057ecce.exe

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

internal class CJnBzQT : IDisposable
{
  private readonly object mMutex;
  private bool _mMutexOwned;

  [MethodImpl(MethodImplOptions.NoInlining)]
  public CJnBzQT(string name)
  {
    CJnBzQT.gwIohX6QmCYEPDWZZIs();
    int num = CJnBzQT.\u0030DUw3o6aUyoqB3a4q74() ? 4 : 2;
    while (true)
    {
      switch (num)
      {
        case 0:
        case 2:
          CJnBzQT.rKbD0k6wFQbcyvVkRbd((object) this);
          goto case 1;
        case 1:
        case 4:
          this.mMutex = (object) new Mutex(false, name);
          goto case 3;
        case 3:
          this._mMutexOwned = false;
          num = 5;
          continue;
        case 5:
          goto label_3;
        default:
          num = 3;
          continue;
      }
    }
label_3:;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public bool IsRunning()
  {
    this._mMutexOwned = CJnBzQT.KA3mRN6NDw5caL84h1A(this.mMutex, 0, true);
    return !this._mMutexOwned;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public void Dispose()
  {
    if (!this._mMutexOwned)
      return;
    CJnBzQT.khbDXA6jhmpL3LuxKIu(this.mMutex);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static void rKbD0k6wFQbcyvVkRbd([In] object obj0) => obj0.\u002Ector();

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool gwIohX6QmCYEPDWZZIs() => true;

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool \u0030DUw3o6aUyoqB3a4q74() => false;

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool KA3mRN6NDw5caL84h1A([In] object obj0, [In] int obj1, [In] bool obj2) => ((WaitHandle) obj0).WaitOne(obj1, obj2);

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static void khbDXA6jhmpL3LuxKIu([In] object obj0) => ((Mutex) obj0).ReleaseMutex();
}
