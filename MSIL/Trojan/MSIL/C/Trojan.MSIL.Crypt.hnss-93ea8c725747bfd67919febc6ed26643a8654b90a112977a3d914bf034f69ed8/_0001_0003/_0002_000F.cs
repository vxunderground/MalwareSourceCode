// Decompiled with JetBrains decompiler
// Type: .
// Assembly: !, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 557A2E9F-07C1-4548-9113-1357BAD65653
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.Crypt.hnss-93ea8c725747bfd67919febc6ed26643a8654b90a112977a3d914bf034f69ed8.exe

using \u0001\u0002;
using \u0001\u0003;
using System;
using System.IO;

namespace \u0001\u0003
{
  public class \u0002\u000F : \u0003\u0012, I\u0001\u000E, \u0003\u0011
  {
    private const uint \u0003\u0008 = 1024;
    private const uint \u0003\u000A = 65536;
    private const uint \u0003\u0005 = 65536;
    private const uint \u0003\u000E = 1;
    private const uint \u0003\u0009 = 1024;
    private const uint \u0003\u0006 = 0;
    private const uint \u0003\u000B = 2147483647;
    private uint \u0002\u001D;
    private uint \u0002\u001E;
    private uint \u0003\u0002;
    private uint[] \u0003\u0003;
    private uint[] \u0002\u001F;
    private uint \u0002\u001C = (uint) byte.MaxValue;
    private uint \u0003;
    private uint \u0003\u0001;
    private bool \u0003\u0004 = true;
    private uint \u0003\u000D;
    private uint \u0003\u000C = 4;
    private uint \u0003\u0007 = 66560;

    public void \u0002\u001A(int numHashBytes)
    {
      this.\u0003\u0004 = numHashBytes > 2;
      if (this.\u0003\u0004)
      {
        this.\u0003\u000D = 0U;
        this.\u0003\u000C = 4U;
        this.\u0003\u0007 = 66560U;
      }
      else
      {
        this.\u0003\u000D = 2U;
        this.\u0003\u000C = 3U;
        this.\u0003\u0007 = 0U;
      }
    }

    public new void \u0002\u0019(Stream stream) => base.\u0002\u0019(stream);

    public new void \u0002\u0017() => base.\u0002\u0017();

    public new void \u0001\u001B()
    {
      base.\u0001\u001B();
      for (uint index = 0; index < this.\u0003\u0001; ++index)
        this.\u0002\u001F[(IntPtr) index] = 0U;
      this.\u0002\u001D = 0U;
      this.\u0003\u0016(-1);
    }

    public new void \u0002\u0015()
    {
      if (++this.\u0002\u001D >= this.\u0002\u001E)
        this.\u0002\u001D = 0U;
      base.\u0002\u0015();
      if (this.\u0003\u001E != (uint) int.MaxValue)
        return;
      this.\u0003\u0010();
    }

    public new byte \u0002\u0011(int index) => base.\u0002\u0011(index);

    public new uint \u0002\u0013(int index, uint distance, uint limit) => base.\u0002\u0013(index, distance, limit);

    public new uint \u0002\u0014() => base.\u0002\u0014();

    public void \u0002\u0010(
      uint historySize,
      uint keepAddBufferBefore,
      uint matchMaxLen,
      uint keepAddBufferAfter)
    {
      if (historySize > 2147483391U)
        throw new Exception();
      this.\u0002\u001C = 16U + (matchMaxLen >> 1);
      uint keepSizeReserv = (historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2U + 256U;
      this.\u0002\u0010(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, keepSizeReserv);
      this.\u0003\u0002 = matchMaxLen;
      uint num1 = historySize + 1U;
      if ((int) this.\u0002\u001E != (int) num1)
        this.\u0003\u0003 = new uint[(IntPtr) ((this.\u0002\u001E = num1) * 2U)];
      uint num2 = 65536;
      if (this.\u0003\u0004)
      {
        uint num3 = historySize - 1U;
        uint num4 = num3 | num3 >> 1;
        uint num5 = num4 | num4 >> 2;
        uint num6 = num5 | num5 >> 4;
        uint num7 = (num6 | num6 >> 8) >> 1 | (uint) ushort.MaxValue;
        if (num7 > 16777216U)
          num7 >>= 1;
        this.\u0003 = num7;
        num2 = num7 + 1U + this.\u0003\u0007;
      }
      if ((int) num2 == (int) this.\u0003\u0001)
        return;
      this.\u0002\u001F = new uint[(IntPtr) (this.\u0003\u0001 = num2)];
    }

    public uint \u0002\u0012(uint[] distances)
    {
      uint num1;
      if (this.\u0003\u001E + this.\u0003\u0002 <= this.\u0004)
      {
        num1 = this.\u0003\u0002;
      }
      else
      {
        num1 = this.\u0004 - this.\u0003\u001E;
        if (num1 < this.\u0003\u000C)
        {
          this.\u0002\u0015();
          return 0;
        }
      }
      uint num2 = 0;
      uint num3 = this.\u0003\u001E > this.\u0002\u001E ? this.\u0003\u001E - this.\u0002\u001E : 0U;
      uint index1 = this.\u0003\u0019 + this.\u0003\u001E;
      uint num4 = 1;
      uint index2 = 0;
      uint num5 = 0;
      uint num6;
      if (this.\u0003\u0004)
      {
        uint num7 = \u0001\u0018.\u0002[(int) this.\u0003\u0018[(IntPtr) index1]] ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 1U)];
        index2 = num7 & 1023U;
        uint num8 = num7 ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 2U)] << 8;
        num5 = num8 & (uint) ushort.MaxValue;
        num6 = (num8 ^ \u0001\u0018.\u0002[(int) this.\u0003\u0018[(IntPtr) (index1 + 3U)]] << 5) & this.\u0003;
      }
      else
        num6 = (uint) this.\u0003\u0018[(IntPtr) index1] ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 1U)] << 8;
      uint num9 = this.\u0002\u001F[(IntPtr) (this.\u0003\u0007 + num6)];
      if (this.\u0003\u0004)
      {
        uint num10 = this.\u0002\u001F[(IntPtr) index2];
        uint num11 = this.\u0002\u001F[(IntPtr) (1024U + num5)];
        this.\u0002\u001F[(IntPtr) index2] = this.\u0003\u001E;
        this.\u0002\u001F[(IntPtr) (1024U + num5)] = this.\u0003\u001E;
        if (num10 > num3 && (int) this.\u0003\u0018[(IntPtr) (this.\u0003\u0019 + num10)] == (int) this.\u0003\u0018[(IntPtr) index1])
        {
          uint[] numArray1 = distances;
          int num12 = (int) num2;
          uint num13 = (uint) (num12 + 1);
          uint index3 = (uint) num12;
          int num14;
          num4 = (uint) (num14 = 2);
          numArray1[(IntPtr) index3] = (uint) num14;
          uint[] numArray2 = distances;
          int num15 = (int) num13;
          num2 = (uint) (num15 + 1);
          uint index4 = (uint) num15;
          int num16 = (int) this.\u0003\u001E - (int) num10 - 1;
          numArray2[(IntPtr) index4] = (uint) num16;
        }
        if (num11 > num3 && (int) this.\u0003\u0018[(IntPtr) (this.\u0003\u0019 + num11)] == (int) this.\u0003\u0018[(IntPtr) index1])
        {
          if ((int) num11 == (int) num10)
            num2 -= 2U;
          uint[] numArray3 = distances;
          int num17 = (int) num2;
          uint num18 = (uint) (num17 + 1);
          uint index5 = (uint) num17;
          int num19;
          num4 = (uint) (num19 = 3);
          numArray3[(IntPtr) index5] = (uint) num19;
          uint[] numArray4 = distances;
          int num20 = (int) num18;
          num2 = (uint) (num20 + 1);
          uint index6 = (uint) num20;
          int num21 = (int) this.\u0003\u001E - (int) num11 - 1;
          numArray4[(IntPtr) index6] = (uint) num21;
          num10 = num11;
        }
        if (num2 != 0U && (int) num10 == (int) num9)
        {
          num2 -= 2U;
          num4 = 1U;
        }
      }
      this.\u0002\u001F[(IntPtr) (this.\u0003\u0007 + num6)] = this.\u0003\u001E;
      uint index7 = (uint) (((int) this.\u0002\u001D << 1) + 1);
      uint index8 = this.\u0002\u001D << 1;
      uint val2;
      uint val1 = val2 = this.\u0003\u000D;
      if (this.\u0003\u000D != 0U && num9 > num3 && (int) this.\u0003\u0018[(IntPtr) (this.\u0003\u0019 + num9 + this.\u0003\u000D)] != (int) this.\u0003\u0018[(IntPtr) (index1 + this.\u0003\u000D)])
      {
        uint[] numArray5 = distances;
        int num22 = (int) num2;
        uint num23 = (uint) (num22 + 1);
        uint index9 = (uint) num22;
        int num24;
        num4 = (uint) (num24 = (int) this.\u0003\u000D);
        numArray5[(IntPtr) index9] = (uint) num24;
        uint[] numArray6 = distances;
        int num25 = (int) num23;
        num2 = (uint) (num25 + 1);
        uint index10 = (uint) num25;
        int num26 = (int) this.\u0003\u001E - (int) num9 - 1;
        numArray6[(IntPtr) index10] = (uint) num26;
      }
      uint num27 = this.\u0002\u001C;
      while (num9 > num3 && num27-- != 0U)
      {
        uint num28 = this.\u0003\u001E - num9;
        uint index11 = (uint) ((num28 <= this.\u0002\u001D ? (int) this.\u0002\u001D - (int) num28 : (int) this.\u0002\u001D - (int) num28 + (int) this.\u0002\u001E) << 1);
        uint num29 = this.\u0003\u0019 + num9;
        uint num30 = Math.Min(val1, val2);
        if ((int) this.\u0003\u0018[(IntPtr) (num29 + num30)] == (int) this.\u0003\u0018[(IntPtr) (index1 + num30)])
        {
          do
            ;
          while ((int) ++num30 != (int) num1 && (int) this.\u0003\u0018[(IntPtr) (num29 + num30)] == (int) this.\u0003\u0018[(IntPtr) (index1 + num30)]);
          if (num4 < num30)
          {
            uint[] numArray7 = distances;
            int num31 = (int) num2;
            uint num32 = (uint) (num31 + 1);
            uint index12 = (uint) num31;
            int num33;
            num4 = (uint) (num33 = (int) num30);
            numArray7[(IntPtr) index12] = (uint) num33;
            uint[] numArray8 = distances;
            int num34 = (int) num32;
            num2 = (uint) (num34 + 1);
            uint index13 = (uint) num34;
            int num35 = (int) num28 - 1;
            numArray8[(IntPtr) index13] = (uint) num35;
            if ((int) num30 == (int) num1)
            {
              this.\u0003\u0003[(IntPtr) index8] = this.\u0003\u0003[(IntPtr) index11];
              this.\u0003\u0003[(IntPtr) index7] = this.\u0003\u0003[(IntPtr) (index11 + 1U)];
              goto label_29;
            }
          }
        }
        if ((int) this.\u0003\u0018[(IntPtr) (num29 + num30)] < (int) this.\u0003\u0018[(IntPtr) (index1 + num30)])
        {
          this.\u0003\u0003[(IntPtr) index8] = num9;
          index8 = index11 + 1U;
          num9 = this.\u0003\u0003[(IntPtr) index8];
          val2 = num30;
        }
        else
        {
          this.\u0003\u0003[(IntPtr) index7] = num9;
          index7 = index11;
          num9 = this.\u0003\u0003[(IntPtr) index7];
          val1 = num30;
        }
      }
      this.\u0003\u0003[(IntPtr) index7] = this.\u0003\u0003[(IntPtr) index8] = 0U;
label_29:
      this.\u0002\u0015();
      return num2;
    }

    public void \u0002\u001B(uint num)
    {
      do
      {
        uint num1;
        if (this.\u0003\u001E + this.\u0003\u0002 <= this.\u0004)
        {
          num1 = this.\u0003\u0002;
        }
        else
        {
          num1 = this.\u0004 - this.\u0003\u001E;
          if (num1 < this.\u0003\u000C)
          {
            this.\u0002\u0015();
            goto label_19;
          }
        }
        uint num2 = this.\u0003\u001E > this.\u0002\u001E ? this.\u0003\u001E - this.\u0002\u001E : 0U;
        uint index1 = this.\u0003\u0019 + this.\u0003\u001E;
        uint num3;
        if (this.\u0003\u0004)
        {
          uint num4 = \u0001\u0018.\u0002[(int) this.\u0003\u0018[(IntPtr) index1]] ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 1U)];
          this.\u0002\u001F[(IntPtr) (num4 & 1023U)] = this.\u0003\u001E;
          uint num5 = num4 ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 2U)] << 8;
          this.\u0002\u001F[(IntPtr) (1024U + (num5 & (uint) ushort.MaxValue))] = this.\u0003\u001E;
          num3 = (num5 ^ \u0001\u0018.\u0002[(int) this.\u0003\u0018[(IntPtr) (index1 + 3U)]] << 5) & this.\u0003;
        }
        else
          num3 = (uint) this.\u0003\u0018[(IntPtr) index1] ^ (uint) this.\u0003\u0018[(IntPtr) (index1 + 1U)] << 8;
        uint num6 = this.\u0002\u001F[(IntPtr) (this.\u0003\u0007 + num3)];
        this.\u0002\u001F[(IntPtr) (this.\u0003\u0007 + num3)] = this.\u0003\u001E;
        uint index2 = (uint) (((int) this.\u0002\u001D << 1) + 1);
        uint index3 = this.\u0002\u001D << 1;
        uint val2;
        uint val1 = val2 = this.\u0003\u000D;
        uint num7 = this.\u0002\u001C;
        while (num6 > num2 && num7-- != 0U)
        {
          uint num8 = this.\u0003\u001E - num6;
          uint index4 = (uint) ((num8 <= this.\u0002\u001D ? (int) this.\u0002\u001D - (int) num8 : (int) this.\u0002\u001D - (int) num8 + (int) this.\u0002\u001E) << 1);
          uint num9 = this.\u0003\u0019 + num6;
          uint num10 = Math.Min(val1, val2);
          if ((int) this.\u0003\u0018[(IntPtr) (num9 + num10)] == (int) this.\u0003\u0018[(IntPtr) (index1 + num10)])
          {
            do
              ;
            while ((int) ++num10 != (int) num1 && (int) this.\u0003\u0018[(IntPtr) (num9 + num10)] == (int) this.\u0003\u0018[(IntPtr) (index1 + num10)]);
            if ((int) num10 == (int) num1)
            {
              this.\u0003\u0003[(IntPtr) index3] = this.\u0003\u0003[(IntPtr) index4];
              this.\u0003\u0003[(IntPtr) index2] = this.\u0003\u0003[(IntPtr) (index4 + 1U)];
              goto label_18;
            }
          }
          if ((int) this.\u0003\u0018[(IntPtr) (num9 + num10)] < (int) this.\u0003\u0018[(IntPtr) (index1 + num10)])
          {
            this.\u0003\u0003[(IntPtr) index3] = num6;
            index3 = index4 + 1U;
            num6 = this.\u0003\u0003[(IntPtr) index3];
            val2 = num10;
          }
          else
          {
            this.\u0003\u0003[(IntPtr) index2] = num6;
            index2 = index4;
            num6 = this.\u0003\u0003[(IntPtr) index2];
            val1 = num10;
          }
        }
        this.\u0003\u0003[(IntPtr) index2] = this.\u0003\u0003[(IntPtr) index3] = 0U;
label_18:
        this.\u0002\u0015();
label_19:;
      }
      while (--num != 0U);
    }

    private void \u0002\u0016(uint[] items, uint numItems, uint subValue)
    {
      for (uint index = 0; index < numItems; ++index)
      {
        uint num1 = items[(IntPtr) index];
        uint num2 = num1 > subValue ? num1 - subValue : 0U;
        items[(IntPtr) index] = num2;
      }
    }

    private void \u0003\u0010()
    {
      uint subValue = this.\u0003\u001E - this.\u0002\u001E;
      this.\u0002\u0016(this.\u0003\u0003, this.\u0002\u001E * 2U, subValue);
      this.\u0002\u0016(this.\u0002\u001F, this.\u0003\u0001, subValue);
      this.\u0003\u0016((int) subValue);
    }

    public void \u0002\u0018(uint cutValue) => this.\u0002\u001C = cutValue;
  }
}
