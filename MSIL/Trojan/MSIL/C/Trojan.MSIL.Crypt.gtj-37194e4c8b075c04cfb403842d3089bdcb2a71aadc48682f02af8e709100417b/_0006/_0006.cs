// Decompiled with JetBrains decompiler
// Type: .
// Assembly: dno_ebanoe, Version=10.1.2.5, Culture=neutral, PublicKeyToken=null
// MVID: 309D9199-0867-40C5-B2E8-3B9E89A70B78
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan.MSIL.Crypt.gtj-37194e4c8b075c04cfb403842d3089bdcb2a71aadc48682f02af8e709100417b.exe

using \u0003;
using \u0005;
using System;
using System.IO;
using System.Runtime.CompilerServices;

namespace \u0006
{
  internal sealed class \u0006
  {
    public static string \u0001;

    internal sealed class \u0001
    {
      private const int \u0001 = 0;
      private const int \u0002 = 1;
      private const int \u0003 = 2;
      private const int \u0004 = 3;
      private const int \u0005 = 4;
      private const int \u0006 = 5;
      private const int \u0007 = 6;
      private const int \u0008 = 7;
      private const int \u000E = 8;
      private const int \u000F = 9;
      private const int \u0010 = 10;
      private const int \u0011 = 11;
      private const int \u0012 = 12;
      internal static readonly int[] \u0001;
      internal static readonly int[] \u0002;
      internal static readonly int[] \u0003;
      internal static readonly int[] \u0004;
      internal int \u0013;
      internal int \u0014;
      internal int \u0015;
      internal int \u0016;
      internal int \u0017;
      internal bool \u0001;
      internal \u0006.\u0006.\u0002 \u0001;
      internal \u0006.\u0006.\u0003 \u0001;
      internal \u0006.\u0006.\u0005 \u0001;
      internal \u0006.\u0006.\u0004 \u0001;
      internal \u0006.\u0006.\u0004 \u0002;

      public \u0001(byte[] bytes)
      {
        this.\u0001 = new \u0006.\u0006.\u0002();
        this.\u0001 = new \u0006.\u0006.\u0003();
        this.\u0013 = 2;
        \u0001.\u0001(bytes.Length, 0, bytes, this.\u0001);
      }

      static \u0001()
      {
label_0:
        int length1 = 29;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u0001.\u0001));
          \u0006.\u0006.\u0001.\u0001 = numArray1;
          while (true)
          {
            \u0006.\u0006.\u0001.\u0002 = new int[29]
            {
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              4,
              4,
              4,
              4,
              5,
              5,
              5,
              5,
              0
            };
            if (true)
            {
              \u0006.\u0006.\u0001.\u0003 = new int[30]
              {
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577
              };
              goto label_5;
            }
          }
          goto label_7;
label_5:
          int length2 = 30;
          if (length2 == 0)
          {
            length1 = length2;
            continue;
          }
          int[] numArray2 = new int[length2];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u0001.\u0001));
          \u0006.\u0006.\u0001.\u0004 = numArray2;
label_7:
          if (true)
          {
            if (false)
              goto label_5;
            else
              break;
          }
          else
            goto label_0;
        }
      }
    }

    internal sealed class \u0002
    {
      internal byte[] \u0001;
      internal int \u0001 = 0;
      internal int \u0002 = 0;
      internal uint \u0001 = 0;
      internal int \u0003 = 0;

      public int AvailableBits => this.\u0003;

      public int AvailableBytes
      {
        get
        {
          int num1 = this.\u0002;
          int num2;
          int num3;
          while (true)
          {
            num2 = this.\u0001;
            if (true)
            {
              num3 = num1 - num2;
              if (false)
                num1 = num3;
              else
                goto label_7;
            }
            else
              break;
          }
label_2:
          do
          {
            if (true)
              num2 >>= 3;
          }
          while (false);
          return num1 + num2;
label_7:
          num2 = this.\u0003;
          num1 = num3;
          goto label_2;
        }
      }

      public bool IsNeedingInput => this.\u0001 == this.\u0002;
    }

    internal sealed class \u0003
    {
      private const int \u0001 = 32768;
      private const int \u0002 = 32767;
      internal byte[] \u0001 = new byte[32768];
      internal int \u0003 = 0;
      internal int \u0004 = 0;
    }

    internal sealed class \u0004
    {
      private const int \u0001 = 15;
      internal short[] \u0001;
      public static readonly \u0006.\u0006.\u0004 \u0001;
      public static readonly \u0006.\u0006.\u0004 \u0002;

      static \u0004()
      {
        byte[] codeLengths = new byte[288];
label_1:
        int num1;
        while (true)
        {
          if (true)
            goto label_18;
label_3:
          if (true)
          {
            while (num1 < 144)
              codeLengths[num1++] = (byte) 8;
            if (true)
            {
              for (; num1 < 256; codeLengths[num1++] = (byte) 9)
              {
                if (false)
                  goto label_1;
              }
              goto label_7;
            }
            else
              break;
          }
          else
            goto label_10;
label_18:
          num1 = 0;
          goto label_3;
        }
        goto label_12;
label_7:
        int num2;
        int num3;
        while (true)
        {
          num2 = num1;
          num3 = 280;
          if (num3 != 0)
          {
            if (num2 < num3)
              codeLengths[num1++] = (byte) 7;
            else
              goto label_10;
          }
          else
            break;
        }
        int num4 = num3;
        int num5 = num2;
        goto label_15;
label_10:
        while (num1 < 288)
          codeLengths[num1++] = (byte) 8;
        \u0006.\u0006.\u0004.\u0001 = new \u0006.\u0006.\u0004(codeLengths);
        codeLengths = new byte[32];
label_12:
        num1 = 0;
label_14:
        num5 = num1;
        num4 = 32;
label_15:
        if (num5 < num4)
        {
          codeLengths[num1++] = (byte) 5;
          goto label_14;
        }
        else if (true)
          \u0006.\u0006.\u0004.\u0002 = new \u0006.\u0006.\u0004(codeLengths);
        else
          goto label_7;
      }

      public \u0004(byte[] codeLengths) => \u0001.\u0001(codeLengths, this);
    }

    internal sealed class \u0005
    {
      private const int \u0001 = 0;
      private const int \u0002 = 1;
      private const int \u0003 = 2;
      private const int \u0004 = 3;
      private const int \u0005 = 4;
      private const int \u0006 = 5;
      internal static readonly int[] \u0001;
      internal static readonly int[] \u0002;
      internal byte[] \u0001;
      internal byte[] \u0002;
      internal \u0006.\u0006.\u0004 \u0001;
      internal int \u0007;
      internal int \u0008;
      internal int \u000E;
      internal int \u000F;
      internal int \u0010;
      internal int \u0011;
      internal byte \u0001;
      internal int \u0012;
      internal static readonly int[] \u0003;

      static \u0005()
      {
label_0:
        int length1 = 3;
        int length2;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u0001.\u0001));
          \u0006.\u0006.\u0005.\u0001 = numArray1;
          do
          {
            if (true)
            {
              length2 = 3;
              if (length2 != 0)
              {
                int[] numArray2 = new int[length2];
                // ISSUE: field reference
                RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u0001.\u0001));
                \u0006.\u0006.\u0005.\u0002 = numArray2;
              }
              else
                goto label_6;
            }
            else
              goto label_0;
          }
          while (false);
          length2 = 19;
label_6:
          if (length2 == 0)
            length1 = length2;
          else
            break;
        }
        int[] numArray = new int[length2];
        // ISSUE: field reference
        RuntimeHelpers.InitializeArray((Array) numArray, __fieldref (\u0001.\u0001));
        \u0006.\u0006.\u0005.\u0003 = numArray;
      }
    }

    internal sealed class \u0006
    {
      private const int \u0001 = 4;
      private const int \u0002 = 8;
      private const int \u0003 = 16;
      private const int \u0004 = 20;
      private const int \u0005 = 28;
      private const int \u0006 = 30;
      internal int \u0007 = 16;
      internal long \u0001 = 0;
      internal \u0006.\u0006.\u000E \u0001;
      internal \u0006.\u0006.\u0008 \u0001;

      public \u0006()
      {
        this.\u0001 = new \u0006.\u0006.\u000E();
        this.\u0001 = new \u0006.\u0006.\u0008(this.\u0001);
      }

      public long TotalOut => this.\u0001;

      public bool IsFinished
      {
        get
        {
          int num1 = this.\u0007;
          int num2;
          int num3;
          int num4;
          while (true)
          {
            int num5 = 30;
            while (true)
            {
              if (num1 == num5)
                goto label_9;
              else
                goto label_7;
label_4:
              if (true)
              {
                num3 = 0;
                if (num3 != 0)
                {
                  num5 = num3;
                  num1 = num2;
                  continue;
                }
                goto label_6;
              }
              else
                break;
label_7:
              num4 = 0;
              if (num4 != 0)
              {
                num2 = num4;
                goto label_4;
              }
              else
                goto label_3;
label_9:
              num2 = this.\u0001.\u0002;
              goto label_4;
            }
            num1 = num2;
          }
label_6:
          return num2 == num3;
label_3:
          return num4 != 0;
        }
      }

      public bool IsNeedingInput => \u0001.\u0001(this.\u0001);
    }

    internal sealed class \u0007
    {
      private const int \u0001 = 16384;
      private const int \u0002 = 286;
      private const int \u0003 = 30;
      private const int \u0004 = 19;
      private const int \u0005 = 16;
      private const int \u0006 = 17;
      private const int \u0007 = 18;
      private const int \u0008 = 256;
      internal static readonly int[] \u0001;
      internal static readonly byte[] \u0001;
      internal \u0006.\u0006.\u000E \u0001;
      internal \u0006.\u0006.\u0007.\u0001 \u0001;
      internal \u0006.\u0006.\u0007.\u0001 \u0002;
      internal \u0006.\u0006.\u0007.\u0001 \u0003;
      internal short[] \u0001;
      internal byte[] \u0002;
      internal int \u000E;
      internal int \u000F;
      internal static readonly short[] \u0002;
      internal static readonly byte[] \u0003;
      internal static readonly short[] \u0003;
      internal static readonly byte[] \u0004;

      static \u0007()
      {
label_0:
        \u0006.\u0006.\u0007.\u0001 = new int[19]
        {
          16,
          17,
          18,
          0,
          8,
          7,
          9,
          6,
          10,
          5,
          11,
          4,
          12,
          3,
          13,
          2,
          14,
          1,
          15
        };
label_1:
        \u0006.\u0006.\u0007.\u0001 = new byte[16]
        {
          (byte) 0,
          (byte) 8,
          (byte) 4,
          (byte) 12,
          (byte) 2,
          (byte) 10,
          (byte) 6,
          (byte) 14,
          (byte) 1,
          (byte) 9,
          (byte) 5,
          (byte) 13,
          (byte) 3,
          (byte) 11,
          (byte) 7,
          (byte) 15
        };
        \u0006.\u0006.\u0007.\u0002 = new short[286];
        \u0006.\u0006.\u0007.\u0003 = new byte[286];
        int index;
        if (true)
        {
          index = 0;
          goto label_23;
        }
        else
          goto label_7;
label_4:
        if (true)
        {
          \u0006.\u0006.\u0007.\u0003[index++] = (byte) 8;
          goto label_23;
        }
        else
          goto label_8;
label_7:
        \u0006.\u0006.\u0007.\u0003[index++] = (byte) 9;
label_8:
        if (index < 256)
        {
          \u0006.\u0006.\u0007.\u0002[index] = \u0001.\u0001(256 + index << 7);
          goto label_7;
        }
        else
        {
          if (true)
          {
            while (true)
            {
              int num1 = index;
label_13:
              if (num1 < 280)
              {
                \u0006.\u0006.\u0007.\u0002[index] = \u0001.\u0001(index - 256 << 9);
                if (true)
                  \u0006.\u0006.\u0007.\u0003[index++] = (byte) 7;
                else
                  goto label_0;
              }
              else
              {
                for (; index < 286; \u0006.\u0006.\u0007.\u0003[index++] = (byte) 8)
                  \u0006.\u0006.\u0007.\u0002[index] = \u0001.\u0001(index - 88 << 8);
                \u0006.\u0006.\u0007.\u0003 = new short[30];
                \u0006.\u0006.\u0007.\u0004 = new byte[30];
                if (true)
                {
                  int num2;
                  for (index = 0; index < 30; index = num2 + 1)
                  {
                    \u0006.\u0006.\u0007.\u0003[index] = \u0001.\u0001(index << 11);
                    if (true)
                    {
                      \u0006.\u0006.\u0007.\u0004[index] = (byte) 5;
                      num2 = index;
                      if (false)
                      {
                        num1 = num2;
                        goto label_13;
                      }
                    }
                    else
                      goto label_1;
                  }
                  break;
                }
                goto label_4;
              }
            }
            return;
          }
          goto label_0;
        }
label_23:
        if (index < 144)
        {
          \u0006.\u0006.\u0007.\u0002[index] = \u0001.\u0001(48 + index << 8);
          goto label_4;
        }
        else
          goto label_8;
      }

      public \u0007(\u0006.\u0006.\u000E pending)
      {
        this.\u0001 = pending;
        this.\u0001 = new \u0006.\u0006.\u0007.\u0001(this, 286, 257, 15);
        this.\u0002 = new \u0006.\u0006.\u0007.\u0001(this, 30, 1, 15);
        this.\u0003 = new \u0006.\u0006.\u0007.\u0001(this, 19, 4, 7);
        this.\u0001 = new short[16384];
        this.\u0002 = new byte[16384];
      }

      public sealed class \u0001
      {
        public short[] \u0001;
        public byte[] \u0001;
        public int \u0001;
        public int \u0002;
        internal short[] \u0002;
        internal int[] \u0001;
        internal int \u0003;
        internal \u0006.\u0006.\u0007 \u0001;

        public \u0001(\u0006.\u0006.\u0007 dh, int elems, int minCodes, int maxLength)
        {
          this.\u0001 = dh;
          this.\u0001 = minCodes;
          this.\u0003 = maxLength;
          this.\u0001 = new short[elems];
          this.\u0001 = new int[maxLength];
        }
      }
    }

    internal sealed class \u0008
    {
      private const int \u0001 = 258;
      private const int \u0002 = 3;
      private const int \u0003 = 32768;
      private const int \u0004 = 32767;
      private const int \u0005 = 32768;
      private const int \u0006 = 32767;
      private const int \u0007 = 5;
      private const int \u0008 = 262;
      private const int \u000E = 32506;
      private const int \u000F = 4096;
      internal int \u0010;
      internal short[] \u0001;
      internal short[] \u0002;
      internal int \u0011;
      internal int \u0012;
      internal bool \u0001;
      internal int \u0013;
      internal int \u0014;
      internal int \u0015;
      internal byte[] \u0001;
      internal byte[] \u0002;
      internal int \u0016;
      internal int \u0017;
      internal int \u0018;
      internal \u0006.\u0006.\u000E \u0001;
      internal \u0006.\u0006.\u0007 \u0001;

      public \u0008(\u0006.\u0006.\u000E pending)
      {
        this.\u0001 = pending;
        this.\u0001 = new \u0006.\u0006.\u0007(pending);
        this.\u0001 = new byte[65536];
        this.\u0001 = new short[32768];
        this.\u0002 = new short[32768];
        this.\u0013 = this.\u0014 = 1;
      }
    }

    internal sealed class \u000E
    {
      protected internal byte[] \u0001 = new byte[65536];
      internal int \u0001 = 0;
      internal int \u0002 = 0;
      internal uint \u0001 = 0;
      internal int \u0003 = 0;

      public int BitCount => this.\u0003;

      public bool IsFlushed => this.\u0002 == 0;
    }

    internal sealed class \u000F : MemoryStream
    {
      public \u000F()
      {
      }

      public \u000F(byte[] buffer)
        : base(buffer, false)
      {
      }
    }
  }
}
