// Decompiled with JetBrains decompiler
// Type: Borland.Delphi.System.TObjectHelper
// Assembly: Project1, Version=1.0.1859.4414, Culture=neutral, PublicKeyToken=null
// MVID: 387A0727-86C4-4744-A694-CF2F2E0F060B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.WMC.10-fd5e584bd80ce552c9df6b54aeb5b165ab53ae3852db7b074873a0872cf5dc56.exe

using System;
using System.Collections;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Borland.Delphi.System
{
  [ComVisible(false)]
  [CLSCompliant(false)]
  public class TObjectHelper : TClassHelperBase
  {
    public static void Free(object Self)
    {
      if (Self == null || !(Self is IDisposable))
        return;
      if (Unit.VCLFreeNotify != null)
        Unit.VCLFreeNotify(Self);
      (Self as IDisposable).Dispose();
    }

    public static \u0040TClass ClassType(object Self) => Unit.\u0040GetMetaFromHandle(TObjectHelper.ClassInfo(Unit.\u0040GetMetaFromObject(Self)).TypeHandle);

    public static string ClassName(\u0040TClass Self)
    {
      Type AType = (Self as \u0040TClass).InstanceType();
      string ASuggestedName = AType.Name;
      if (Unit.TraditionalClassNames)
      {
        // ISSUE: explicit non-virtual call
        if (__nonvirtual (AType.Equals(typeof (object))))
        {
          ASuggestedName = "TObject";
        }
        else
        {
          // ISSUE: explicit non-virtual call
          if (__nonvirtual (AType.Equals(typeof (Guid))))
            ASuggestedName = "TGUID";
        }
        if (Unit.VCLGetClassName != null)
          ASuggestedName = Unit.VCLGetClassName(AType, ASuggestedName);
      }
      return ASuggestedName;
    }

    public static bool ClassNameIs(\u0040TClass Self, [In] string Name) => string.Compare(TObjectHelper.ClassName(Self), Name, true) == 0;

    public static \u0040TClass ClassParent(\u0040TClass Self) => (Self as \u0040TClass).ClassParent();

    public static Type ClassInfo(\u0040TClass Self) => (Self as \u0040TClass).InstanceType();

    public static bool InheritsFrom(\u0040TClass Self, \u0040TClass AClass)
    {
      bool flag = false;
      if (Self != null && AClass != null)
      {
        Type c = TObjectHelper.ClassInfo(Self);
        flag = TObjectHelper.ClassInfo(AClass).IsAssignableFrom(c);
      }
      return flag;
    }

    public static MemberInfo MethodAddress(\u0040TClass Self, [In] string AName)
    {
      MemberInfo ACode;
      if (Unit.ProxySystemSupport == null || !Unit.ProxySystemSupport.GetMethodAddress(Self, AName, out ACode))
        ACode = (AName != null ? AName.Length : 0) <= 0 ? (MemberInfo) null : (MemberInfo) (Self as \u0040TClass).InstanceType().GetMethod(AName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod);
      return ACode;
    }

    public static string MethodName(\u0040TClass Self, MemberInfo ACode) => (object) ACode == null || Unit.\u0040WStrCmp(ACode.Name, "") == 0 || (object) ACode.DeclaringType == null || !__nonvirtual (ACode.DeclaringType.Equals(TObjectHelper.ClassInfo(Self))) ? "" : ACode.Name;

    public static object FieldAddress(object Self, [In] string AName) => (AName != null ? AName.Length : 0) <= 0 ? (object) null : (object) __nonvirtual (Self.GetType().GetField(AName));

    public static void Dispatch(object Self, ref object Message)
    {
      object o = Message;
      int messageId = Unit.GetMessageID(o);
      Type ClassType = Self.GetType();
      object[] objArray1;
      object[] sourceArray = objArray1;
      object[] objArray2;
      object[] destinationArray = objArray2 = new object[1];
      if (sourceArray != null)
      {
        int length;
        if ((length = sourceArray.Length) > 1)
          length = 1;
        if (length > 0)
          Array.Copy((Array) sourceArray, (Array) destinationArray, length);
      }
      object[] parameters = objArray2;
      MethodInfo methodInfo1 = (MethodInfo) null;
      if ((object) ClassType != null)
      {
        do
        {
          if (Unit.MethodMaps == null)
            Unit.MethodMaps = new Hashtable();
          TMethodMap tmethodMap = (TMethodMap) Unit.MethodMaps[(object) ClassType.TypeHandle];
          if (tmethodMap == null)
          {
            tmethodMap = new TMethodMap(ClassType);
            Unit.MethodMaps[(object) ClassType.TypeHandle] = (object) tmethodMap;
          }
          MethodInfo methodInfo2 = tmethodMap[messageId];
          if ((object) methodInfo2 != null)
          {
            Type conversionType = methodInfo2.GetParameters()[0].ParameterType;
            // ISSUE: explicit non-virtual call
            if (__nonvirtual (conversionType.IsByRef))
              conversionType = conversionType.GetElementType();
            bool flag = false;
            if (conversionType.IsInstanceOfType(o))
            {
              parameters[0] = o;
            }
            else
            {
              flag = true;
              parameters[0] = Convert.ChangeType(o, conversionType);
            }
            try
            {
              // ISSUE: explicit non-virtual call
              __nonvirtual (methodInfo2.Invoke(Self, parameters));
            }
            catch (Exception ex)
            {
              Unit.\u0040ExceptObject = (object) ex;
              Exception exception = ex;
              while (exception is TargetInvocationException && (exception as TargetInvocationException).InnerException != null)
                exception = (exception as TargetInvocationException).InnerException;
              throw exception;
            }
            if (!flag)
            {
              Message = parameters[0];
              return;
            }
            goto label_34;
          }
          else
          {
            if ((object) methodInfo1 == null)
              methodInfo1 = tmethodMap.Default;
            ClassType = ClassType.BaseType;
          }
        }
        while ((object) ClassType != null);
        goto label_26;
label_34:
        return;
      }
label_26:
      if ((object) methodInfo1 == null)
        return;
      parameters[0] = o;
      try
      {
        // ISSUE: explicit non-virtual call
        __nonvirtual (methodInfo1.Invoke(Self, parameters));
      }
      catch (Exception ex)
      {
        Unit.\u0040ExceptObject = (object) ex;
        Exception exception = ex;
        while (exception is TargetInvocationException && (exception as TargetInvocationException).InnerException != null)
          exception = (exception as TargetInvocationException).InnerException;
        throw exception;
      }
      Message = parameters[0];
    }

    internal void \u0024delegate\u002EDispatch(ref object Message) => TObjectHelper.Dispatch(this.FInstance, ref Message);

    internal object \u0024delegate\u002EFieldAddress([In] string AName) => TObjectHelper.FieldAddress(this.FInstance, AName);

    internal \u0040TClass \u0024delegate\u002EClassType() => TObjectHelper.ClassType(this.FInstance);

    internal void \u0024delegate\u002EFree() => TObjectHelper.Free(this.FInstance);
  }
}
