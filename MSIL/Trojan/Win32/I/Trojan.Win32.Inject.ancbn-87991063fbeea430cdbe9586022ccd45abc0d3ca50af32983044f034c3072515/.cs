// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Ressource, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7A61D5AB-B799-4526-BF58-A6DA1297213F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Inject.ancbn-87991063fbeea430cdbe9586022ccd45abc0d3ca50af32983044f034c3072515.exe

using System;

internal sealed class \uE00E
{
  internal static int[] \uE002(int[] _param0, int _param1)
  {
    int[] items = new int[_param0.Length];
    int[] numArray1 = new int[_param0.Length];
    for (int index = 0; index < items.Length; ++index)
      items[index] = index;
    Array.Copy((Array) _param0, (Array) numArray1, _param0.Length);
    Array.Sort<int, int>(numArray1, items);
    int sourceIndex = 0;
    while (sourceIndex < numArray1.Length && numArray1[sourceIndex] == 0)
      ++sourceIndex;
    int[] destinationArray = new int[numArray1.Length - sourceIndex];
    Array.Copy((Array) numArray1, sourceIndex, (Array) destinationArray, 0, destinationArray.Length);
    int[] numArray2;
    if (destinationArray.Length == 0)
      numArray2 = new int[0];
    else if (destinationArray.Length == 1)
      numArray2 = new int[1]{ 1 };
    else
      numArray2 = \uE00E.\uE003(destinationArray, _param1);
    int[] numArray3 = new int[_param0.Length];
    for (int index = 0; index < numArray2.Length; ++index)
      numArray3[items[index + sourceIndex]] = numArray2[index];
    return numArray3;
  }

  private static int[] \uE003(int[] _param0, int _param1)
  {
    int length = _param0.Length;
    int[][] numArray1 = new int[_param1][];
    numArray1[0] = _param0;
    int[] numArray2 = new int[_param0.Length / 2];
    for (int index = 0; index < numArray2.Length; ++index)
      numArray2[index] = _param0[index * 2] + _param0[index * 2 + 1];
    for (int index1 = 1; index1 < _param1; ++index1)
    {
      int[] numArray3 = \uE00E.\uE000(numArray2, _param0);
      numArray1[index1] = numArray3;
      numArray2 = new int[numArray3.Length / 2];
      for (int index2 = 0; index2 < numArray2.Length; ++index2)
        numArray2[index2] = numArray3[index2 * 2] + numArray3[index2 * 2 + 1];
    }
    int[] numArray4 = new int[length];
    int num1 = length - 1;
    for (int index3 = _param1 - 1; index3 >= 0; --index3)
    {
      int[] numArray5 = numArray1[index3];
      int num2 = 0;
      int index4 = 0;
      for (int index5 = 0; index5 < num1 * 2; ++index5)
      {
        if (index4 < _param0.Length && _param0[index4] == numArray5[index5])
        {
          ++numArray4[index4];
          ++index4;
        }
        else
          ++num2;
      }
      num1 = num2;
    }
    return numArray4;
  }

  private static int[] \uE000(int[] _param0, int[] _param1)
  {
    int[] numArray = new int[_param0.Length + _param1.Length];
    int index1 = 0;
    int index2 = 0;
    int num = 0;
    while (index1 < _param0.Length && index2 < _param1.Length)
      numArray[num++] = _param0[index1] >= _param1[index2] ? _param1[index2++] : _param0[index1++];
    while (index1 < _param0.Length)
      numArray[num++] = _param0[index1++];
    while (index2 < _param1.Length)
      numArray[num++] = _param1[index2++];
    return numArray;
  }
}
