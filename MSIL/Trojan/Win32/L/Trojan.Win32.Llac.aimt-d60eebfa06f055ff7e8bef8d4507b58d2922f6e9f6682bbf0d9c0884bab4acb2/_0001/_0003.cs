// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Stub, Version=2.0.0.2, Culture=neutral, PublicKeyToken=null
// MVID: 18A6455A-DBC9-4D4B-8699-BEBEFCABEF8D
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.Win32.Llac.aimt-d60eebfa06f055ff7e8bef8d4507b58d2922f6e9f6682bbf0d9c0884bab4acb2.exe

using \u0001;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0001
{
  internal static class \u0003
  {
    private static ModuleHandle \u0001;
    private static char[] \u0001 = new char[58]
    {
      '\u0001',
      '\u0002',
      '\u0003',
      '\u0004',
      '\u0005',
      '\u0006',
      '\a',
      '\b',
      '\u000E',
      '\u000F',
      '\u0010',
      '\u0011',
      '\u0012',
      '\u0013',
      '\u0014',
      '\u0015',
      '\u0016',
      '\u0017',
      '\u0018',
      '\u0019',
      '\u001A',
      '\u001B',
      '\u001C',
      '\u001D',
      '\u001E',
      '\u001F',
      '\u007F',
      '\u0080',
      '\u0081',
      '\u0082',
      '\u0083',
      '\u0084',
      '\u0086',
      '\u0087',
      '\u0088',
      '\u0089',
      '\u008A',
      '\u008B',
      '\u008C',
      '\u008D',
      '\u008E',
      '\u008F',
      '\u0090',
      '\u0091',
      '\u0092',
      '\u0093',
      '\u0094',
      '\u0095',
      '\u0096',
      '\u0097',
      '\u0098',
      '\u0099',
      '\u009A',
      '\u009B',
      '\u009C',
      '\u009D',
      '\u009E',
      '\u009F'
    };

    public static void \u0002([In] int obj0)
    {
      Type typeFromHandle;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(\u0003.\u0001.ResolveTypeHandle(33554433 + obj0));
      }
      catch
      {
        return;
      }
      FieldInfo[] fields;
      int index1;
      if (true)
      {
        if (true)
        {
          fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
          index1 = 0;
          goto label_52;
        }
        else
          goto label_46;
      }
label_29:
      MethodInfo methodFromHandle;
      ParameterInfo[] parameters = methodFromHandle.GetParameters();
      int num1 = parameters.Length;
      int num2 = 1;
label_30:
      int length = num1 + num2;
      Type[] parameterTypes = new Type[length];
      parameterTypes[0] = typeof (object);
      int index2 = 1;
      goto label_34;
label_33:
      int num3;
      int num4;
      index2 = num3 + num4;
label_34:
      DynamicMethod dynamicMethod;
      ILGenerator ilGenerator;
      if (index2 < length)
      {
        if (true)
        {
          parameterTypes[index2] = parameters[index2 - 1].ParameterType;
          int num5 = index2;
          num4 = 1;
          num3 = num5;
          goto label_33;
        }
      }
      else
      {
        dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
        ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        if (length > 1)
          ilGenerator.Emit(OpCodes.Ldarg_1);
      }
      int num6 = length;
      int num7 = 2;
label_38:
      if (num6 > num7)
        ilGenerator.Emit(OpCodes.Ldarg_2);
      if (length > 3)
        ilGenerator.Emit(OpCodes.Ldarg_3);
      if (length > 4)
      {
        for (int index3 = 4; index3 < length; ++index3)
          ilGenerator.Emit(OpCodes.Ldarg_S, index3);
      }
label_46:
      bool flag;
      ilGenerator.Emit(flag ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
      ilGenerator.Emit(OpCodes.Ret);
      Delegate @delegate;
      try
      {
        @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
      }
      catch
      {
        goto label_51;
      }
label_49:
      FieldInfo fieldInfo;
      try
      {
        fieldInfo.SetValue((object) null, (object) @delegate);
      }
      catch
      {
      }
label_51:
      ++index1;
label_52:
      if (index1 >= fields.Length)
        return;
      fieldInfo = fields[index1];
      string name = fieldInfo.Name;
      flag = false;
      int num8 = 0;
      int index4 = name.Length - 1;
      int num9;
      int num10;
      int num11;
      int num12;
      while (true)
      {
        int num13 = index4;
        int index5;
        while (true)
        {
          if (num13 >= 0)
          {
            char ch = name[index4];
            if (ch != '~')
            {
              index5 = 0;
              while (true)
              {
                num3 = index5;
                num4 = 8;
                if (num4 != 0)
                {
                  if (num4 != 0)
                  {
                    if (num3 < 58)
                    {
                      if ((int) \u0003.\u0001[index5] != (int) ch)
                      {
                        num9 = index5;
                        num10 = 1;
                        if (num10 != 0)
                          index5 = num9 + num10;
                        else
                          goto label_2;
                      }
                      else
                        goto label_14;
                    }
                    else
                      goto label_21;
                  }
                  else
                    break;
                }
                else
                  goto label_33;
              }
              num13 = num3;
            }
            else
              goto label_11;
          }
          else
            goto label_24;
        }
label_14:
        num11 = num8 * 58;
        num12 = index5;
        if (true)
          num8 = num11 + num12;
        else
          goto label_1;
label_21:
        --index4;
      }
label_11:
      flag = true;
label_24:
      try
      {
        methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u0003.\u0001.ResolveMethodHandle(num8 + 167772161));
      }
      catch
      {
        goto label_51;
      }
      if (methodFromHandle.IsStatic)
      {
        try
        {
          @delegate = Delegate.CreateDelegate(fieldInfo.FieldType, methodFromHandle);
          goto label_49;
        }
        catch (Exception ex)
        {
          goto label_51;
        }
      }
      else
        goto label_29;
label_1:
      num2 = num12;
      num1 = num11;
      goto label_30;
label_2:
      num7 = num10;
      num6 = num9;
      goto label_38;
    }

    static \u0003()
    {
      Type type;
      if (true)
        type = typeof (MulticastDelegate);
      do
      {
        if ((object) type != null)
          goto label_6;
label_3:
        if (true)
          continue;
label_6:
        \u0003.\u0001 = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
        goto label_3;
      }
      while (false);
    }
  }
}
