// Decompiled with JetBrains decompiler
// Type: lq
// Assembly: XobniService, Version=1.8.3.7917, Culture=neutral, PublicKeyToken=6298d2d1fcfb5d85
// MVID: EA9F7D71-4A8D-4739-A320-5F01FC76E972
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.Win32.Patched.mf-01164dae267b1f13c988de64e7fce38753b97528a3dc3fe730e191fc953c65ba.exe

using System;
using System.Security.AccessControl;
using System.Threading;
using XobniLogging;

public class lq : IDisposable
{
  private const string a = "XobniIpcEvent";
  private readonly string b;
  private readonly EventResetMode c = EventResetMode.ManualReset;
  private EventWaitHandle d;
  private bool e;
  private bool f;
  private readonly object g = new object();

  public lq(string A_0, EventResetMode A_1)
  {
    this.b = A_0;
    this.c = A_1;
    this.b();
  }

  public void c() => this.d.Set();

  public void d() => this.d.Reset();

  public void g() => this.d.Close();

  public bool a(TimeSpan A_0) => this.d.WaitOne(A_0, false);

  public void a(q8 A_0)
  {
    lock (this.g)
    {
      if (this.f)
        return;
      this.f = true;
    }
    new Thread(new ParameterizedThreadStart(this.a))
    {
      Name = (this.b + "WaitThread"),
      IsBackground = true
    }.Start((object) A_0);
  }

  private void a(object A_0)
  {
    try
    {
      q8 q8 = (q8) A_0;
      try
      {
        while (!this.e)
        {
          if (this.d.WaitOne(TimeSpan.FromSeconds(1.0), false))
            q8();
        }
      }
      catch (Exception ex)
      {
        ady.a(Level.Exception, "IpcEventWait", ex);
      }
    }
    finally
    {
      lock (this.g)
        this.f = false;
    }
  }

  private void b()
  {
    try
    {
      this.d = EventWaitHandle.OpenExisting(this.b);
    }
    catch (WaitHandleCannotBeOpenedException ex)
    {
      this.a();
    }
  }

  private void a()
  {
    EventWaitHandleSecurity eventSecurity = new EventWaitHandleSecurity();
    EventWaitHandleAccessRule rule = new EventWaitHandleAccessRule("Everyone", EventWaitHandleRights.Modify | EventWaitHandleRights.Synchronize, AccessControlType.Allow);
    eventSecurity.AddAccessRule(rule);
    bool createdNew;
    this.d = new EventWaitHandle(false, this.c, this.b, out createdNew, eventSecurity);
  }

  public void a(bool A_0)
  {
    this.e = true;
    if (!A_0)
      return;
    this.g();
  }

  public void f()
  {
    try
    {
      this.a(true);
    }
    finally
    {
      GC.SuppressFinalize((object) this);
    }
  }

  void object.e()
  {
    try
    {
      this.a(false);
    }
    catch (Exception ex)
    {
      ady.a(Level.Exception, "IpcEventFinalizer", ex);
    }
    finally
    {
      // ISSUE: explicit finalizer call
      this.Finalize();
    }
  }
}
