// Decompiled with JetBrains decompiler
// Type: eh
// Assembly: XobniService, Version=1.8.3.7917, Culture=neutral, PublicKeyToken=6298d2d1fcfb5d85
// MVID: EA9F7D71-4A8D-4739-A320-5F01FC76E972
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.Win32.Patched.mf-01164dae267b1f13c988de64e7fce38753b97528a3dc3fe730e191fc953c65ba.exe

using System;
using System.Runtime.InteropServices;

public static class eh
{
  public static void b(string A_0) => eh.a("DllRegisterServer", A_0);

  public static void a(string A_0) => eh.a("DllUnregisterServer", A_0);

  public static void a(string A_0, string A_1)
  {
    IntPtr A_0_1 = IntPtr.Zero;
    try
    {
      A_0_1 = eh.LoadLibrary(A_1);
      IntPtr ptr = !(A_0_1 == IntPtr.Zero) ? eh.GetProcAddress(A_0_1, A_0) : throw new Exception("Could not load library: " + (object) Marshal.GetLastWin32Error());
      if (ptr == IntPtr.Zero)
        throw new Exception("Could not find DllRegisterServer entry point: " + (object) Marshal.GetLastWin32Error());
      int num = ((eh.a) Marshal.GetDelegateForFunctionPointer(ptr, typeof (eh.a)))();
    }
    finally
    {
      if (A_0_1 != IntPtr.Zero && !eh.FreeLibrary(A_0_1))
        throw new Exception("Could not FreeLibrary: " + (object) Marshal.GetLastWin32Error());
    }
  }

  [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
  private static extern IntPtr GetProcAddress(IntPtr A_0, string A_1);

  [DllImport("kernel32.dll", SetLastError = true)]
  private static extern IntPtr LoadLibrary(string A_0);

  [DllImport("kernel32.dll", SetLastError = true)]
  private static extern bool FreeLibrary(IntPtr A_0);

  private delegate int a();
}
