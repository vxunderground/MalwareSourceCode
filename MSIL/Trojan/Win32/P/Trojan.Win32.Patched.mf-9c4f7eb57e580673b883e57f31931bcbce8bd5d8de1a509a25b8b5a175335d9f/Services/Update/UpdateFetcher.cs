// Decompiled with JetBrains decompiler
// Type: Bmc.Services.Update.UpdateFetcher
// Assembly: updateservice, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A6A1FC23-14F7-4CCE-B702-0F9FFD2CD5AC
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.Win32.Patched.mf-9c4f7eb57e580673b883e57f31931bcbce8bd5d8de1a509a25b8b5a175335d9f.exe

using Bmc.Broker.Config;
using Bmc.Broker.ResourceSystem;
using Bmc.RegistryAccess;
using Bmc.Services.Ticket;
using Net.LShift.SPKI;
using Net.LShift.Utilities;
using System.Collections;
using System.IO;
using System.Net;

namespace Bmc.Services.Update
{
  public class UpdateFetcher : UpdateServices
  {
    private WebClient _webClient;
    private ResourceManager _resourceManager;

    public UpdateFetcher(WebClient webClient, ResourceManager resourceManager)
    {
      this._webClient = webClient;
      this._resourceManager = resourceManager;
    }

    public void TryFetch()
    {
      string str = "machine/updates/" + ConfigurationManager.Instance[(FIELD) 12];
      WebRequest request = this._webClient.GetRequest(str + "/update.spki");
      WebResponse response1;
      try
      {
        response1 = request.GetResponse();
      }
      catch (WebException ex)
      {
        if (ex.Status == WebExceptionStatus.ProtocolError && ex.Response is HttpWebResponse response2 && response2.StatusCode == HttpStatusCode.NotFound)
          return;
        throw ex;
      }
      SPKISexp sexp = SPKISexp.ParseSexp(response1.GetResponseStream());
      SPKISexp updatePayload = this.GetUpdatePayload(sexp);
      string name1 = updatePayload.Get("update-increment").Name;
      DirectoryInfo updatesDirectory = this._resourceManager.GetUpdatesDirectory();
      updatesDirectory.Create();
      DirectoryInfo directoryInfo = new DirectoryInfo(updatesDirectory.FullName + "\\" + name1);
      if (directoryInfo.Exists)
        return;
      DirectoryInfo progressDirectory = this._resourceManager.GetUpdatesInProgressDirectory();
      progressDirectory.Create();
      SPKISexp spkiSexp1 = updatePayload["files"];
      Hashtable hashtable = new Hashtable();
      foreach (FileInfo file in progressDirectory.GetFiles())
        hashtable[(object) file.Name] = (object) file;
      ArrayList arrayList = new ArrayList();
      for (int index = 1; index < spkiSexp1.Length; ++index)
      {
        SPKISexp spkiSexp2 = spkiSexp1[index];
        if (spkiSexp2[0].Name == "file")
        {
          string name2 = spkiSexp2[1].Name;
          SPKISexp spkiSexp3 = spkiSexp2[3];
          if (hashtable.Contains((object) name2) && this.HashFile((FileInfo) hashtable[(object) name2]).Equals((object) spkiSexp3))
            hashtable.Remove((object) name2);
          else
            arrayList.Add((object) spkiSexp2);
        }
      }
      foreach (FileSystemInfo fileSystemInfo in (IEnumerable) hashtable.Values)
        fileSystemInfo.Delete();
      foreach (SPKISexp spkiSexp4 in arrayList)
      {
        string name3 = spkiSexp4[1].Name;
        SPKISexp spkiSexp5 = spkiSexp4[3];
        FileInfo fileInfo = new FileInfo(progressDirectory.ToString() + "\\" + name3);
        this._webClient.FetchFile(str + "/" + spkiSexp4[2].Name, fileInfo);
        if (!this.HashFile(fileInfo).Equals((object) spkiSexp5))
        {
          fileInfo.Delete();
          throw new BadUpdateException("Hash mismatch on download");
        }
      }
      using (Stream stream = (Stream) System.IO.File.Create(progressDirectory.FullName + "\\update.spki"))
        sexp.Marshal(stream);
      progressDirectory.MoveTo(directoryInfo.FullName);
    }

    public static UpdateFetcher Create(ResourceManager resourceManager) => new UpdateFetcher(new WebClient(ConfigurationManager.Instance.ProtocolUri, (ICredentialFactory) new BmcCredentialFactory(new SecureStateManager())), resourceManager);
  }
}
