// Decompiled with JetBrains decompiler
// Type: Bmc.Broker.Proxy.ProxyInfo
// Assembly: updateservice, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A6A1FC23-14F7-4CCE-B702-0F9FFD2CD5AC
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.Win32.Patched.mf-9c4f7eb57e580673b883e57f31931bcbce8bd5d8de1a509a25b8b5a175335d9f.exe

using System;
using System.Collections;
using System.Net;
using System.Text.RegularExpressions;

namespace Bmc.Broker.Proxy
{
  public class ProxyInfo : IWebProxy
  {
    public static readonly Regex schematizedProxyRegex = new Regex("^([a-zA-Z]+)=(.*)");
    public static readonly Regex hostAndPortRegex = new Regex("^[a-zA-Z0-9.]+:[0-9]+");
    private static readonly char[] splitChars = new char[5]
    {
      ' ',
      ';',
      '\n',
      '\r',
      '\t'
    };
    private ICredentials creds;
    public bool useProxy;
    public Hashtable proxies;
    public Uri defaultProxy;
    public string[] bypassDomains;
    public bool bypassLocal;

    public ProxyInfo()
    {
      this.creds = (ICredentials) null;
      this.useProxy = false;
      this.proxies = new Hashtable();
      this.defaultProxy = (Uri) null;
      this.bypassDomains = new string[0];
      this.bypassLocal = true;
    }

    private Uri UriFrom(string str) => str.IndexOf(':') == -1 || ProxyInfo.hostAndPortRegex.Match(str).Success ? new Uri("http://" + str) : new Uri(str);

    public void LoadFrom(WINHTTP_PROXY_INFO wpi)
    {
      if (wpi.dwAccessType == 1)
      {
        this.useProxy = false;
      }
      else
      {
        this.useProxy = true;
        foreach (string str in wpi.lpszProxy == null ? new string[0] : wpi.lpszProxy.Split(ProxyInfo.splitChars))
        {
          Match match = ProxyInfo.schematizedProxyRegex.Match(str);
          if (match.Success)
            this.proxies[(object) match.Groups[1].ToString()] = (object) this.UriFrom(match.Groups[2].ToString());
          else
            this.defaultProxy = this.UriFrom(str);
        }
        this.bypassDomains = wpi.lpszProxyBypass == null ? new string[0] : wpi.lpszProxyBypass.Split(ProxyInfo.splitChars);
        this.bypassLocal = false;
        foreach (string bypassDomain in this.bypassDomains)
        {
          if (bypassDomain == "<local>")
          {
            this.bypassLocal = true;
            break;
          }
        }
        if (!this.bypassLocal)
          return;
        string[] strArray = new string[this.bypassDomains.Length - 1];
        int num = 0;
        foreach (string bypassDomain in this.bypassDomains)
        {
          if (bypassDomain != "<local>")
            strArray[num++] = bypassDomain;
        }
        this.bypassDomains = strArray;
      }
    }

    public ICredentials Credentials
    {
      get => this.creds;
      set => this.creds = value;
    }

    public Uri GetProxy(Uri dest)
    {
      if (!this.useProxy)
        return (Uri) null;
      return this.proxies.ContainsKey((object) dest.Scheme) ? (Uri) this.proxies[(object) dest.Scheme] : this.defaultProxy;
    }

    public bool IsBypassed(Uri dest)
    {
      if (!this.useProxy || this.bypassLocal && (dest.IsLoopback || dest.Host.IndexOf('.') == -1))
        return true;
      foreach (string bypassDomain in this.bypassDomains)
      {
        if (bypassDomain == dest.Host)
          return true;
      }
      return false;
    }
  }
}
