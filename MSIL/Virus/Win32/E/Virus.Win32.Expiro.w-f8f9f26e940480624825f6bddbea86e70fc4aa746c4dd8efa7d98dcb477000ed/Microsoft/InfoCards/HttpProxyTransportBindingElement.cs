// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.HttpProxyTransportBindingElement
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 1D4D5564-A025-490C-AF1D-DF4FBB709D1F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-f8f9f26e940480624825f6bddbea86e70fc4aa746c4dd8efa7d98dcb477000ed.exe

using Microsoft.InfoCards.Diagnostics;
using System.Net;
using System.ServiceModel.Channels;

namespace Microsoft.InfoCards
{
  internal class HttpProxyTransportBindingElement : TransportBindingElement
  {
    private static object proxyLock = new object();
    private HttpTransportBindingElement innerHttpTransport;
    private IWebProxy proxy;

    public static BindingElementCollection ReplaceHttpTransportWithProxy(
      BindingElementCollection bindingElements,
      IWebProxy proxy)
    {
      int index1 = -1;
      for (int index2 = 0; index2 < bindingElements.Count; ++index2)
      {
        if (bindingElements[index2] is HttpTransportBindingElement)
        {
          index1 = index2;
          break;
        }
      }
      if (index1 == -1)
        return bindingElements;
      InfoCardTrace.Assert(index1 == bindingElements.Count - 1, "Transport should be last in the Binding Element list");
      HttpTransportBindingElement bindingElement = (HttpTransportBindingElement) bindingElements[index1];
      HttpProxyTransportBindingElement transportBindingElement = new HttpProxyTransportBindingElement(proxy, bindingElement);
      bindingElements[index1] = (BindingElement) transportBindingElement;
      return bindingElements;
    }

    private HttpProxyTransportBindingElement(
      IWebProxy proxy,
      HttpTransportBindingElement innerHttpTransport)
    {
      this.innerHttpTransport = innerHttpTransport;
      this.proxy = proxy;
    }

    private HttpProxyTransportBindingElement(HttpProxyTransportBindingElement elementToBeCloned)
      : base((TransportBindingElement) elementToBeCloned)
    {
      this.innerHttpTransport = elementToBeCloned.innerHttpTransport;
      this.proxy = elementToBeCloned.proxy;
    }

    public override long MaxBufferPoolSize
    {
      get => this.innerHttpTransport.MaxBufferPoolSize;
      set => this.innerHttpTransport.MaxBufferPoolSize = value;
    }

    public override long MaxReceivedMessageSize
    {
      get => this.innerHttpTransport.MaxReceivedMessageSize;
      set => this.innerHttpTransport.MaxReceivedMessageSize = value;
    }

    public override string Scheme => this.innerHttpTransport.Scheme;

    public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(
      BindingContext context)
    {
      lock (HttpProxyTransportBindingElement.proxyLock)
      {
        IWebProxy defaultWebProxy = WebRequest.DefaultWebProxy;
        try
        {
          WebRequest.DefaultWebProxy = this.proxy;
          return this.innerHttpTransport.BuildChannelFactory<TChannel>(context);
        }
        finally
        {
          WebRequest.DefaultWebProxy = defaultWebProxy;
        }
      }
    }

    public override IChannelListener<TChannel> BuildChannelListener<TChannel>(
      BindingContext context)
    {
      return this.innerHttpTransport.BuildChannelListener<TChannel>(context);
    }

    public override bool CanBuildChannelFactory<TChannel>(BindingContext context) => this.innerHttpTransport.CanBuildChannelFactory<TChannel>(context);

    public override bool CanBuildChannelListener<TChannel>(BindingContext context) => this.innerHttpTransport.CanBuildChannelListener<TChannel>(context);

    public override BindingElement Clone() => (BindingElement) new HttpProxyTransportBindingElement(this);

    public override T GetProperty<T>(BindingContext context) => this.innerHttpTransport.GetProperty<T>(context);
  }
}
