// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.SelfIssuedAuthProofToken
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 1D4D5564-A025-490C-AF1D-DF4FBB709D1F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-f8f9f26e940480624825f6bddbea86e70fc4aa746c4dd8efa7d98dcb477000ed.exe

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IdentityModel.Tokens;
using System.Security.Cryptography;

namespace Microsoft.InfoCards
{
  internal class SelfIssuedAuthProofToken : SecurityToken, IDisposable
  {
    private string m_id;
    private DateTime m_expiration;
    private ReadOnlyCollection<SecurityKey> m_securityKeys;
    private SecurityKey m_securityKey;
    private bool m_isSymmetric;
    private RSACryptoServiceProvider m_publicKey;

    public SelfIssuedAuthProofToken(RSACryptoServiceProvider rsa, DateTime expiration)
      : this(expiration)
    {
      this.m_publicKey = new RSACryptoServiceProvider();
      this.m_publicKey.ImportCspBlob(rsa.ExportCspBlob(false));
      this.InitCrypto((SecurityKey) new SelfIssuedAuthAsymmetricKey(rsa));
    }

    public SelfIssuedAuthProofToken(InMemorySymmetricSecurityKey symKey, DateTime expiration)
      : this(expiration)
    {
      this.m_isSymmetric = true;
      this.InitCrypto((SecurityKey) symKey);
    }

    private SelfIssuedAuthProofToken(DateTime expiration)
    {
      this.m_id = Guid.NewGuid().ToString();
      this.m_expiration = expiration.ToUniversalTime();
    }

    public override string Id => this.m_id;

    public override ReadOnlyCollection<SecurityKey> SecurityKeys => this.m_securityKeys;

    public override DateTime ValidTo => this.m_expiration;

    public override DateTime ValidFrom => DateTime.UtcNow;

    private void InitCrypto(SecurityKey securityKey)
    {
      this.m_securityKey = securityKey;
      this.m_securityKeys = new List<SecurityKey>(1)
      {
        securityKey
      }.AsReadOnly();
    }

    public override bool CanCreateKeyIdentifierClause<T>() => (object) typeof (T) == (object) typeof (RsaKeyIdentifierClause);

    public override T CreateKeyIdentifierClause<T>() => (object) typeof (T) == (object) typeof (RsaKeyIdentifierClause) ? (T) new RsaKeyIdentifierClause((RSA) this.m_publicKey) : base.CreateKeyIdentifierClause<T>();

    public override bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause) => keyIdentifierClause is RsaKeyIdentifierClause identifierClause && identifierClause.Matches((RSA) this.m_publicKey);

    public void Dispose()
    {
      if (this.m_securityKey != null && !this.m_isSymmetric)
      {
        ((IDisposable) this.m_securityKey).Dispose();
        this.m_securityKey = (SecurityKey) null;
        this.m_securityKeys = (ReadOnlyCollection<SecurityKey>) null;
      }
      if (this.m_publicKey == null)
        return;
      this.m_publicKey.Dispose();
      this.m_publicKey = (RSACryptoServiceProvider) null;
    }
  }
}
