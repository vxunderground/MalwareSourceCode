// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.SelfIssuedAuthRSACryptoProvider
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 1D4D5564-A025-490C-AF1D-DF4FBB709D1F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-f8f9f26e940480624825f6bddbea86e70fc4aa746c4dd8efa7d98dcb477000ed.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.Security.Cryptography;

namespace Microsoft.InfoCards
{
  internal class SelfIssuedAuthRSACryptoProvider : RSA
  {
    private RSACryptoServiceProvider m_rsa;

    public SelfIssuedAuthRSACryptoProvider(RSACryptoServiceProvider rsa) => this.m_rsa = rsa;

    public override string SignatureAlgorithm => this.m_rsa.SignatureAlgorithm;

    public override string KeyExchangeAlgorithm => this.m_rsa.KeyExchangeAlgorithm;

    public bool IsPublicOnly() => this.m_rsa.PublicOnly;

    public override byte[] EncryptValue(byte[] rgb) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override byte[] DecryptValue(byte[] rgb) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] Decrypt(byte[] inData, bool fAOEP) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] Encrypt(byte[] inData, bool fAOEP) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] SignHash(byte[] hash, string hashAlgOid)
    {
      InfoCardTrace.ThrowInvalidArgumentConditional(hash == null || 0 == hash.Length, nameof (hash));
      InfoCardTrace.ThrowInvalidArgumentConditional(string.IsNullOrEmpty(hashAlgOid), nameof (hashAlgOid));
      return this.m_rsa.SignHash(hash, hashAlgOid);
    }

    public bool VerifyHash(byte[] hash, string hashAlgOid, byte[] sig)
    {
      InfoCardTrace.ThrowInvalidArgumentConditional(hash == null || 0 == hash.Length, nameof (hash));
      InfoCardTrace.ThrowInvalidArgumentConditional(string.IsNullOrEmpty(hashAlgOid), nameof (hashAlgOid));
      InfoCardTrace.ThrowInvalidArgumentConditional(sig == null || 0 == sig.Length, nameof (sig));
      return this.m_rsa.VerifyHash(hash, hashAlgOid, sig);
    }

    public override RSAParameters ExportParameters(bool includePrivateParameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override string ToXmlString(bool includePrivateParameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override void FromXmlString(string xmlString) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override void ImportParameters(RSAParameters parameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    protected override void Dispose(bool disposing)
    {
      if (this.m_rsa == null)
        return;
      this.m_rsa.Dispose();
    }
  }
}
