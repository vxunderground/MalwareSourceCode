// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.InfoCardBinaryReader
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 1D4D5564-A025-490C-AF1D-DF4FBB709D1F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-f8f9f26e940480624825f6bddbea86e70fc4aa746c4dd8efa7d98dcb477000ed.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.InfoCards
{
  internal sealed class InfoCardBinaryReader : BinaryReader
  {
    private static readonly char[] s_singleChar = new char[1]
    {
      'a'
    };
    private int m_charSize;

    public InfoCardBinaryReader(Stream stream, Encoding encoding)
      : base(stream, encoding)
    {
      this.m_charSize = encoding.GetByteCount(InfoCardBinaryReader.s_singleChar);
    }

    public InfoCardBinaryReader(Stream stream)
      : this(stream, Encoding.Unicode)
    {
    }

    public override int Read()
    {
      this.EnsureBufferBounds(1L);
      return base.Read();
    }

    public override int Read(byte[] buffer, int index, int count) => base.Read(buffer, index, count);

    public override int Read(char[] buffer, int index, int count) => base.Read(buffer, index, count);

    public override bool ReadBoolean()
    {
      this.EnsureBufferBounds(1L);
      return base.ReadBoolean();
    }

    public override byte ReadByte()
    {
      this.EnsureBufferBounds(1L);
      return base.ReadByte();
    }

    public override byte[] ReadBytes(int count)
    {
      this.EnsureBufferBounds((long) count);
      return base.ReadBytes(count);
    }

    public override char ReadChar()
    {
      this.EnsureBufferBounds((long) this.m_charSize);
      return base.ReadChar();
    }

    public override char[] ReadChars(int count)
    {
      this.EnsureBufferBounds(Convert.ToInt64(this.m_charSize * count));
      return base.ReadChars(count);
    }

    public override Decimal ReadDecimal()
    {
      this.EnsureBufferBounds(Convert.ToInt64(Marshal.SizeOf(typeof (Decimal))));
      return base.ReadDecimal();
    }

    public override double ReadDouble()
    {
      this.EnsureBufferBounds(8L);
      return base.ReadDouble();
    }

    public override short ReadInt16()
    {
      this.EnsureBufferBounds(2L);
      return base.ReadInt16();
    }

    public override int ReadInt32()
    {
      this.EnsureBufferBounds(4L);
      return base.ReadInt32();
    }

    public override long ReadInt64()
    {
      this.EnsureBufferBounds(8L);
      return base.ReadInt64();
    }

    public override sbyte ReadSByte()
    {
      this.EnsureBufferBounds(1L);
      return base.ReadSByte();
    }

    public override float ReadSingle()
    {
      this.EnsureBufferBounds(4L);
      return base.ReadSingle();
    }

    public override string ReadString()
    {
      this.EnsureBufferBounds((long) (this.m_charSize * this.PeekChar() + 4));
      return base.ReadString();
    }

    public override ushort ReadUInt16()
    {
      this.EnsureBufferBounds(4L);
      return base.ReadUInt16();
    }

    public override uint ReadUInt32()
    {
      this.EnsureBufferBounds(4L);
      return base.ReadUInt32();
    }

    public override ulong ReadUInt64()
    {
      this.EnsureBufferBounds(8L);
      return base.ReadUInt64();
    }

    private void EnsureBufferBounds(long offset)
    {
      if ((ulong) (this.BaseStream.Position + offset) > (ulong) this.BaseStream.Length)
        throw InfoCardTrace.ThrowHelperError((Exception) new InfoCardArgumentException(SR.GetString("InvalidOrCorruptArgumentStream")));
    }
  }
}
