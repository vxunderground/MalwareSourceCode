// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.ExportFileRequest
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: ADE0A079-11DB-4A46-8BDE-D2A592CA8DEA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-1f15ee7e9f7da02b6bfb4c5a5e6484eb9fa71b82d3699c54bcc7a31794b4a66d.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;

namespace Microsoft.InfoCards
{
  internal class ExportFileRequest : UIAgentRequest
  {
    private string m_filename;
    private string m_passphrase;
    private string[] m_cardIds;

    public ExportFileRequest(
      IntPtr rpcHandle,
      Stream inArgs,
      Stream outArgs,
      ClientUIRequest parent)
      : base(rpcHandle, inArgs, outArgs, parent)
    {
    }

    protected override void OnMarshalInArgs()
    {
      BinaryReader reader = (BinaryReader) new InfoCardBinaryReader(this.InArgs, Encoding.Unicode);
      this.m_filename = Utility.DeserializeString(reader);
      this.m_passphrase = Utility.DeserializeString(reader);
      uint length = reader.ReadUInt32();
      this.m_cardIds = new string[(IntPtr) length];
      for (uint index = 0; index < length; ++index)
        this.m_cardIds[(IntPtr) index] = Utility.DeserializeString(reader);
    }

    protected override void OnProcess()
    {
      InfoCardTrace.Assert(!string.IsNullOrEmpty(this.m_filename), "No file name was specified");
      InfoCardTrace.Assert(!string.IsNullOrEmpty(this.m_passphrase), " No passphrase specified for the file");
      StoreConnection connection = StoreConnection.GetConnection();
      try
      {
        RoamingStoreFile roamingStoreFile = new RoamingStoreFile();
        try
        {
          for (int index = 0; index < this.m_cardIds.Length; ++index)
          {
            InfoCard infoCard = new InfoCard(new Uri(this.m_cardIds[index]));
            infoCard.Get(connection);
            infoCard.GetMasterKey(connection);
            roamingStoreFile.Cards.Add(infoCard);
          }
          using (FileStream output = new FileStream(this.m_filename, FileMode.Create))
          {
            using (XmlWriter writer = XmlWriter.Create((Stream) output, new XmlWriterSettings()
            {
              CloseOutput = false
            }))
            {
              roamingStoreFile.WriteTo(this.m_passphrase, writer);
              writer.Flush();
            }
            output.Flush();
          }
        }
        finally
        {
          foreach (InfoCard card in (IEnumerable<InfoCard>) roamingStoreFile.Cards)
            card.ClearSensitiveData();
        }
        AuditLog.AuditStoreExport();
      }
      catch (XmlSchemaValidationException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("SchemaValidationFailed"), (Exception) ex));
      }
      catch (XmlException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("InvalidImportFile"), (Exception) ex));
      }
      catch (UnauthorizedAccessException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("ImportInaccesibleFile"), (Exception) ex));
      }
      catch (IOException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("InvalidImportFile"), (Exception) ex));
      }
      catch (ArgumentException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("ImportInaccesibleFile"), (Exception) ex));
      }
      catch (SerializationIncompleteException ex)
      {
        throw InfoCardTrace.ThrowHelperError((Exception) new ExportException(SR.GetString("FailedToSerializeObject", (object) ex.ObjectType), (Exception) ex));
      }
      finally
      {
        connection.Close();
      }
    }

    protected override void OnMarshalOutArgs()
    {
    }
  }
}
