// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.HttpProxyTransportBindingElement
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: ADE0A079-11DB-4A46-8BDE-D2A592CA8DEA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Expiro.w-1f15ee7e9f7da02b6bfb4c5a5e6484eb9fa71b82d3699c54bcc7a31794b4a66d.exe

using Microsoft.InfoCards.Diagnostics;
using System.Net;
using System.ServiceModel.Channels;

namespace Microsoft.InfoCards
{
  internal class HttpProxyTransportBindingElement : TransportBindingElement
  {
    private HttpTransportBindingElement innerHttpTransport;
    private IWebProxy proxy;

    public static BindingElementCollection ReplaceHttpTransportWithProxy(
      BindingElementCollection bindingElements,
      IWebProxy proxy,
      bool turnOffClientAuthOnTransport)
    {
      int index1 = -1;
      for (int index2 = 0; index2 < bindingElements.Count; ++index2)
      {
        if (bindingElements[index2] is HttpTransportBindingElement)
        {
          index1 = index2;
          break;
        }
      }
      if (index1 == -1)
        return bindingElements;
      InfoCardTrace.Assert(index1 == bindingElements.Count - 1, "Transport should be last in the Binding Element list");
      HttpTransportBindingElement bindingElement = (HttpTransportBindingElement) bindingElements[index1];
      if (turnOffClientAuthOnTransport)
        bindingElement.AuthenticationScheme = AuthenticationSchemes.Anonymous;
      HttpProxyTransportBindingElement transportBindingElement = new HttpProxyTransportBindingElement(proxy, bindingElement);
      bindingElements[index1] = (BindingElement) transportBindingElement;
      return bindingElements;
    }

    private HttpProxyTransportBindingElement(
      IWebProxy proxy,
      HttpTransportBindingElement innerHttpTransport)
    {
      this.innerHttpTransport = innerHttpTransport;
      this.proxy = proxy;
    }

    private HttpProxyTransportBindingElement(HttpProxyTransportBindingElement elementToBeCloned)
      : base((TransportBindingElement) elementToBeCloned)
    {
      this.innerHttpTransport = elementToBeCloned.innerHttpTransport;
      this.proxy = elementToBeCloned.proxy;
    }

    public override long MaxBufferPoolSize
    {
      get => this.innerHttpTransport.MaxBufferPoolSize;
      set => this.innerHttpTransport.MaxBufferPoolSize = value;
    }

    public override long MaxReceivedMessageSize
    {
      get => this.innerHttpTransport.MaxReceivedMessageSize;
      set => this.innerHttpTransport.MaxReceivedMessageSize = value;
    }

    public override string Scheme => this.innerHttpTransport.Scheme;

    public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(
      BindingContext context)
    {
      this.innerHttpTransport.Proxy = this.proxy;
      return this.innerHttpTransport.BuildChannelFactory<TChannel>(context);
    }

    public override IChannelListener<TChannel> BuildChannelListener<TChannel>(
      BindingContext context)
    {
      return this.innerHttpTransport.BuildChannelListener<TChannel>(context);
    }

    public override bool CanBuildChannelFactory<TChannel>(BindingContext context) => this.innerHttpTransport.CanBuildChannelFactory<TChannel>(context);

    public override bool CanBuildChannelListener<TChannel>(BindingContext context) => this.innerHttpTransport.CanBuildChannelListener<TChannel>(context);

    public override BindingElement Clone() => (BindingElement) new HttpProxyTransportBindingElement(this);

    public override T GetProperty<T>(BindingContext context) => this.innerHttpTransport.GetProperty<T>(context);
  }
}
