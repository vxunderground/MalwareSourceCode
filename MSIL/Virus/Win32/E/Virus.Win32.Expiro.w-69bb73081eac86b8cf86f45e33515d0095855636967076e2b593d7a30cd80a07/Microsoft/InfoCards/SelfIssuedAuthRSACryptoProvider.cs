// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.SelfIssuedAuthRSACryptoProvider
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 516D8B44-4448-4D2C-8B8E-FFBB3FFE472B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Virus.Win32.Expiro.w-69bb73081eac86b8cf86f45e33515d0095855636967076e2b593d7a30cd80a07.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.Security.Cryptography;

namespace Microsoft.InfoCards
{
  internal class SelfIssuedAuthRSACryptoProvider : RSA
  {
    private RSACryptoServiceProvider m_rsa;

    public SelfIssuedAuthRSACryptoProvider(RSACryptoServiceProvider rsa) => this.m_rsa = rsa;

    public override string SignatureAlgorithm => this.m_rsa.SignatureAlgorithm;

    public override string KeyExchangeAlgorithm => this.m_rsa.KeyExchangeAlgorithm;

    public bool IsPublicOnly() => this.m_rsa.PublicOnly;

    public override byte[] EncryptValue(byte[] rgb) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override byte[] DecryptValue(byte[] rgb) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] Decrypt(byte[] inData, bool fAOEP) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] Encrypt(byte[] inData, bool fAOEP) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public byte[] SignHash(byte[] hash, string hashAlgOid)
    {
      InfoCardTrace.ThrowInvalidArgumentConditional(hash == null || 0 == hash.Length, nameof (hash));
      InfoCardTrace.ThrowInvalidArgumentConditional(string.IsNullOrEmpty(hashAlgOid), nameof (hashAlgOid));
      return this.m_rsa.SignHash(hash, hashAlgOid);
    }

    public bool VerifyHash(byte[] hash, string hashAlgOid, byte[] sig)
    {
      InfoCardTrace.ThrowInvalidArgumentConditional(hash == null || 0 == hash.Length, nameof (hash));
      InfoCardTrace.ThrowInvalidArgumentConditional(string.IsNullOrEmpty(hashAlgOid), nameof (hashAlgOid));
      InfoCardTrace.ThrowInvalidArgumentConditional(sig == null || 0 == sig.Length, nameof (sig));
      return this.m_rsa.VerifyHash(hash, hashAlgOid, sig);
    }

    public override RSAParameters ExportParameters(bool includePrivateParameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override string ToXmlString(bool includePrivateParameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override void FromXmlString(string xmlString) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    public override void ImportParameters(RSAParameters parameters) => throw InfoCardTrace.ThrowHelperError((Exception) new NotSupportedException());

    protected override void Dispose(bool disposing)
    {
      if (this.m_rsa == null)
        return;
      this.m_rsa.Dispose();
    }
  }
}
