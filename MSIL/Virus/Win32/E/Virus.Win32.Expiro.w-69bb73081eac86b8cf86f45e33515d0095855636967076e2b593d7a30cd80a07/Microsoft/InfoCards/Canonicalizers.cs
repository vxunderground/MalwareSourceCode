// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.Canonicalizers
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 516D8B44-4448-4D2C-8B8E-FFBB3FFE472B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Virus.Win32.Expiro.w-69bb73081eac86b8cf86f45e33515d0095855636967076e2b593d7a30cd80a07.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Microsoft.InfoCards
{
  internal sealed class Canonicalizers
  {
    private static ICanonicalizer s_binary;
    private static ICanonicalizer s_caseInsensitiveWithHashing;
    private static ICanonicalizer s_caseSensitiveWithHashing;
    private static ICanonicalizer s_binaryWithHashing;

    private Canonicalizers()
    {
    }

    public static ICanonicalizer CaseInsensitiveWithHashing
    {
      get
      {
        if (Canonicalizers.s_caseInsensitiveWithHashing == null)
          Canonicalizers.s_caseInsensitiveWithHashing = (ICanonicalizer) new Canonicalizers.CaseInsensitiveCanonicalizer(true, Encoding.Unicode, CultureInfo.InvariantCulture);
        return Canonicalizers.s_caseInsensitiveWithHashing;
      }
    }

    public static ICanonicalizer CaseSensitiveWithHashing
    {
      get
      {
        if (Canonicalizers.s_caseSensitiveWithHashing == null)
          Canonicalizers.s_caseSensitiveWithHashing = (ICanonicalizer) new Canonicalizers.CaseSensitiveCanonicalizer(true, Encoding.Unicode, CultureInfo.InvariantCulture);
        return Canonicalizers.s_caseSensitiveWithHashing;
      }
    }

    public static ICanonicalizer Binary
    {
      get
      {
        if (Canonicalizers.s_binary == null)
          Canonicalizers.s_binary = (ICanonicalizer) new Canonicalizers.BinaryCanonicalizer(false);
        return Canonicalizers.s_binary;
      }
    }

    public static ICanonicalizer BinaryWithHashing
    {
      get
      {
        if (Canonicalizers.s_binaryWithHashing == null)
          Canonicalizers.s_binaryWithHashing = (ICanonicalizer) new Canonicalizers.BinaryCanonicalizer(true);
        return Canonicalizers.s_binaryWithHashing;
      }
    }

    private delegate byte[] CanonicalizeObjectCallback(object dataToHash);

    private abstract class CanonicalizerBase : ICanonicalizer
    {
      private bool m_hashValue;

      public CanonicalizerBase(bool hashValue) => this.m_hashValue = hashValue;

      public byte[] Canonicalize(object obj)
      {
        byte[] dataToHash = obj != null ? this.GetRawForm(obj) : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (obj));
        if (!this.m_hashValue)
          return dataToHash;
        byte[] data = new byte[HashUtility.HashBufferLength];
        HashUtility.SetHashValue(data, 0, dataToHash);
        return data;
      }

      public abstract bool CanCanonicalize(object obj);

      protected abstract byte[] GetRawForm(object obj);
    }

    private class BinaryCanonicalizer : Canonicalizers.CanonicalizerBase
    {
      private Dictionary<Type, Canonicalizers.CanonicalizeObjectCallback> m_canonicalizers;

      public BinaryCanonicalizer(bool hashValue)
        : base(hashValue)
      {
        this.m_canonicalizers = new Dictionary<Type, Canonicalizers.CanonicalizeObjectCallback>();
        this.CreateCanonicalizers();
      }

      public override bool CanCanonicalize(object obj) => obj != null ? this.m_canonicalizers.ContainsKey(obj.GetType()) : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (obj));

      private void CreateCanonicalizers()
      {
        this.m_canonicalizers.Add(typeof (short), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeInt16));
        this.m_canonicalizers.Add(typeof (ushort), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeUInt16));
        this.m_canonicalizers.Add(typeof (int), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeInt32));
        this.m_canonicalizers.Add(typeof (uint), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeUInt32));
        this.m_canonicalizers.Add(typeof (long), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeInt64));
        this.m_canonicalizers.Add(typeof (ulong), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeUInt64));
        this.m_canonicalizers.Add(typeof (byte), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeByte));
        this.m_canonicalizers.Add(typeof (byte[]), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeByteArray));
        this.m_canonicalizers.Add(typeof (string), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeString));
        this.m_canonicalizers.Add(typeof (Guid), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeGuid));
        this.m_canonicalizers.Add(typeof (GlobalId), new Canonicalizers.CanonicalizeObjectCallback(this.CanonicalizeGlobalId));
      }

      protected override byte[] GetRawForm(object obj) => this.m_canonicalizers[obj.GetType()](obj);

      private byte[] CanonicalizeGlobalId(object data) => data != null ? ((Guid) (GlobalId) data).ToByteArray() : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));

      private byte[] CanonicalizeGuid(object data) => data != null ? ((Guid) data).ToByteArray() : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));

      private unsafe byte[] CanonicalizeInt16(object data)
      {
        short num = data != null ? (short) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[2];
        fixed (byte* numPtr = &numArray[0])
          *(short*) numPtr = num;
        return numArray;
      }

      private unsafe byte[] CanonicalizeUInt16(object data)
      {
        ushort num = data != null ? (ushort) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[2];
        fixed (byte* numPtr = &numArray[0])
          *(short*) numPtr = (short) num;
        return numArray;
      }

      private unsafe byte[] CanonicalizeInt32(object data)
      {
        int num = data != null ? (int) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[4];
        fixed (byte* numPtr = &numArray[0])
          *(int*) numPtr = num;
        return numArray;
      }

      private unsafe byte[] CanonicalizeUInt32(object data)
      {
        uint num = data != null ? (uint) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[4];
        fixed (byte* numPtr = &numArray[0])
          *(int*) numPtr = (int) num;
        return numArray;
      }

      private unsafe byte[] CanonicalizeInt64(object data)
      {
        long num = data != null ? (long) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[8];
        fixed (byte* numPtr = &numArray[0])
          *(long*) numPtr = num;
        return numArray;
      }

      private unsafe byte[] CanonicalizeUInt64(object data)
      {
        ulong num = data != null ? (ulong) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        byte[] numArray = new byte[8];
        fixed (byte* numPtr = &numArray[0])
          *(long*) numPtr = (long) num;
        return numArray;
      }

      private byte[] CanonicalizeString(object data)
      {
        string s = data != null ? (string) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
        return !string.IsNullOrEmpty(s) ? Encoding.Unicode.GetBytes(s) : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
      }

      private byte[] CanonicalizeByte(object data) => data != null ? new byte[1]
      {
        (byte) data
      } : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));

      private byte[] CanonicalizeByteArray(object data) => data != null ? (byte[]) data : throw InfoCardTrace.ThrowHelperArgumentNull(nameof (data));
    }

    private abstract class StringCanonicalizerBase : Canonicalizers.CanonicalizerBase
    {
      private static readonly Type[] s_validTypes = new Type[2]
      {
        typeof (string),
        typeof (Uri)
      };
      private Encoding m_encoding;
      private CultureInfo m_culture;

      protected StringCanonicalizerBase(bool hashValue, Encoding encoding, CultureInfo culture)
        : base(hashValue)
      {
        if (encoding == null)
          throw InfoCardTrace.ThrowHelperArgumentNull(nameof (encoding));
        this.m_culture = culture != null ? culture : CultureInfo.InvariantCulture;
        this.m_encoding = encoding;
      }

      protected virtual Type[] SupportedTypes => Canonicalizers.StringCanonicalizerBase.s_validTypes;

      public CultureInfo Culture => this.m_culture;

      public Encoding Encoding => this.m_encoding;

      public override bool CanCanonicalize(object obj)
      {
        if (obj == null)
          throw InfoCardTrace.ThrowHelperArgumentNull(nameof (obj));
        return this.SupportedTypes != null && -1 != Array.IndexOf<Type>(this.SupportedTypes, obj.GetType());
      }

      protected override byte[] GetRawForm(object obj) => this.GetBytesFromString(obj.ToString());

      protected abstract byte[] GetBytesFromString(string data);
    }

    private class CaseSensitiveCanonicalizer : Canonicalizers.StringCanonicalizerBase
    {
      public CaseSensitiveCanonicalizer(bool hashValue, Encoding encoding, CultureInfo culture)
        : base(hashValue, encoding, culture)
      {
      }

      protected override byte[] GetBytesFromString(string data) => this.Encoding.GetBytes(data);
    }

    private class CaseInsensitiveCanonicalizer : Canonicalizers.StringCanonicalizerBase
    {
      public CaseInsensitiveCanonicalizer(bool hashValue, Encoding encoding, CultureInfo culture)
        : base(hashValue, encoding, culture)
      {
      }

      protected override byte[] GetBytesFromString(string obj) => this.Encoding.GetBytes(this.Culture.TextInfo.ToUpper(obj));
    }
  }
}
