// Decompiled with JetBrains decompiler
// Type: Microsoft.Build.Shared.AssemblyLoadInfo
// Assembly: MSBuild, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: E42BAB90-704E-4C03-B5C0-D4E3A6B884E3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Nimnul.c-d5c6463b93131b3c485115414cf5809e01323986e3d4274a4868222cbb54aa43.exe

namespace Microsoft.Build.Shared
{
  internal sealed class AssemblyLoadInfo
  {
    private string assemblyName;
    private string assemblyFile;

    private AssemblyLoadInfo()
    {
    }

    internal AssemblyLoadInfo(string assemblyName, string assemblyFile)
    {
      ErrorUtilities.VerifyThrow(assemblyName != null && assemblyName.Length > 0 || assemblyFile != null && assemblyFile.Length > 0, "We must have either the assembly name or the assembly file/path.");
      ErrorUtilities.VerifyThrow(assemblyName == null || assemblyFile == null, "We must not have both the assembly name and the assembly file/path.");
      this.assemblyName = assemblyName;
      this.assemblyFile = assemblyFile;
    }

    internal string AssemblyName => this.assemblyName;

    internal string AssemblyFile => this.assemblyFile;

    public override string ToString()
    {
      if (this.assemblyName != null)
      {
        ErrorUtilities.VerifyThrow(this.assemblyFile == null, "We cannot have both the assembly name and the assembly file/path.");
        return this.assemblyName;
      }
      ErrorUtilities.VerifyThrow(this.assemblyFile != null, "We must have either the assembly name or the assembly file/path.");
      return this.assemblyFile;
    }

    public override int GetHashCode() => this.ToString().GetHashCode();

    public override bool Equals(object obj)
    {
      if (obj == null || !(obj is AssemblyLoadInfo))
        return false;
      AssemblyLoadInfo assemblyLoadInfo = (AssemblyLoadInfo) obj;
      return this.AssemblyName == assemblyLoadInfo.AssemblyName && this.AssemblyFile == assemblyLoadInfo.AssemblyFile;
    }
  }
}
