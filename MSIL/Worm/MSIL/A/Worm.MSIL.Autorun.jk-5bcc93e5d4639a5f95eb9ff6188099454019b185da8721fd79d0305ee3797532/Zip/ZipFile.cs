// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.ZipFile
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using ICSharpCode.SharpZipLib.Zip.Compression;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;
using System.Collections;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class ZipFile : IEnumerable
  {
    private string name;
    private string comment;
    private Stream baseStream;
    private ZipEntry[] entries;

    public ZipFile(string name)
      : this(File.OpenRead(name))
    {
    }

    public ZipFile(FileStream file)
    {
      this.baseStream = (Stream) file;
      this.name = file.Name;
      this.ReadEntries();
    }

    public ZipFile(Stream baseStream)
    {
      this.baseStream = baseStream;
      this.name = (string) null;
      this.ReadEntries();
    }

    private int ReadLeShort() => this.baseStream.ReadByte() | this.baseStream.ReadByte() << 8;

    private int ReadLeInt() => this.ReadLeShort() | this.ReadLeShort() << 16;

    private void ReadEntries()
    {
      long num1 = this.baseStream.Length - 22L;
      while (num1 >= 0L)
      {
        this.baseStream.Seek(num1--, SeekOrigin.Begin);
        if (this.ReadLeInt() == 101010256)
        {
          long position1 = this.baseStream.Position;
          this.baseStream.Position += 6L;
          if (this.baseStream.Position - position1 != 6L)
            throw new EndOfStreamException();
          int length = this.ReadLeShort();
          long position2 = this.baseStream.Position;
          this.baseStream.Position += 4L;
          if (this.baseStream.Position - position2 != 4L)
            throw new EndOfStreamException();
          int offset = this.ReadLeInt();
          byte[] numArray1 = new byte[(int) checked ((uint) this.ReadLeShort())];
          this.baseStream.Read(numArray1, 0, numArray1.Length);
          this.comment = ZipConstants.ConvertToString(numArray1);
          this.entries = new ZipEntry[(int) checked ((uint) length)];
          this.baseStream.Seek((long) offset, SeekOrigin.Begin);
          for (int index = 0; index < length; ++index)
          {
            if (this.ReadLeInt() != 33639248)
              throw new ZipException("Wrong Central Directory signature");
            long position3 = this.baseStream.Position;
            this.baseStream.Position += 6L;
            if (this.baseStream.Position - position3 != 6L)
              throw new EndOfStreamException();
            int num2 = this.ReadLeShort();
            int num3 = this.ReadLeInt();
            int num4 = this.ReadLeInt();
            int num5 = this.ReadLeInt();
            int num6 = this.ReadLeInt();
            int num7 = this.ReadLeShort();
            int count = this.ReadLeShort();
            int num8 = this.ReadLeShort();
            long position4 = this.baseStream.Position;
            this.baseStream.Position += 8L;
            if (this.baseStream.Position - position4 != 8L)
              throw new EndOfStreamException();
            int num9 = this.ReadLeInt();
            byte[] numArray2 = new byte[(int) checked ((uint) Math.Max(num7, num8))];
            this.baseStream.Read(numArray2, 0, num7);
            ZipEntry zipEntry = new ZipEntry(ZipConstants.ConvertToString(numArray2));
            zipEntry.CompressionMethod = (CompressionMethod) num2;
            zipEntry.Crc = (long) num4 & (long) uint.MaxValue;
            zipEntry.Size = (long) num6 & (long) uint.MaxValue;
            zipEntry.CompressedSize = (long) num5 & (long) uint.MaxValue;
            zipEntry.DosTime = (uint) num3;
            if (count > 0)
            {
              byte[] buffer = new byte[(int) checked ((uint) count)];
              this.baseStream.Read(buffer, 0, count);
              zipEntry.ExtraData = buffer;
            }
            if (num8 > 0)
            {
              this.baseStream.Read(numArray2, 0, num8);
              zipEntry.Comment = ZipConstants.ConvertToString(numArray2);
            }
            zipEntry.zipFileIndex = index;
            zipEntry.offset = num9;
            this.entries[index] = zipEntry;
          }
          return;
        }
      }
      throw new ZipException("central directory not found, probably not a zip file");
    }

    public void Close()
    {
      this.entries = (ZipEntry[]) null;
      lock (this.baseStream)
        this.baseStream.Close();
    }

    public IEnumerator GetEnumerator() => this.entries != null ? (IEnumerator) new ZipFile.ZipEntryEnumeration(this.entries) : throw new InvalidOperationException("ZipFile has closed");

    private int GetEntryIndex(string name)
    {
      for (int entryIndex = 0; entryIndex < this.entries.Length; ++entryIndex)
      {
        if (name.Equals(this.entries[entryIndex].Name))
          return entryIndex;
      }
      return -1;
    }

    public ZipEntry GetEntry(string name)
    {
      if (this.entries == null)
        throw new InvalidOperationException("ZipFile has closed");
      int entryIndex = this.GetEntryIndex(name);
      return entryIndex >= 0 ? (ZipEntry) this.entries[entryIndex].Clone() : (ZipEntry) null;
    }

    private long CheckLocalHeader(ZipEntry entry)
    {
      lock (this.baseStream)
      {
        this.baseStream.Seek((long) entry.offset, SeekOrigin.Begin);
        if (this.ReadLeInt() != 67324752)
          throw new ZipException("Wrong Local header signature");
        long position1 = this.baseStream.Position;
        this.baseStream.Position += 4L;
        if (this.baseStream.Position - position1 != 4L)
          throw new EndOfStreamException();
        if (entry.CompressionMethod != (CompressionMethod) this.ReadLeShort())
          throw new ZipException("Compression method mismatch");
        long position2 = this.baseStream.Position;
        this.baseStream.Position += 16L;
        if (this.baseStream.Position - position2 != 16L)
          throw new EndOfStreamException();
        if (entry.Name.Length != this.ReadLeShort())
          throw new ZipException("file name length mismatch");
        int num = entry.Name.Length + this.ReadLeShort();
        return (long) (entry.offset + 30 + num);
      }
    }

    public Stream GetInputStream(ZipEntry entry)
    {
      if (this.entries == null)
        throw new InvalidOperationException("ZipFile has closed");
      int index = entry.zipFileIndex;
      if (index < 0 || index >= this.entries.Length || this.entries[index].Name != entry.Name)
      {
        index = this.GetEntryIndex(entry.Name);
        if (index < 0)
          throw new IndexOutOfRangeException();
      }
      long start = this.CheckLocalHeader(this.entries[index]);
      CompressionMethod compressionMethod = this.entries[index].CompressionMethod;
      Stream baseInputStream = (Stream) new ZipFile.PartialInputStream(this.baseStream, start, this.entries[index].CompressedSize);
      switch (compressionMethod)
      {
        case CompressionMethod.Stored:
          return baseInputStream;
        case CompressionMethod.Deflated:
          return (Stream) new InflaterInputStream(baseInputStream, new Inflater(true));
        default:
          throw new ZipException("Unknown compression method " + (object) compressionMethod);
      }
    }

    public string ZipFileComment
    {
      get => this.comment;
      set => this.comment = value;
    }

    public string Name => this.name;

    public int Size
    {
      get
      {
        try
        {
          return this.entries.Length;
        }
        catch (Exception ex)
        {
          throw new InvalidOperationException("ZipFile has closed");
        }
      }
    }

    private class ZipEntryEnumeration : IEnumerator
    {
      private ZipEntry[] array;
      private int ptr = -1;

      public ZipEntryEnumeration(ZipEntry[] arr) => this.array = arr;

      public object Current => (object) this.array[this.ptr];

      public void Reset() => this.ptr = -1;

      public bool MoveNext() => ++this.ptr < this.array.Length;
    }

    private class PartialInputStream : InflaterInputStream
    {
      private Stream baseStream;
      private long filepos;
      private long end;

      public PartialInputStream(Stream baseStream, long start, long len)
        : base(baseStream)
      {
        this.baseStream = baseStream;
        this.filepos = start;
        this.end = start + len;
      }

      public override int Available
      {
        get
        {
          long num = this.end - this.filepos;
          return num > (long) int.MaxValue ? int.MaxValue : (int) num;
        }
      }

      public override int ReadByte()
      {
        if (this.filepos == this.end)
          return -1;
        lock (this.baseStream)
        {
          this.baseStream.Seek(this.filepos++, SeekOrigin.Begin);
          return this.baseStream.ReadByte();
        }
      }

      public override int Read(byte[] b, int off, int len)
      {
        if ((long) len > this.end - this.filepos)
        {
          len = (int) (this.end - this.filepos);
          if (len == 0)
            return -1;
        }
        lock (this.baseStream)
        {
          this.baseStream.Seek(this.filepos, SeekOrigin.Begin);
          int num = this.baseStream.Read(b, off, len);
          if (num > 0)
            this.filepos += (long) len;
          return num;
        }
      }

      public long SkipBytes(long amount)
      {
        if (amount < 0L)
          throw new ArgumentOutOfRangeException();
        if (amount > this.end - this.filepos)
          amount = this.end - this.filepos;
        this.filepos += amount;
        return amount;
      }
    }
  }
}
