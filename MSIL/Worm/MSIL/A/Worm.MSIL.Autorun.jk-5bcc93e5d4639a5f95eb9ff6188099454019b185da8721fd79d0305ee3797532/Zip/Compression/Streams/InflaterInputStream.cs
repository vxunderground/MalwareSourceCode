// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using ICSharpCode.SharpZipLib.Checksums;
using System;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class InflaterInputStream : Stream
  {
    protected Inflater inf;
    protected byte[] buf;
    protected int len;
    private byte[] onebytebuffer = new byte[1];
    protected Stream baseInputStream;
    protected byte[] cryptbuffer = (byte[]) null;
    private uint[] keys = (uint[]) null;

    public override bool CanRead => this.baseInputStream.CanRead;

    public override bool CanSeek => this.baseInputStream.CanSeek;

    public override bool CanWrite => this.baseInputStream.CanWrite;

    public override long Length => (long) this.len;

    public override long Position
    {
      get => this.baseInputStream.Position;
      set => this.baseInputStream.Position = value;
    }

    public override void Flush() => this.baseInputStream.Flush();

    public override long Seek(long offset, SeekOrigin origin) => this.baseInputStream.Seek(offset, origin);

    public override void SetLength(long val) => this.baseInputStream.SetLength(val);

    public override void Write(byte[] array, int offset, int count) => this.baseInputStream.Write(array, offset, count);

    public override void WriteByte(byte val) => this.baseInputStream.WriteByte(val);

    public InflaterInputStream(Stream baseInputStream)
      : this(baseInputStream, new Inflater(), 4096)
    {
    }

    public InflaterInputStream(Stream baseInputStream, Inflater inf)
      : this(baseInputStream, inf, 4096)
    {
    }

    public InflaterInputStream(Stream baseInputStream, Inflater inf, int size)
    {
      this.baseInputStream = baseInputStream;
      this.inf = inf;
      try
      {
        this.len = (int) baseInputStream.Length;
      }
      catch (Exception ex)
      {
        this.len = 0;
      }
      this.buf = size > 0 ? new byte[(int) checked ((uint) size)] : throw new ArgumentOutOfRangeException("size <= 0");
    }

    public virtual int Available => this.inf.IsFinished ? 0 : 1;

    public override void Close() => this.baseInputStream.Close();

    protected void Fill()
    {
      this.len = this.baseInputStream.Read(this.buf, 0, this.buf.Length);
      if (this.cryptbuffer != null)
        this.DecryptBlock(this.buf, 0, this.buf.Length);
      if (this.len <= 0)
        throw new ApplicationException("Deflated stream ends early.");
      this.inf.SetInput(this.buf, 0, this.len);
    }

    public override int ReadByte() => this.Read(this.onebytebuffer, 0, 1) > 0 ? (int) this.onebytebuffer[0] & (int) byte.MaxValue : -1;

    public override int Read(byte[] b, int off, int len)
    {
      int num;
      while (true)
      {
        try
        {
          num = this.inf.Inflate(b, off, len);
        }
        catch (Exception ex)
        {
          throw new ZipException(ex.ToString());
        }
        if (num <= 0)
        {
          if (!this.inf.IsNeedingDictionary)
          {
            if (!this.inf.IsFinished)
            {
              if (this.inf.IsNeedingInput)
                this.Fill();
              else
                goto label_11;
            }
            else
              goto label_8;
          }
          else
            goto label_6;
        }
        else
          break;
      }
      return num;
label_6:
      throw new ZipException("Need a dictionary");
label_8:
      return 0;
label_11:
      throw new InvalidOperationException("Don't know what to do");
    }

    public long Skip(long n)
    {
      if (n < 0L)
        throw new ArgumentOutOfRangeException(nameof (n));
      int length = 2048;
      if (n < (long) length)
        length = (int) n;
      byte[] buffer = new byte[(int) checked ((uint) length)];
      return (long) this.baseInputStream.Read(buffer, 0, buffer.Length);
    }

    protected byte DecryptByte()
    {
      uint num = (uint) ((int) this.keys[2] & (int) ushort.MaxValue | 2);
      return (byte) (num * (num ^ 1U) >> 8);
    }

    protected void DecryptBlock(byte[] buf, int off, int len)
    {
      for (int index1 = off; index1 < off + len; ++index1)
      {
        byte[] numArray;
        IntPtr index2;
        (numArray = buf)[(int) (index2 = (IntPtr) index1)] = (byte) ((uint) numArray[index2] ^ (uint) this.DecryptByte());
        this.UpdateKeys(buf[index1]);
      }
    }

    protected void InitializePassword(string password)
    {
      this.keys = new uint[3]
      {
        305419896U,
        591751049U,
        878082192U
      };
      for (int index = 0; index < password.Length; ++index)
        this.UpdateKeys((byte) password[index]);
    }

    private uint ComputeCrc32(uint oldCrc, byte bval) => Crc32.CrcTable[(IntPtr) (uint) (((int) oldCrc ^ (int) bval) & (int) byte.MaxValue)] ^ oldCrc >> 8;

    protected void UpdateKeys(byte ch)
    {
      this.keys[0] = this.ComputeCrc32(this.keys[0], ch);
      this.keys[1] = this.keys[1] + (uint) (byte) this.keys[0];
      this.keys[1] = (uint) ((int) this.keys[1] * 134775813 + 1);
      this.keys[2] = this.ComputeCrc32(this.keys[2], (byte) (this.keys[1] >> 24));
    }
  }
}
