// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class OutputWindow
  {
    private static int WINDOW_SIZE = 32768;
    private static int WINDOW_MASK = OutputWindow.WINDOW_SIZE - 1;
    private byte[] window = new byte[(int) checked ((uint) OutputWindow.WINDOW_SIZE)];
    private int window_end = 0;
    private int window_filled = 0;

    public void Write(int abyte)
    {
      if (this.window_filled++ == OutputWindow.WINDOW_SIZE)
        throw new InvalidOperationException("Window full");
      this.window[this.window_end++] = (byte) abyte;
      this.window_end &= OutputWindow.WINDOW_MASK;
    }

    private void SlowRepeat(int rep_start, int len, int dist)
    {
      while (len-- > 0)
      {
        this.window[this.window_end++] = this.window[rep_start++];
        this.window_end &= OutputWindow.WINDOW_MASK;
        rep_start &= OutputWindow.WINDOW_MASK;
      }
    }

    public void Repeat(int len, int dist)
    {
      if ((this.window_filled += len) > OutputWindow.WINDOW_SIZE)
        throw new InvalidOperationException("Window full");
      int num1 = this.window_end - dist & OutputWindow.WINDOW_MASK;
      int num2 = OutputWindow.WINDOW_SIZE - len;
      if (num1 <= num2 && this.window_end < num2)
      {
        if (len <= dist)
        {
          Array.Copy((Array) this.window, num1, (Array) this.window, this.window_end, len);
          this.window_end += len;
        }
        else
        {
          while (len-- > 0)
            this.window[this.window_end++] = this.window[num1++];
        }
      }
      else
        this.SlowRepeat(num1, len, dist);
    }

    public int CopyStored(StreamManipulator input, int len)
    {
      len = Math.Min(Math.Min(len, OutputWindow.WINDOW_SIZE - this.window_filled), input.AvailableBytes);
      int length = OutputWindow.WINDOW_SIZE - this.window_end;
      int num;
      if (len > length)
      {
        num = input.CopyBytes(this.window, this.window_end, length);
        if (num == length)
          num += input.CopyBytes(this.window, 0, len - length);
      }
      else
        num = input.CopyBytes(this.window, this.window_end, len);
      this.window_end = this.window_end + num & OutputWindow.WINDOW_MASK;
      this.window_filled += num;
      return num;
    }

    public void CopyDict(byte[] dict, int offset, int len)
    {
      if (this.window_filled > 0)
        throw new InvalidOperationException();
      if (len > OutputWindow.WINDOW_SIZE)
      {
        offset += len - OutputWindow.WINDOW_SIZE;
        len = OutputWindow.WINDOW_SIZE;
      }
      Array.Copy((Array) dict, offset, (Array) this.window, 0, len);
      this.window_end = len & OutputWindow.WINDOW_MASK;
    }

    public int GetFreeSpace() => OutputWindow.WINDOW_SIZE - this.window_filled;

    public int GetAvailable() => this.window_filled;

    public int CopyOutput(byte[] output, int offset, int len)
    {
      int num1 = this.window_end;
      if (len > this.window_filled)
        len = this.window_filled;
      else
        num1 = this.window_end - this.window_filled + len & OutputWindow.WINDOW_MASK;
      int num2 = len;
      int length = len - num1;
      if (length > 0)
      {
        Array.Copy((Array) this.window, OutputWindow.WINDOW_SIZE - length, (Array) output, offset, length);
        offset += length;
        len = num1;
      }
      Array.Copy((Array) this.window, num1 - len, (Array) output, offset, len);
      this.window_filled -= num2;
      if (this.window_filled < 0)
        throw new InvalidOperationException();
      return num2;
    }

    public void Reset() => this.window_filled = this.window_end = 0;
  }
}
