// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Deflater
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class Deflater
  {
    public static int BEST_COMPRESSION = 9;
    public static int BEST_SPEED = 1;
    public static int DEFAULT_COMPRESSION = -1;
    public static int NO_COMPRESSION = 0;
    public static int DEFLATED = 8;
    private static int IS_SETDICT = 1;
    private static int IS_FLUSHING = 4;
    private static int IS_FINISHING = 8;
    private static int INIT_STATE = 0;
    private static int SETDICT_STATE = 1;
    private static int BUSY_STATE = 16;
    private static int FLUSHING_STATE = 20;
    private static int FINISHING_STATE = 28;
    private static int FINISHED_STATE = 30;
    private static int CLOSED_STATE = (int) sbyte.MaxValue;
    private int level;
    private bool noHeader;
    private int state;
    private int totalOut;
    private DeflaterPending pending;
    private DeflaterEngine engine;

    public Deflater()
      : this(Deflater.DEFAULT_COMPRESSION, false)
    {
    }

    public Deflater(int lvl)
      : this(lvl, false)
    {
    }

    public Deflater(int lvl, bool nowrap)
    {
      if (lvl == Deflater.DEFAULT_COMPRESSION)
        lvl = 6;
      else if (lvl < Deflater.NO_COMPRESSION || lvl > Deflater.BEST_COMPRESSION)
        throw new ArgumentOutOfRangeException(nameof (lvl));
      this.pending = new DeflaterPending();
      this.engine = new DeflaterEngine(this.pending);
      this.noHeader = nowrap;
      this.SetStrategy(DeflateStrategy.Default);
      this.SetLevel(lvl);
      this.Reset();
    }

    public void Reset()
    {
      this.state = this.noHeader ? Deflater.BUSY_STATE : Deflater.INIT_STATE;
      this.totalOut = 0;
      this.pending.Reset();
      this.engine.Reset();
    }

    public int Adler => this.engine.Adler;

    public int TotalIn => this.engine.TotalIn;

    public int TotalOut => this.totalOut;

    public void Flush() => this.state |= Deflater.IS_FLUSHING;

    public void Finish() => this.state |= Deflater.IS_FLUSHING | Deflater.IS_FINISHING;

    public bool IsFinished => this.state == Deflater.FINISHED_STATE && this.pending.IsFlushed;

    public bool IsNeedingInput => this.engine.NeedsInput();

    public void SetInput(byte[] input) => this.SetInput(input, 0, input.Length);

    public void SetInput(byte[] input, int off, int len)
    {
      if ((this.state & Deflater.IS_FINISHING) != 0)
        throw new InvalidOperationException("finish()/end() already called");
      this.engine.SetInput(input, off, len);
    }

    public void SetLevel(int lvl)
    {
      if (lvl == Deflater.DEFAULT_COMPRESSION)
        lvl = 6;
      else if (lvl < Deflater.NO_COMPRESSION || lvl > Deflater.BEST_COMPRESSION)
        throw new ArgumentOutOfRangeException(nameof (lvl));
      if (this.level == lvl)
        return;
      this.level = lvl;
      this.engine.SetLevel(lvl);
    }

    public void SetStrategy(DeflateStrategy stgy) => this.engine.Strategy = stgy;

    public int Deflate(byte[] output) => this.Deflate(output, 0, output.Length);

    public int Deflate(byte[] output, int offset, int length)
    {
      int num1 = length;
      if (this.state == Deflater.CLOSED_STATE)
        throw new InvalidOperationException("Deflater closed");
      if (this.state < Deflater.BUSY_STATE)
      {
        int num2 = Deflater.DEFLATED + 112 << 8;
        int num3 = this.level - 1 >> 1;
        if (num3 < 0 || num3 > 3)
          num3 = 3;
        int num4 = num2 | num3 << 6;
        if ((this.state & Deflater.IS_SETDICT) != 0)
          num4 |= 32;
        this.pending.WriteShortMSB(num4 + (31 - num4 % 31));
        if ((this.state & Deflater.IS_SETDICT) != 0)
        {
          int adler = this.engine.Adler;
          this.engine.ResetAdler();
          this.pending.WriteShortMSB(adler >> 16);
          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
        }
        this.state = Deflater.BUSY_STATE | this.state & (Deflater.IS_FLUSHING | Deflater.IS_FINISHING);
      }
      while (true)
      {
        do
        {
          do
          {
            int num5 = this.pending.Flush(output, offset, length);
            offset += num5;
            this.totalOut += num5;
            length -= num5;
            if (length == 0 || this.state == Deflater.FINISHED_STATE)
              goto label_24;
          }
          while (this.engine.Deflate((this.state & Deflater.IS_FLUSHING) != 0, (this.state & Deflater.IS_FINISHING) != 0));
          if (this.state == Deflater.BUSY_STATE)
            return num1 - length;
          if (this.state == Deflater.FLUSHING_STATE)
          {
            if (this.level != Deflater.NO_COMPRESSION)
            {
              for (int index = 8 + (-this.pending.BitCount & 7); index > 0; index -= 10)
                this.pending.WriteBits(2, 10);
            }
            this.state = Deflater.BUSY_STATE;
          }
        }
        while (this.state != Deflater.FINISHING_STATE);
        this.pending.AlignToByte();
        if (!this.noHeader)
        {
          int adler = this.engine.Adler;
          this.pending.WriteShortMSB(adler >> 16);
          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
        }
        this.state = Deflater.FINISHED_STATE;
      }
label_24:
      return num1 - length;
    }

    public void SetDictionary(byte[] dict) => this.SetDictionary(dict, 0, dict.Length);

    public void SetDictionary(byte[] dict, int offset, int length)
    {
      this.state = this.state == Deflater.INIT_STATE ? Deflater.SETDICT_STATE : throw new InvalidOperationException();
      this.engine.SetDictionary(dict, offset, length);
    }
  }
}
