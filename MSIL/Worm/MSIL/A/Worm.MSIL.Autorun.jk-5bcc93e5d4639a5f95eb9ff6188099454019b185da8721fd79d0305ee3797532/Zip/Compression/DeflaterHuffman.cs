// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class DeflaterHuffman
  {
    private static int BUFSIZE = 16384;
    private static int LITERAL_NUM = 286;
    private static int DIST_NUM = 30;
    private static int BITLEN_NUM = 19;
    private static int REP_3_6 = 16;
    private static int REP_3_10 = 17;
    private static int REP_11_138 = 18;
    private static int EOF_SYMBOL = 256;
    private static int[] BL_ORDER = new int[19]
    {
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    };
    private static byte[] bit4Reverse = new byte[16]
    {
      (byte) 0,
      (byte) 8,
      (byte) 4,
      (byte) 12,
      (byte) 2,
      (byte) 10,
      (byte) 6,
      (byte) 14,
      (byte) 1,
      (byte) 9,
      (byte) 5,
      (byte) 13,
      (byte) 3,
      (byte) 11,
      (byte) 7,
      (byte) 15
    };
    public DeflaterPending pending;
    private DeflaterHuffman.Tree literalTree;
    private DeflaterHuffman.Tree distTree;
    private DeflaterHuffman.Tree blTree;
    private short[] d_buf;
    private byte[] l_buf;
    private int last_lit;
    private int extra_bits;
    private static short[] staticLCodes = new short[(int) checked ((uint) DeflaterHuffman.LITERAL_NUM)];
    private static byte[] staticLLength = new byte[(int) checked ((uint) DeflaterHuffman.LITERAL_NUM)];
    private static short[] staticDCodes;
    private static byte[] staticDLength;

    public static short BitReverse(int value) => (short) ((int) DeflaterHuffman.bit4Reverse[value & 15] << 12 | (int) DeflaterHuffman.bit4Reverse[value >> 4 & 15] << 8 | (int) DeflaterHuffman.bit4Reverse[value >> 8 & 15] << 4 | (int) DeflaterHuffman.bit4Reverse[value >> 12]);

    static DeflaterHuffman()
    {
      int index1;
      for (index1 = 0; index1 < 144; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(48 + index1 << 8);
      for (; index1 < 256; DeflaterHuffman.staticLLength[index1++] = (byte) 9)
        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(256 + index1 << 7);
      for (; index1 < 280; DeflaterHuffman.staticLLength[index1++] = (byte) 7)
        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 256 << 9);
      for (; index1 < DeflaterHuffman.LITERAL_NUM; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 88 << 8);
      DeflaterHuffman.staticDCodes = new short[(int) checked ((uint) DeflaterHuffman.DIST_NUM)];
      DeflaterHuffman.staticDLength = new byte[(int) checked ((uint) DeflaterHuffman.DIST_NUM)];
      for (int index2 = 0; index2 < DeflaterHuffman.DIST_NUM; ++index2)
      {
        DeflaterHuffman.staticDCodes[index2] = DeflaterHuffman.BitReverse(index2 << 11);
        DeflaterHuffman.staticDLength[index2] = (byte) 5;
      }
    }

    public DeflaterHuffman(DeflaterPending pending)
    {
      this.pending = pending;
      this.literalTree = new DeflaterHuffman.Tree(this, DeflaterHuffman.LITERAL_NUM, 257, 15);
      this.distTree = new DeflaterHuffman.Tree(this, DeflaterHuffman.DIST_NUM, 1, 15);
      this.blTree = new DeflaterHuffman.Tree(this, DeflaterHuffman.BITLEN_NUM, 4, 7);
      this.d_buf = new short[(int) checked ((uint) DeflaterHuffman.BUFSIZE)];
      this.l_buf = new byte[(int) checked ((uint) DeflaterHuffman.BUFSIZE)];
    }

    public void Reset()
    {
      this.last_lit = 0;
      this.extra_bits = 0;
      this.literalTree.Reset();
      this.distTree.Reset();
      this.blTree.Reset();
    }

    private int L_code(int len)
    {
      if (len == (int) byte.MaxValue)
        return 285;
      int num = 257;
      for (; len >= 8; len >>= 1)
        num += 4;
      return num + len;
    }

    private int D_code(int distance)
    {
      int num = 0;
      for (; distance >= 4; distance >>= 1)
        num += 2;
      return num + distance;
    }

    public void SendAllTrees(int blTreeCodes)
    {
      this.blTree.BuildCodes();
      this.literalTree.BuildCodes();
      this.distTree.BuildCodes();
      this.pending.WriteBits(this.literalTree.numCodes - 257, 5);
      this.pending.WriteBits(this.distTree.numCodes - 1, 5);
      this.pending.WriteBits(blTreeCodes - 4, 4);
      for (int index = 0; index < blTreeCodes; ++index)
        this.pending.WriteBits((int) this.blTree.length[DeflaterHuffman.BL_ORDER[index]], 3);
      this.literalTree.WriteTree(this.blTree);
      this.distTree.WriteTree(this.blTree);
    }

    public void CompressBlock()
    {
      for (int index = 0; index < this.last_lit; ++index)
      {
        int num1 = (int) this.l_buf[index] & (int) byte.MaxValue;
        int num2 = (int) this.d_buf[index];
        int distance = num2 - 1;
        if (num2 != 0)
        {
          int code1 = this.L_code(num1);
          this.literalTree.WriteSymbol(code1);
          int count1 = (code1 - 261) / 4;
          if (count1 > 0 && count1 <= 5)
            this.pending.WriteBits(num1 & (1 << count1) - 1, count1);
          int code2 = this.D_code(distance);
          this.distTree.WriteSymbol(code2);
          int count2 = code2 / 2 - 1;
          if (count2 > 0)
            this.pending.WriteBits(distance & (1 << count2) - 1, count2);
        }
        else
          this.literalTree.WriteSymbol(num1);
      }
      this.literalTree.WriteSymbol(DeflaterHuffman.EOF_SYMBOL);
    }

    public void FlushStoredBlock(byte[] stored, int stored_offset, int stored_len, bool lastBlock)
    {
      this.pending.WriteBits(lastBlock ? 1 : 0, 3);
      this.pending.AlignToByte();
      this.pending.WriteShort(stored_len);
      this.pending.WriteShort(~stored_len);
      this.pending.WriteBlock(stored, stored_offset, stored_len);
      this.Reset();
    }

    public void FlushBlock(byte[] stored, int stored_offset, int stored_len, bool lastBlock)
    {
      short[] freqs;
      IntPtr eofSymbol;
      (freqs = this.literalTree.freqs)[(int) (eofSymbol = (IntPtr) DeflaterHuffman.EOF_SYMBOL)] = (short) ((int) freqs[eofSymbol] + 1);
      this.literalTree.BuildTree();
      this.distTree.BuildTree();
      this.literalTree.CalcBLFreq(this.blTree);
      this.distTree.CalcBLFreq(this.blTree);
      this.blTree.BuildTree();
      int blTreeCodes = 4;
      for (int index = 18; index > blTreeCodes; --index)
      {
        if (this.blTree.length[DeflaterHuffman.BL_ORDER[index]] > (byte) 0)
          blTreeCodes = index + 1;
      }
      int num = 14 + blTreeCodes * 3 + this.blTree.GetEncodedLength() + this.literalTree.GetEncodedLength() + this.distTree.GetEncodedLength() + this.extra_bits;
      int extraBits = this.extra_bits;
      for (int index = 0; index < DeflaterHuffman.LITERAL_NUM; ++index)
        extraBits += (int) this.literalTree.freqs[index] * (int) DeflaterHuffman.staticLLength[index];
      for (int index = 0; index < DeflaterHuffman.DIST_NUM; ++index)
        extraBits += (int) this.distTree.freqs[index] * (int) DeflaterHuffman.staticDLength[index];
      if (num >= extraBits)
        num = extraBits;
      if (stored_offset >= 0 && stored_len + 4 < num >> 3)
        this.FlushStoredBlock(stored, stored_offset, stored_len, lastBlock);
      else if (num == extraBits)
      {
        this.pending.WriteBits(2 + (lastBlock ? 1 : 0), 3);
        this.literalTree.SetStaticCodes(DeflaterHuffman.staticLCodes, DeflaterHuffman.staticLLength);
        this.distTree.SetStaticCodes(DeflaterHuffman.staticDCodes, DeflaterHuffman.staticDLength);
        this.CompressBlock();
        this.Reset();
      }
      else
      {
        this.pending.WriteBits(4 + (lastBlock ? 1 : 0), 3);
        this.SendAllTrees(blTreeCodes);
        this.CompressBlock();
        this.Reset();
      }
    }

    public bool IsFull() => this.last_lit + 16 >= DeflaterHuffman.BUFSIZE;

    public bool TallyLit(int lit)
    {
      this.d_buf[this.last_lit] = (short) 0;
      this.l_buf[this.last_lit++] = (byte) lit;
      short[] freqs;
      IntPtr index;
      (freqs = this.literalTree.freqs)[(int) (index = (IntPtr) lit)] = (short) ((int) freqs[index] + 1);
      return this.IsFull();
    }

    public bool TallyDist(int dist, int len)
    {
      this.d_buf[this.last_lit] = (short) dist;
      this.l_buf[this.last_lit++] = (byte) (len - 3);
      int num1 = this.L_code(len - 3);
      short[] freqs1;
      IntPtr index1;
      (freqs1 = this.literalTree.freqs)[(int) (index1 = (IntPtr) num1)] = (short) ((int) freqs1[index1] + 1);
      if (num1 >= 265 && num1 < 285)
        this.extra_bits += (num1 - 261) / 4;
      int num2 = this.D_code(dist - 1);
      short[] freqs2;
      IntPtr index2;
      (freqs2 = this.distTree.freqs)[(int) (index2 = (IntPtr) num2)] = (short) ((int) freqs2[index2] + 1);
      if (num2 >= 4)
        this.extra_bits += num2 / 2 - 1;
      return this.IsFull();
    }

    public class Tree
    {
      public short[] freqs;
      public short[] codes;
      public byte[] length;
      public int[] bl_counts;
      public int minNumCodes;
      public int numCodes;
      public int maxLength;
      private DeflaterHuffman dh;

      public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
      {
        this.dh = dh;
        this.minNumCodes = minCodes;
        this.maxLength = maxLength;
        this.freqs = new short[(int) checked ((uint) elems)];
        this.bl_counts = new int[(int) checked ((uint) maxLength)];
      }

      public void Reset()
      {
        for (int index = 0; index < this.freqs.Length; ++index)
          this.freqs[index] = (short) 0;
        this.codes = (short[]) null;
        this.length = (byte[]) null;
      }

      public void WriteSymbol(int code) => this.dh.pending.WriteBits((int) this.codes[code] & (int) ushort.MaxValue, (int) this.length[code]);

      public void CheckEmpty()
      {
        bool flag = true;
        for (int index = 0; index < this.freqs.Length; ++index)
        {
          if (this.freqs[index] != (short) 0)
            flag = false;
        }
        if (!flag)
          throw new Exception();
      }

      public void SetStaticCodes(short[] stCodes, byte[] stLength)
      {
        this.codes = stCodes;
        this.length = stLength;
      }

      public void BuildCodes()
      {
        int length = this.freqs.Length;
        int[] numArray = new int[(int) checked ((uint) this.maxLength)];
        int num1 = 0;
        this.codes = new short[(int) checked ((uint) this.freqs.Length)];
        for (int index = 0; index < this.maxLength; ++index)
        {
          numArray[index] = num1;
          num1 += this.bl_counts[index] << 15 - index;
        }
        for (int index = 0; index < this.numCodes; ++index)
        {
          int num2 = (int) this.length[index];
          if (num2 > 0)
          {
            this.codes[index] = DeflaterHuffman.BitReverse(numArray[num2 - 1]);
            numArray[num2 - 1] += 1 << 16 - num2;
          }
        }
      }

      private void BuildLength(int[] childs)
      {
        this.length = new byte[(int) checked ((uint) this.freqs.Length)];
        int length = childs.Length / 2;
        int num1 = (length + 1) / 2;
        int num2 = 0;
        for (int index = 0; index < this.maxLength; ++index)
          this.bl_counts[index] = 0;
        int[] numArray1 = new int[(int) checked ((uint) length)];
        numArray1[length - 1] = 0;
        for (int index = length - 1; index >= 0; --index)
        {
          if (childs[2 * index + 1] != -1)
          {
            int num3 = numArray1[index] + 1;
            if (num3 > this.maxLength)
            {
              num3 = this.maxLength;
              ++num2;
            }
            numArray1[childs[2 * index]] = numArray1[childs[2 * index + 1]] = num3;
          }
          else
          {
            ++this.bl_counts[numArray1[index] - 1];
            this.length[childs[2 * index]] = (byte) numArray1[index];
          }
        }
        if (num2 == 0)
          return;
        int index1 = this.maxLength - 1;
        do
        {
          do
            ;
          while (this.bl_counts[--index1] == 0);
          do
          {
            --this.bl_counts[index1];
            int[] blCounts;
            int[] numArray2 = blCounts = this.bl_counts;
            int index2;
            index1 = index2 = index1 + 1;
            int index3 = index2;
            int num4 = numArray2[(IntPtr) index3] + 1;
            blCounts[index2] = num4;
            num2 -= 1 << this.maxLength - 1 - index1;
          }
          while (num2 > 0 && index1 < this.maxLength - 1);
        }
        while (num2 > 0);
        this.bl_counts[this.maxLength - 1] += num2;
        this.bl_counts[this.maxLength - 2] -= num2;
        int num5 = 2 * num1;
        for (int maxLength = this.maxLength; maxLength != 0; --maxLength)
        {
          int blCount = this.bl_counts[maxLength - 1];
          while (blCount > 0)
          {
            int index4 = 2 * childs[num5++];
            if (childs[index4 + 1] == -1)
            {
              this.length[childs[index4]] = (byte) maxLength;
              --blCount;
            }
          }
        }
      }

      public void BuildTree()
      {
        int length = this.freqs.Length;
        int[] numArray1 = new int[(int) checked ((uint) length)];
        int num1 = 0;
        int num2 = 0;
        for (int index1 = 0; index1 < length; ++index1)
        {
          int freq = (int) this.freqs[index1];
          if (freq != 0)
          {
            int index2;
            int index3;
            for (index2 = num1++; index2 > 0 && (int) this.freqs[numArray1[index3 = (index2 - 1) / 2]] > freq; index2 = index3)
              numArray1[index2] = numArray1[index3];
            numArray1[index2] = index1;
            num2 = index1;
          }
        }
        int num3;
        for (; num1 < 2; numArray1[num1++] = num3)
        {
          int num4;
          if (num2 >= 2)
            num4 = 0;
          else
            num2 = num4 = num2 + 1;
          num3 = num4;
        }
        this.numCodes = Math.Max(num2 + 1, this.minNumCodes);
        int num5 = num1;
        int[] childs = new int[(int) checked ((uint) unchecked (4 * num1 - 2))];
        int[] numArray2 = new int[(int) checked ((uint) unchecked (2 * num1 - 1))];
        int num6 = num5;
        for (int index4 = 0; index4 < num1; ++index4)
        {
          int index5 = numArray1[index4];
          childs[2 * index4] = index5;
          childs[2 * index4 + 1] = -1;
          numArray2[index4] = (int) this.freqs[index5] << 8;
          numArray1[index4] = index4;
        }
        do
        {
          int index6 = numArray1[0];
          int index7 = numArray1[--num1];
          int index8 = 0;
          for (int index9 = 1; index9 < num1; index9 = index9 * 2 + 1)
          {
            if (index9 + 1 < num1 && numArray2[numArray1[index9]] > numArray2[numArray1[index9 + 1]])
              ++index9;
            numArray1[index8] = numArray1[index9];
            index8 = index9;
          }
          int num7 = numArray2[index7];
          int index10;
          while ((index10 = index8) > 0 && numArray2[numArray1[index8 = (index10 - 1) / 2]] > num7)
            numArray1[index10] = numArray1[index8];
          numArray1[index10] = index7;
          int index11 = numArray1[0];
          int index12 = num6++;
          childs[2 * index12] = index6;
          childs[2 * index12 + 1] = index11;
          int num8 = Math.Min(numArray2[index6] & (int) byte.MaxValue, numArray2[index11] & (int) byte.MaxValue);
          int num9;
          numArray2[index12] = num9 = numArray2[index6] + numArray2[index11] - num8 + 1;
          int index13 = 0;
          for (int index14 = 1; index14 < num1; index14 = index13 * 2 + 1)
          {
            if (index14 + 1 < num1 && numArray2[numArray1[index14]] > numArray2[numArray1[index14 + 1]])
              ++index14;
            numArray1[index13] = numArray1[index14];
            index13 = index14;
          }
          int index15;
          while ((index15 = index13) > 0 && numArray2[numArray1[index13 = (index15 - 1) / 2]] > num9)
            numArray1[index15] = numArray1[index13];
          numArray1[index15] = index12;
        }
        while (num1 > 1);
        if (numArray1[0] != childs.Length / 2 - 1)
          throw new Exception("Weird!");
        this.BuildLength(childs);
      }

      public int GetEncodedLength()
      {
        int encodedLength = 0;
        for (int index = 0; index < this.freqs.Length; ++index)
          encodedLength += (int) this.freqs[index] * (int) this.length[index];
        return encodedLength;
      }

      public void CalcBLFreq(DeflaterHuffman.Tree blTree)
      {
        int num1 = -1;
        int index1 = 0;
        while (index1 < this.numCodes)
        {
          int num2 = 1;
          int num3 = (int) this.length[index1];
          int num4;
          int num5;
          if (num3 == 0)
          {
            num4 = 138;
            num5 = 3;
          }
          else
          {
            num4 = 6;
            num5 = 3;
            if (num1 != num3)
            {
              short[] freqs;
              IntPtr index2;
              (freqs = blTree.freqs)[(int) (index2 = (IntPtr) num3)] = (short) ((int) freqs[index2] + 1);
              num2 = 0;
            }
          }
          num1 = num3;
          ++index1;
          while (index1 < this.numCodes && num1 == (int) this.length[index1])
          {
            ++index1;
            if (++num2 >= num4)
              break;
          }
          if (num2 < num5)
          {
            short[] freqs;
            IntPtr index3;
            (freqs = blTree.freqs)[(int) (index3 = (IntPtr) num1)] = (short) ((int) freqs[index3] + (int) (short) num2);
          }
          else if (num1 != 0)
          {
            short[] freqs;
            IntPtr rep36;
            (freqs = blTree.freqs)[(int) (rep36 = (IntPtr) DeflaterHuffman.REP_3_6)] = (short) ((int) freqs[rep36] + 1);
          }
          else if (num2 <= 10)
          {
            short[] freqs;
            IntPtr rep310;
            (freqs = blTree.freqs)[(int) (rep310 = (IntPtr) DeflaterHuffman.REP_3_10)] = (short) ((int) freqs[rep310] + 1);
          }
          else
          {
            short[] freqs;
            IntPtr rep11138;
            (freqs = blTree.freqs)[(int) (rep11138 = (IntPtr) DeflaterHuffman.REP_11_138)] = (short) ((int) freqs[rep11138] + 1);
          }
        }
      }

      public void WriteTree(DeflaterHuffman.Tree blTree)
      {
        int code1 = -1;
        int index = 0;
        while (index < this.numCodes)
        {
          int num1 = 1;
          int code2 = (int) this.length[index];
          int num2;
          int num3;
          if (code2 == 0)
          {
            num2 = 138;
            num3 = 3;
          }
          else
          {
            num2 = 6;
            num3 = 3;
            if (code1 != code2)
            {
              blTree.WriteSymbol(code2);
              num1 = 0;
            }
          }
          code1 = code2;
          ++index;
          while (index < this.numCodes && code1 == (int) this.length[index])
          {
            ++index;
            if (++num1 >= num2)
              break;
          }
          if (num1 < num3)
          {
            while (num1-- > 0)
              blTree.WriteSymbol(code1);
          }
          else if (code1 != 0)
          {
            blTree.WriteSymbol(DeflaterHuffman.REP_3_6);
            this.dh.pending.WriteBits(num1 - 3, 2);
          }
          else if (num1 <= 10)
          {
            blTree.WriteSymbol(DeflaterHuffman.REP_3_10);
            this.dh.pending.WriteBits(num1 - 3, 3);
          }
          else
          {
            blTree.WriteSymbol(DeflaterHuffman.REP_11_138);
            this.dh.pending.WriteBits(num1 - 11, 7);
          }
        }
      }
    }
  }
}
