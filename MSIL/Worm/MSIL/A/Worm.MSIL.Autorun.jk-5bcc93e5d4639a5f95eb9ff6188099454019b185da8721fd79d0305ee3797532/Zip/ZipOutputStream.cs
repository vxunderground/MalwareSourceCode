// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.ZipOutputStream
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using ICSharpCode.SharpZipLib.Checksums;
using ICSharpCode.SharpZipLib.Zip.Compression;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;
using System.Collections;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class ZipOutputStream : DeflaterOutputStream
  {
    private const int ZIP_STORED_VERSION = 10;
    private const int ZIP_DEFLATED_VERSION = 20;
    public const int STORED = 0;
    public const int DEFLATED = 8;
    private ArrayList entries = new ArrayList();
    private Crc32 crc = new Crc32();
    private ZipEntry curEntry = (ZipEntry) null;
    private CompressionMethod curMethod;
    private int size;
    private int offset = 0;
    private byte[] zipComment = new byte[0];
    private int defaultMethod = 8;
    private bool shouldWriteBack = false;
    private long seekPos = -1;

    public ZipOutputStream(Stream baseOutputStream)
      : base(baseOutputStream, new Deflater(Deflater.DEFAULT_COMPRESSION, true))
    {
    }

    public void SetComment(string comment)
    {
      byte[] array = ZipConstants.ConvertToArray(comment);
      this.zipComment = array.Length <= (int) ushort.MaxValue ? array : throw new ArgumentException("Comment too long.");
    }

    public void SetMethod(int method) => this.defaultMethod = method == 0 || method == 8 ? method : throw new ArgumentException("Method not supported.");

    public void SetLevel(int level) => this.def.SetLevel(level);

    private void WriteLeShort(int value)
    {
      this.baseOutputStream.WriteByte((byte) value);
      this.baseOutputStream.WriteByte((byte) (value >> 8));
    }

    private void WriteLeInt(int value)
    {
      this.WriteLeShort(value);
      this.WriteLeShort(value >> 16);
    }

    private void WriteLeLong(long value)
    {
      this.WriteLeInt((int) value);
      this.WriteLeInt((int) (value >> 32));
    }

    public void PutNextEntry(ZipEntry entry)
    {
      if (this.entries == null)
        throw new InvalidOperationException("ZipOutputStream was finished");
      CompressionMethod compressionMethod = entry.CompressionMethod;
      int num = 0;
      switch (compressionMethod)
      {
        case CompressionMethod.Stored:
          if (entry.CompressedSize >= 0L)
          {
            if (entry.Size < 0L)
              entry.Size = entry.CompressedSize;
            else if (entry.Size != entry.CompressedSize)
              throw new ZipException("Method STORED, but compressed size != size");
          }
          else
            entry.CompressedSize = entry.Size;
          if (entry.Size < 0L)
            throw new ZipException("Method STORED, but size not set");
          if (entry.Crc < 0L)
            throw new ZipException("Method STORED, but crc not set");
          break;
        case CompressionMethod.Deflated:
          if (entry.CompressedSize < 0L || entry.Size < 0L || entry.Crc < 0L)
          {
            num |= 8;
            break;
          }
          break;
      }
      if (this.curEntry != null)
        this.CloseEntry();
      entry.flags = num;
      entry.offset = this.offset;
      entry.CompressionMethod = compressionMethod;
      this.curMethod = compressionMethod;
      this.WriteLeInt(67324752);
      this.WriteLeShort(compressionMethod == CompressionMethod.Stored ? 10 : 20);
      if ((num & 8) == 0)
      {
        this.WriteLeShort(num);
        this.WriteLeShort((int) (byte) compressionMethod);
        this.WriteLeInt((int) entry.DosTime);
        this.WriteLeInt((int) entry.Crc);
        this.WriteLeInt((int) entry.CompressedSize);
        this.WriteLeInt((int) entry.Size);
      }
      else
      {
        if (this.baseOutputStream.CanSeek)
        {
          this.shouldWriteBack = true;
          this.WriteLeShort((int) (short) (num & -9));
        }
        else
        {
          this.shouldWriteBack = false;
          this.WriteLeShort(num);
        }
        this.WriteLeShort((int) (byte) compressionMethod);
        this.WriteLeInt((int) entry.DosTime);
        this.seekPos = this.baseOutputStream.Position;
        this.WriteLeInt(0);
        this.WriteLeInt(0);
        this.WriteLeInt(0);
      }
      byte[] array = ZipConstants.ConvertToArray(entry.Name);
      if (array.Length > (int) ushort.MaxValue)
        throw new ZipException("Name too long.");
      byte[] buffer = entry.ExtraData ?? new byte[0];
      if (buffer.Length > (int) ushort.MaxValue)
        throw new ZipException("Extra data too long.");
      this.WriteLeShort(array.Length);
      this.WriteLeShort(buffer.Length);
      this.baseOutputStream.Write(array, 0, array.Length);
      this.baseOutputStream.Write(buffer, 0, buffer.Length);
      this.offset += 30 + array.Length + buffer.Length;
      this.curEntry = entry;
      this.crc.Reset();
      if (compressionMethod == CompressionMethod.Deflated)
        this.def.Reset();
      this.size = 0;
    }

    public void CloseEntry()
    {
      if (this.curEntry == null)
        throw new InvalidOperationException("No open entry");
      if (this.curMethod == CompressionMethod.Deflated)
        base.Finish();
      int num = this.curMethod == CompressionMethod.Deflated ? this.def.TotalOut : this.size;
      if (this.curEntry.Size < 0L)
        this.curEntry.Size = (long) this.size;
      else if (this.curEntry.Size != (long) this.size)
        throw new ZipException("size was " + (object) this.size + ", but I expected " + (object) this.curEntry.Size);
      if (this.curEntry.CompressedSize < 0L)
        this.curEntry.CompressedSize = (long) num;
      else if (this.curEntry.CompressedSize != (long) num)
        throw new ZipException("compressed size was " + (object) num + ", but I expected " + (object) this.curEntry.CompressedSize);
      if (this.curEntry.Crc < 0L)
        this.curEntry.Crc = this.crc.Value;
      else if (this.curEntry.Crc != this.crc.Value)
        throw new ZipException("crc was " + (object) this.crc.Value + ", but I expected " + (object) this.curEntry.Crc);
      this.offset += num;
      if (this.curMethod == CompressionMethod.Deflated && (this.curEntry.flags & 8) != 0)
      {
        if (this.shouldWriteBack)
        {
          this.curEntry.flags &= -9;
          long position = this.baseOutputStream.Position;
          this.baseOutputStream.Seek(this.seekPos, SeekOrigin.Begin);
          this.WriteLeInt((int) this.curEntry.Crc);
          this.WriteLeInt((int) this.curEntry.CompressedSize);
          this.WriteLeInt((int) this.curEntry.Size);
          this.baseOutputStream.Seek(position, SeekOrigin.Begin);
          this.shouldWriteBack = false;
        }
        else
        {
          this.WriteLeInt(134695760);
          this.WriteLeInt((int) this.curEntry.Crc);
          this.WriteLeInt((int) this.curEntry.CompressedSize);
          this.WriteLeInt((int) this.curEntry.Size);
          this.offset += 16;
        }
      }
      this.entries.Add((object) this.curEntry);
      this.curEntry = (ZipEntry) null;
    }

    public override void Write(byte[] b, int off, int len)
    {
      if (this.curEntry == null)
        throw new InvalidOperationException("No open entry.");
      switch (this.curMethod)
      {
        case CompressionMethod.Stored:
          this.baseOutputStream.Write(b, off, len);
          break;
        case CompressionMethod.Deflated:
          base.Write(b, off, len);
          break;
      }
      this.crc.Update(b, off, len);
      this.size += len;
    }

    public override void Finish()
    {
      if (this.entries == null)
        return;
      if (this.curEntry != null)
        this.CloseEntry();
      int num1 = 0;
      int num2 = 0;
      foreach (ZipEntry entry in this.entries)
      {
        CompressionMethod compressionMethod = entry.CompressionMethod;
        this.WriteLeInt(33639248);
        this.WriteLeShort(compressionMethod == CompressionMethod.Stored ? 10 : 20);
        this.WriteLeShort(compressionMethod == CompressionMethod.Stored ? 10 : 20);
        if (entry.IsCrypted)
          entry.flags |= 1;
        this.WriteLeShort(entry.flags);
        this.WriteLeShort((int) (short) compressionMethod);
        this.WriteLeInt((int) entry.DosTime);
        this.WriteLeInt((int) entry.Crc);
        this.WriteLeInt((int) entry.CompressedSize);
        this.WriteLeInt((int) entry.Size);
        byte[] array = ZipConstants.ConvertToArray(entry.Name);
        if (array.Length > (int) ushort.MaxValue)
          throw new ZipException("Name too long.");
        byte[] buffer1 = entry.ExtraData ?? new byte[0];
        string comment = entry.Comment;
        byte[] buffer2 = comment != null ? ZipConstants.ConvertToArray(comment) : new byte[0];
        if (buffer2.Length > (int) ushort.MaxValue)
          throw new ZipException("Comment too long.");
        this.WriteLeShort(array.Length);
        this.WriteLeShort(buffer1.Length);
        this.WriteLeShort(buffer2.Length);
        this.WriteLeShort(0);
        this.WriteLeShort(0);
        this.WriteLeInt(0);
        this.WriteLeInt(entry.offset);
        this.baseOutputStream.Write(array, 0, array.Length);
        this.baseOutputStream.Write(buffer1, 0, buffer1.Length);
        this.baseOutputStream.Write(buffer2, 0, buffer2.Length);
        ++num1;
        num2 += 46 + array.Length + buffer1.Length + buffer2.Length;
      }
      this.WriteLeInt(101010256);
      this.WriteLeShort(0);
      this.WriteLeShort(0);
      this.WriteLeShort(num1);
      this.WriteLeShort(num1);
      this.WriteLeInt(num2);
      this.WriteLeInt(this.offset);
      this.WriteLeShort(this.zipComment.Length);
      this.baseOutputStream.Write(this.zipComment, 0, this.zipComment.Length);
      this.baseOutputStream.Flush();
      this.entries = (ArrayList) null;
    }
  }
}
