// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.ZipEntry
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class ZipEntry : ICloneable
  {
    private static int KNOWN_SIZE = 1;
    private static int KNOWN_CSIZE = 2;
    private static int KNOWN_CRC = 4;
    private static int KNOWN_TIME = 8;
    private string name;
    private uint size;
    private ushort version;
    private uint compressedSize;
    private uint crc;
    private uint dosTime;
    private ushort known = 0;
    private CompressionMethod method = CompressionMethod.Deflated;
    private byte[] extra = (byte[]) null;
    private string comment = (string) null;
    private bool isCrypted;
    public int zipFileIndex = -1;
    public int flags;
    public int offset;

    public ZipEntry(string name)
    {
      if (name == null)
        throw new ArgumentNullException(nameof (name));
      this.DateTime = DateTime.Now;
      this.name = name;
    }

    public ZipEntry(ZipEntry e)
    {
      this.name = e.name;
      this.known = e.known;
      this.size = e.size;
      this.compressedSize = e.compressedSize;
      this.crc = e.crc;
      this.dosTime = e.dosTime;
      this.method = e.method;
      this.extra = e.extra;
      this.comment = e.comment;
    }

    public ushort Version
    {
      get => this.version;
      set => this.version = value;
    }

    public uint DosTime
    {
      get => ((int) this.known & ZipEntry.KNOWN_TIME) == 0 ? 0U : this.dosTime;
      set
      {
        this.dosTime = value;
        this.known |= (ushort) ZipEntry.KNOWN_TIME;
      }
    }

    public DateTime DateTime
    {
      get => new DateTime(((int) (this.dosTime >> 25) & (int) sbyte.MaxValue) + 1980, (int) (this.dosTime >> 21 & 15U), (int) (this.dosTime >> 16 & 31U), (int) (this.dosTime >> 11 & 31U), (int) (this.dosTime >> 5 & 63U), 2 * ((int) this.dosTime & 31));
      set => this.DosTime = (uint) ((value.Year - 1980 & (int) sbyte.MaxValue) << 25 | value.Month << 21 | value.Day << 16 | value.Hour << 11 | value.Minute << 5) | (uint) value.Second >> 1;
    }

    public string Name => this.name;

    public long Size
    {
      get => ((int) this.known & ZipEntry.KNOWN_SIZE) != 0 ? (long) this.size : -1L;
      set
      {
        this.size = (value & -4294967296L) == 0L ? (uint) value : throw new ArgumentOutOfRangeException("size");
        this.known |= (ushort) ZipEntry.KNOWN_SIZE;
      }
    }

    public long CompressedSize
    {
      get => ((int) this.known & ZipEntry.KNOWN_CSIZE) != 0 ? (long) this.compressedSize : -1L;
      set
      {
        this.compressedSize = (value & -4294967296L) == 0L ? (uint) value : throw new ArgumentOutOfRangeException();
        this.known |= (ushort) ZipEntry.KNOWN_CSIZE;
      }
    }

    public long Crc
    {
      get => ((int) this.known & ZipEntry.KNOWN_CRC) != 0 ? (long) this.crc & (long) uint.MaxValue : -1L;
      set
      {
        this.crc = ((long) this.crc & -4294967296L) == 0L ? (uint) value : throw new Exception();
        this.known |= (ushort) ZipEntry.KNOWN_CRC;
      }
    }

    public CompressionMethod CompressionMethod
    {
      get => this.method;
      set => this.method = value;
    }

    public byte[] ExtraData
    {
      get => this.extra;
      set
      {
        if (value == null)
        {
          this.extra = (byte[]) null;
        }
        else
        {
          this.extra = value.Length <= (int) ushort.MaxValue ? value : throw new ArgumentOutOfRangeException();
          try
          {
            int index1;
            int num1;
            for (int index2 = 0; index2 < this.extra.Length; index2 = index1 + num1)
            {
              byte[] extra1 = this.extra;
              int index3 = index2;
              int num2 = index3 + 1;
              int num3 = (int) extra1[index3] & (int) byte.MaxValue;
              byte[] extra2 = this.extra;
              int index4 = num2;
              int num4 = index4 + 1;
              int num5 = ((int) extra2[index4] & (int) byte.MaxValue) << 8;
              int num6 = num3 | num5;
              byte[] extra3 = this.extra;
              int index5 = num4;
              int num7 = index5 + 1;
              int num8 = (int) extra3[index5] & (int) byte.MaxValue;
              byte[] extra4 = this.extra;
              int index6 = num7;
              index1 = index6 + 1;
              int num9 = ((int) extra4[index6] & (int) byte.MaxValue) << 8;
              num1 = num8 | num9;
              if (num6 == 21589 && ((int) this.extra[index1] & 1) != 0)
              {
                this.DateTime = (new DateTime(1970, 1, 1, 0, 0, 0) + new TimeSpan(0, 0, 0, (int) this.extra[index1 + 1] & (int) byte.MaxValue | ((int) this.extra[index1 + 2] & (int) byte.MaxValue) << 8 | ((int) this.extra[index1 + 3] & (int) byte.MaxValue) << 16 | ((int) this.extra[index1 + 4] & (int) byte.MaxValue) << 24, 0)).ToLocalTime();
                this.known |= (ushort) ZipEntry.KNOWN_TIME;
              }
            }
          }
          catch (Exception ex)
          {
          }
        }
      }
    }

    public string Comment
    {
      get => this.comment;
      set => this.comment = value.Length <= (int) ushort.MaxValue ? value : throw new ArgumentOutOfRangeException();
    }

    public bool IsDirectory
    {
      get
      {
        int length = this.name.Length;
        return length > 0 && this.name[length - 1] == '/';
      }
    }

    public bool IsCrypted
    {
      get => this.isCrypted;
      set => this.isCrypted = value;
    }

    public object Clone() => this.MemberwiseClone();

    public override string ToString() => this.name;
  }
}
