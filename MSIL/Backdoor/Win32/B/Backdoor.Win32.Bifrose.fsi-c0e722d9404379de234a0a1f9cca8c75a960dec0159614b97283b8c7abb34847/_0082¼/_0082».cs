// Decompiled with JetBrains decompiler
// Type: ¼.»
// Assembly: Cursor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BB91517D-96CD-4859-A72C-BFC1CBA44DE2
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Backdoor.Win32.Bifrose.fsi-c0e722d9404379de234a0a1f9cca8c75a960dec0159614b97283b8c7abb34847.exe

using \u0082\u00BC;
using å;
using õ;
using PvLogiciels.dotNetProtector;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

namespace \u0082\u00BC
{
  internal class \u0082\u00BB
  {
    internal static \u00BF \u00BC;
    [FixedAddressValueType]
    internal static int \u00B8;
    internal static __FnPtr<void ()> \u009F;
    internal static \u00BF \u0087;
    [FixedAddressValueType]
    internal static \u00AE.\u00A9 \u0081ç;
    internal static __FnPtr<void ()> \u0082\u00A3;
    [FixedAddressValueType]
    internal static bool \u0082\u0080;
    internal static __FnPtr<void ()> \u0081ë;
    internal static \u00BF \u0081Ë;
    [FixedAddressValueType]
    internal static \u00AE.\u00A9 \u0081Æ;
    internal static __FnPtr<void ()> \u0081\u00AE;
    [FixedAddressValueType]
    internal static int \u0081\u0096;
    internal static __FnPtr<void ()> \u0081\u0087;
    internal static \u00BF ð;
    [FixedAddressValueType]
    internal static \u00AE.\u00A9 ê;
    internal static __FnPtr<void ()> \u0082\u00B1;
    internal static \u00BF \u00B2;
    [FixedAddressValueType]
    internal static \u00AE.\u00A9 \u00A7;
    internal static __FnPtr<void ()> \u008F;
    internal static bool \u0081Ì;
    internal static bool \u0082\u009B;
    internal static bool \u0082\u0089;
    internal static int \u0081ó;
    internal static uint \u0081à;
    internal static uint \u0081Ð;
    internal static \u008E.\u00A9 \u0081Á;
    internal static uint \u0082µ;
    internal static uint \u0081\u009E;
    internal static uint \u0081\u0092;
    internal static \u008E.\u00A9 \u0081\u0082;
    internal static bool ï;
    internal static \u00BF \u00D7;
    public static unsafe int** Ð;
    public static unsafe int** \u00BD;
    internal static __FnPtr<int ()> \u009E;
    [FixedAddressValueType]
    internal static uint \u0097;
    [FixedAddressValueType]
    internal static \u0082\u0098 \u0091;
    internal static __FnPtr<void ()> \u0082\u00B7;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0082\u009F;
    internal static uint \u0082\u0097;
    internal static unsafe __FnPtr<void ()>* \u0082\u008D;
    internal static unsafe __FnPtr<void ()>* \u0082\u0085;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0081ü;
    internal static int \u0081ô;
    internal static int \u0081ñ;
    internal static int \u0081í;
    internal static int \u0081å;
    internal static int \u0081ß;
    internal static int \u0024;
    internal static int \u0081Ú;
    public static \u00A6 \u0081Ã;
    public static volatile uint æ;
    public static \u00A6 ß;
    public static \u0099 Ú;
    public static volatile \u0094 \u0081\u00B6;
    public static \u0099 \u0081\u00B1;
    public static unsafe void* \u0081\u00AD;
    public static volatile uint \u0081\u00A8;
    public static unsafe __FnPtr<void ()>* \u0081\u00A2;
    public static unsafe __FnPtr<void ()>* \u0081\u009F;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Ë() => \u0082\u00BB.\u0081\u00A8 != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool À() => \u0082\u00BB.\u0081\u00A8 == 1U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00AF() => \u0082\u00BB.\u0081\u00A8 == 0U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u009B() => \u0082\u00BB.æ != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0090() => (\u0082\u00BB.\u0081\u00A8 != uint.MaxValue ? 1 : 0) == 0 || (\u0082\u00BB.æ != uint.MaxValue ? 1 : 0) != 0 || \u0082\u00BB.\u0081\u00A8 != 1U && \u0082\u00BB.\u0081\u00A8 != 0U;

    internal static unsafe int \u0081(void* _param0)
    {
      GC.KeepAlive((object) int.MaxValue);
      return 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082ª()
    {
      if (\u0082\u00BB.\u0081\u0082 != (\u008E.\u00A9) 2)
        return \u0082\u00BB.\u0081\u0082 == (\u008E.\u00A9) -1;
      void** voidPtr = (void**) &\u0082\u00BB.\u00D7;
      if (ref \u0082\u00BB.\u00D7 < ref \u0082\u00BB.\u00BC)
      {
        while (*(int*) voidPtr == 0)
        {
          voidPtr += 4;
          if ((IntPtr) voidPtr >= ref \u0082\u00BB.\u00BC)
            goto label_5;
        }
        \u0082\u00BB.\u0081\u0082 = (\u008E.\u00A9) -1;
        return true;
      }
label_5:
      \u0082\u00BB.\u0081\u0082 = (\u008E.\u00A9) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081Ó()
    {
      if (\u0082\u00BB.\u0081Á != (\u008E.\u00A9) 2)
        return \u0082\u00BB.\u0081Á == (\u008E.\u00A9) -1;
      void** voidPtr1 = (void**) &\u0082\u00BB.Ú;
      if (ref \u0082\u00BB.Ú < ref \u0082\u00BB.\u0081\u00B1)
      {
        while (*(int*) voidPtr1 == 0)
        {
          voidPtr1 += 4;
          if ((IntPtr) voidPtr1 >= ref \u0082\u00BB.\u0081\u00B1)
            goto label_5;
        }
        \u0082\u00BB.\u0081Á = (\u008E.\u00A9) -1;
        return true;
      }
label_5:
      void** voidPtr2 = (void**) &\u0082\u00BB.ß;
      if (ref \u0082\u00BB.ß < ref \u0082\u00BB.\u0081Ã)
      {
        while (*(int*) voidPtr2 == 0)
        {
          voidPtr2 += 4;
          if ((IntPtr) voidPtr2 >= ref \u0082\u00BB.\u0081Ã)
            goto label_9;
        }
        \u0082\u00BB.\u0081Á = (\u008E.\u00A9) -1;
        return true;
      }
label_9:
      \u0082\u00BB.\u0081Á = (\u008E.\u00A9) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082\u008C() => \u0082\u00BB.\u0082ª() && !\u0082\u00BB.\u0081Ì || \u0082\u00BB.\u0081Ó() && !\u0082\u00BB.\u0082\u0089 && \u0082\u00BB.\u0081\u00B6 == (\u0094) 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00F7() => \u0082\u00BB.\u0082\u009B;

    internal static unsafe void \u0081á() => \u0082\u00BB.ö((__FnPtr<int (void*)>) (IntPtr) \u0082\u00BB.Ð, (void*) 0);

    internal static void \u0081Ò() => \u0082\u00BB.\u0081\u0096 = 0;

    internal static void \u0081\u00BB() => \u0082\u00BB.\u00B8 = 0;

    internal static void \u0081\u00A3() => \u0082\u00BB.\u0082\u0080 = false;

    internal static void \u0081\u008E() => \u0082\u00BB.ê = (\u00AE.\u00A9) 0;

    internal static void \u00A2() => \u0082\u00BB.\u0081Æ = (\u00AE.\u00A9) 0;

    internal static void \u00A5() => \u0082\u00BB.\u00A7 = (\u00AE.\u00A9) 0;

    internal static void \u00AC() => \u0082\u00BB.\u0081ç = (\u00AE.\u00A9) 0;

    [DebuggerStepThrough]
    internal static unsafe void \u008C([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load during vtable initialization.\n");
      \u0082\u00BB.ê = (\u00AE.\u00A9) 1;
      \u0082\u00BB.\u0085((__FnPtr<void* ()>*) &\u0082\u00BB.\u0087, (__FnPtr<void* ()>*) &\u0082\u00BB.\u00B2);
      \u0082\u00BB.ê = (\u00AE.\u00A9) 2;
    }

    internal static unsafe void \u0082\u00B8([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
      \u0082\u00BB.\u0081á();
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u00A4([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load during native initialization.\n");
      \u0082\u00BB.\u0081\u00B7();
      \u0082\u00BB.\u0082\u0089 = true;
      if (!\u0082\u00BB.\u0090())
        \u0082\u00BB.\u0081º(33);
      switch (\u0082\u00BB.\u0081\u00B6)
      {
        case (\u0094) 0:
          \u0082\u00BB.\u0081Æ = (\u00AE.\u00A9) 1;
          \u0082\u00BB.\u0081\u00B6 = (\u0094) 1;
          if (\u0082\u00BB.\u0082\u009E((__FnPtr<int ()>*) &\u0082\u00BB.Ú, (__FnPtr<int ()>*) &\u0082\u00BB.\u0081\u00B1) != 0)
            \u0082\u00BB.\u00B9(\u0082\u00BB.\u009A((Ê*) obj0));
          \u0082\u00BB.\u0093((__FnPtr<void ()>*) &\u0082\u00BB.ß, (__FnPtr<void ()>*) &\u0082\u00BB.\u0081Ã);
          \u0082\u00BB.\u0081\u00B6 = (\u0094) 2;
          \u0082\u00BB.ï = true;
          \u0082\u00BB.\u0081Æ = (\u00AE.\u00A9) 2;
          break;
        case (\u0094) 1:
          \u0082\u00BB.\u0081º(33);
          break;
      }
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u008F([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load during process initialization.\n");
      \u0082\u00BB.\u00A7 = (\u00AE.\u00A9) 1;
      \u0082\u00BB.\u0081\u0094();
      \u0082\u00BB.\u0085((__FnPtr<void* ()>*) &\u0082\u00BB.\u00D7, (__FnPtr<void* ()>*) &\u0082\u00BB.\u00BC);
      \u0082\u00BB.\u00A7 = (\u00AE.\u00A9) 2;
      \u0082\u00BB.\u0081Ì = true;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0081û([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load during appdomain initialization.\n");
      \u0082\u00BB.\u0081ç = (\u00AE.\u00A9) 1;
      \u0082\u00BB.\u0081\u0089();
      \u0082\u00BB.\u0085((__FnPtr<void* ()>*) &\u0082\u00BB.\u0081Ë, (__FnPtr<void* ()>*) &\u0082\u00BB.ð);
      \u0082\u00BB.\u0081ç = (\u00AE.\u00A9) 2;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0081ä([In] Ñ* obj0)
    {
      \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load during registration for the unload events.\n");
      \u0082\u00BB.\u0081\u0085(new EventHandler(\u0082\u00BB.\u0081\u008F));
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    internal static unsafe void Ø([In] Ñ* obj0)
    {
      \u0082\u00BB.\u0082\u0080 = AppDomain.CurrentDomain.IsDefaultAppDomain();
      if (\u0082\u00BB.\u0082\u0080)
        \u0082\u00BB.\u0082\u009B = true;
      \u0082\u00BB.\u0081\u00A1();
      void* voidPtr1 = \u0082\u00BB.\u0081\u00BE();
      int num1 = 0;
      int num2 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        while (num2 == 0)
        {
          try
          {
          }
          finally
          {
            IntPtr comparand = (IntPtr) 0;
            IntPtr num3 = (IntPtr) voidPtr1;
            // ISSUE: cast to a reference type
            void* voidPtr2 = (void*) Interlocked.CompareExchange((IntPtr&) ref \u0082\u00BB.\u0081\u00AD, num3, comparand);
            if ((IntPtr) voidPtr2 == IntPtr.Zero)
              num2 = 1;
            else if (voidPtr2 == voidPtr1)
            {
              num1 = 1;
              num2 = 1;
            }
          }
          if (num2 == 0)
            \u0082\u00BB.\u0081\u00B2(1000U);
        }
        if (!\u0082\u00BB.\u0082\u0080)
        {
          if (\u0082\u00BB.\u0082\u008C())
            \u0082\u00BB.\u0082\u00B8(obj0);
        }
      }
      finally
      {
        if (num1 == 0)
        {
          IntPtr num4 = (IntPtr) 0;
          // ISSUE: cast to a reference type
          Interlocked.Exchange((IntPtr&) ref \u0082\u00BB.\u0081\u00AD, num4);
        }
      }
      \u0082\u00BB.\u008C(obj0);
      if (\u0082\u00BB.\u0082\u0080)
      {
        \u0082\u00BB.\u0082\u00A4(obj0);
        \u0082\u00BB.\u0082\u008F(obj0);
      }
      \u0082\u00BB.\u0081û(obj0);
      \u0082\u00BB.\u0081\u0096 = 1;
      \u0082\u00BB.\u0081ä(obj0);
    }

    internal static void \u0081À() => \u0082\u00BB.É();

    internal static unsafe int \u0081\u00AF(void* _param0)
    {
      \u0082\u00BB.\u0081\u0098();
      \u0082\u00BB.\u0081Ì = false;
      if (\u0082\u00BB.ï)
      {
        \u0082\u00BB.ì();
        \u0082\u00BB.\u0081\u00B6 = (\u0094) 0;
        \u0082\u00BB.ï = false;
      }
      \u0082\u00BB.\u0082\u0089 = false;
      return 0;
    }

    internal static unsafe void \u0081\u009D()
    {
      if (!\u0082\u00BB.\u0082\u009B)
        return;
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        \u0082\u00BB.\u0081\u00AF((void*) 0);
      }
      else
      {
        // ISSUE: cast to a function pointer type
        \u0082\u00BB.ö((__FnPtr<int (void*)>) (IntPtr) \u0082\u00BB.\u00BD, (void*) 0);
      }
    }

    [PrePrepareMethod]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static void \u0081\u008F(object _param0, EventArgs _param1)
    {
      if (\u0082\u00BB.\u0081\u0096 == 0 || Interlocked.Exchange(ref \u0082\u00BB.\u00B8, 1) != 0)
        return;
      int num = Interlocked.Decrement(ref \u0082\u00BB.\u0081ó) == 0 ? 1 : 0;
      \u0082\u00BB.É();
      if ((byte) num == (byte) 0)
        return;
      \u0082\u00BB.\u0081\u009D();
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void û([In] Ñ* obj0, Exception _param1)
    {
      try
      {
        bool flag = Interlocked.Decrement(ref \u0082\u00BB.\u0081ó) == 0;
        \u0082\u00BB.\u0081À();
        if (!flag)
          return;
        \u0082\u00BB.\u0081\u009D();
      }
      catch (Exception ex)
      {
        \u0082\u00BB.\u0081\u0095(_param1, ex);
      }
      catch
      {
        \u0082\u00BB.\u0081\u0095(_param1, (Exception) null);
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    internal static unsafe void ë([In] Ñ* obj0)
    {
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        \u0082\u00BB.\u00A3((Ê*) obj0, "The C++ module failed to load.\n");
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Interlocked.Increment(ref \u0082\u00BB.\u0081ó);
          flag = true;
        }
        \u0082\u00BB.Ø(obj0);
      }
      catch (Exception ex)
      {
        if (flag)
          \u0082\u00BB.û(obj0, ex);
        \u0082\u00BB.\u00B9(\u0082\u00BB.\u009A((Ê*) obj0), ex);
      }
      catch
      {
        if (flag)
          \u0082\u00BB.û(obj0, (Exception) null);
        \u0082\u00BB.\u00B9(\u0082\u00BB.\u009A((Ê*) obj0), (Exception) null);
      }
    }

    [DebuggerStepThrough]
    static unsafe \u0082\u00BB()
    {
      Ñ ñ;
      \u0082\u00BB.Ó(&ñ);
      // ISSUE: fault handler
      try
      {
        \u0082\u00BB.ë(&ñ);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u0082\u00BB.\u0081\u00A4((__FnPtr<void (void*)>) __methodptr(Æ), (void*) &ñ);
      }
      \u0082\u00BB.\u00B0((Ê*) &ñ);
    }

    internal static unsafe Ñ* Ó([In] Ñ* obj0)
    {
      \u0082\u00BB.º((Ê*) obj0);
      return obj0;
    }

    internal static unsafe void Æ([In] Ñ* obj0) => \u0082\u00BB.\u00B0((Ê*) obj0);

    [DebuggerStepThrough]
    internal static unsafe Ê* º([In] Ê* obj0)
    {
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      *(int*) obj0 = (int) num.ToPointer();
      return obj0;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00B0([In] Ê* obj0)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe Ê* \u00A3([In] Ê* obj0, string _param1)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) _param1;
      return obj0;
    }

    internal static unsafe string \u009A([In] Ê* obj0) => (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;

    [STAThread]
    internal static unsafe int \u0082\u009C(string[] _param0)
    {
      try
      {
        \u0082\u00BB.à(1);
        *\u0082\u00BB.Å() = \u0082\u00BB.\u0024;
        *\u0082\u00BB.Ì() = \u0082\u00BB.\u0081ß;
        \u0082\u00BB.\u0081þ();
        \u0082\u00BB.\u0082\u0081();
        if (\u0082\u00BB.\u0081í == -1)
          \u0082\u00BB.Ù(-1);
        \u0082º º;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref º = \u0082\u00BB.\u0081ñ;
        int num;
        char** chPtr1;
        char** chPtr2;
        if (\u0082\u00BB.Â(&num, &chPtr1, &chPtr2, \u0082\u00BB.\u0081ô, &º) < 0)
          \u0082\u00BB.\u0081º(8);
        \u0082\u00BB.\u008A();
        return \u0082\u00BB.\u0081É(_param0);
      }
      catch (Exception ex) when (\u0082\u00BB.È((uint) Marshal.GetExceptionCode(), (\u0082\u00B2*) Marshal.GetExceptionPointers()) != 0)
      {
        return Marshal.GetExceptionCode();
      }
    }

    internal static unsafe void \u008A()
    {
      \u0082\u009A* objPtr1 = (\u0082\u009A*) \u0082\u00BB.Ò((sbyte*) 0);
      if (*(ushort*) objPtr1 != (ushort) 23117)
        return;
      \u0082\u00A7* objPtr2 = (\u0082\u00A7*) (*(int*) ((IntPtr) objPtr1 + 60) + (IntPtr) objPtr1);
      if (*(int*) objPtr2 != 17744 || *(ushort*) ((IntPtr) objPtr2 + 24) != (ushort) 267)
        return;
      if (*(ushort*) ((IntPtr) objPtr2 + 24 + 68) != (ushort) 3)
        \u0082\u00BB.à(2);
      else
        \u0082\u00BB.à(1);
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0086()
    {
      object obj = new object();
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref \u0082\u00BB.\u0091 = 0;
      \u0082\u00BB.\u00AB(&\u0082\u00BB.\u0091, obj);
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u00AC() => \u0082\u00BB.â(&\u0082\u00BB.\u0091) != null;

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u00A0() => Monitor.Enter(\u0082\u00BB.â(&\u0082\u00BB.\u0091));

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0091() => Monitor.Exit(\u0082\u00BB.â(&\u0082\u00BB.\u0091));

    internal static void \u0082\u0083() => \u0082\u00BB.ø((__FnPtr<void ()>) __methodptr(\u0081Ý));

    internal static unsafe void \u0081Ý() => \u0082\u00BB.Í(&\u0082\u00BB.\u0091);

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081\u00BF()
    {
      bool flag = false;
      if (\u0082\u00BB.\u0082\u00AC())
      {
        Monitor.Enter(\u0082\u00BB.â(&\u0082\u00BB.\u0091));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081\u00B8()
    {
      bool flag = false;
      if (\u0082\u00BB.\u0082\u00AC())
      {
        Monitor.Exit(\u0082\u00BB.â(&\u0082\u00BB.\u0091));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00B0()
    {
      if (!\u0082\u00BB.\u0082\u00AC())
        \u0082\u00BB.\u0082\u0086();
      return \u0082\u00BB.\u0082\u00AC();
    }

    internal static unsafe int \u0081\u00A6(
      __FnPtr<void ()> _param0,
      uint* _param1,
      __FnPtr<void ()>** _param2,
      __FnPtr<void ()>** _param3)
    {
      // ISSUE: cast to a function pointer type
      __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
      if (_param0 == null)
        return -1;
      int num1;
      if (\u0082\u00BB.\u0081\u00BF())
      {
        try
        {
          if (*_param1 - 1U < (uint) (*(int*) _param2 - *(int*) _param3) >> 2)
          {
            try
            {
              uint num2 = *_param1 * 4U;
              uint num3 = num2 >= 2048U ? 2048U : num2;
              IntPtr cb = new IntPtr((int) num2 + (int) num3);
              IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local2 = _param2;
              IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) _param3);
              *(int*) local2 = (int) num5;
              *(int*) _param3 = (int) num4.ToPointer();
              uint num6 = *_param1;
              uint num7 = 512U >= num6 ? num6 : 512U;
              *_param1 = num6 + num7;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *_param1 * 4 + 8);
              IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local3 = _param2;
              IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) _param3);
              *(int*) local3 = (int) num9;
              *(int*) _param3 = (int) num8.ToPointer();
              uint* numPtr = _param1;
              int num10 = (int) *numPtr + 4;
              *numPtr = (uint) num10;
            }
          }
          *(int*) *(int*) _param2 = (int) _param0;
          __FnPtr<void ()>** local4 = _param2;
          int num11 = *(int*) local4 + 4;
          *(int*) local4 = num11;
          local1 = _param0;
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u0082\u00BB.\u0081\u00B8();
        }
        if (local1 != null)
        {
          num1 = 0;
          goto label_12;
        }
      }
      num1 = -1;
label_12:
      return num1;
    }

    internal static unsafe void \u0081\u0098()
    {
      if ((IntPtr) \u0082\u00BB.\u0082\u0085 == new IntPtr(-1) || (IntPtr) \u0082\u00BB.\u0082\u0085 == IntPtr.Zero || (IntPtr) \u0082\u00BB.\u0082\u008D == IntPtr.Zero)
        return;
      \u0082\u00BB.\u0082\u008D -= 4;
      if (\u0082\u00BB.\u0082\u008D >= \u0082\u00BB.\u0082\u0085)
      {
        do
        {
          if (*(int*) \u0082\u00BB.\u0082\u008D != 0)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void ()>) *(int*) \u0082\u00BB.\u0082\u008D)();
          }
          \u0082\u00BB.\u0082\u008D -= 4;
        }
        while (\u0082\u00BB.\u0082\u008D >= \u0082\u00BB.\u0082\u0085);
      }
      Marshal.FreeHGlobal(new IntPtr((void*) \u0082\u00BB.\u0082\u0085));
    }

    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0094()
    {
      if (!\u0082\u00BB.\u0081\u00B0())
        return 0;
      \u0082\u00BB.\u0082\u0085 = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
      \u0082\u00BB.\u0082\u008D = \u0082\u00BB.\u0082\u0085;
      \u0082\u00BB.\u0082\u0097 = 32U;
      return 1;
    }

    internal static __FnPtr<int ()> \u0081\u0091(__FnPtr<int ()> _param0) => \u0082\u00BB.\u0081\u008A((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    internal static unsafe int \u0081\u008A(__FnPtr<void ()> _param0) => \u0082\u00BB.\u0081\u00A6(_param0, &\u0082\u00BB.\u0082\u0097, &\u0082\u00BB.\u0082\u008D, &\u0082\u00BB.\u0082\u0085);

    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0089()
    {
      if (\u0082\u00BB.\u0081\u00B0())
      {
        \u0082\u00BB.\u0082\u009F = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
        \u0082\u00BB.\u0081ü = \u0082\u00BB.\u0082\u009F;
        \u0082\u00BB.\u0097 = 32U;
      }
      return 1;
    }

    internal static unsafe void É()
    {
      if ((IntPtr) \u0082\u00BB.\u0082\u009F == new IntPtr(-1) || (IntPtr) \u0082\u00BB.\u0082\u009F == IntPtr.Zero)
        return;
      if ((IntPtr) \u0082\u00BB.\u0081ü == IntPtr.Zero)
        return;
      try
      {
        while (true)
        {
          do
          {
            \u0082\u00BB.\u0081ü -= 4;
            if (\u0082\u00BB.\u0081ü < \u0082\u00BB.\u0082\u009F)
              goto label_8;
          }
          while (*(int*) \u0082\u00BB.\u0081ü == 0);
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) *(int*) \u0082\u00BB.\u0081ü)();
        }
label_8:;
      }
      finally
      {
        Marshal.FreeHGlobal(new IntPtr((void*) \u0082\u00BB.\u0082\u009F));
      }
    }

    internal static __FnPtr<int ()> ý(__FnPtr<int ()> _param0) => \u0082\u00BB.ø((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [DebuggerStepThrough]
    internal static unsafe int ø(__FnPtr<void ()> _param0) => \u0082\u00BB.\u0081\u00A6(_param0, &\u0082\u00BB.\u0097, &\u0082\u00BB.\u0081ü, &\u0082\u00BB.\u0082\u009F);

    [DebuggerStepThrough]
    internal static unsafe void ó([In] \u0082\u0098* obj0, object _param1)
    {
      *(int*) obj0 = 0;
      \u0082\u00BB.\u00AB(obj0, _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe object â([In] \u0082\u0098* obj0)
    {
      ValueType valueType = \u0082\u00BB.\u00BE(obj0);
      return valueType != null ? ((GCHandle) valueType).Target : (object) null;
    }

    internal static unsafe void Í([In] \u0082\u0098* obj0)
    {
      ValueType valueType = \u0082\u00BB.\u00BE(obj0);
      if (valueType == null)
        return;
      ((GCHandle) valueType).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe ValueType \u00BE([In] \u0082\u0098* obj0)
    {
      uint num = (uint) *(int*) obj0;
      return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00AB([In] \u0082\u0098* obj0, object _param1)
    {
      ValueType valueType = \u0082\u00BB.\u00BE(obj0);
      if (valueType == null)
      {
        IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(_param1));
        *(int*) obj0 = (int) intPtr.ToPointer();
      }
      else
        ((GCHandle) valueType).Target = _param1;
    }

    [DebuggerStepThrough]
    internal static unsafe int \u0082\u009E(__FnPtr<int ()>* _param0, __FnPtr<int ()>* _param1)
    {
      int num1 = 0;
      if (_param0 < _param1)
      {
        while (num1 == 0)
        {
          uint num2 = (uint) *(int*) _param0;
          if (num2 != 0U)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            num1 = __calli((__FnPtr<int ()>) (int) num2)();
          }
          _param0 += 4;
          if (_param0 >= _param1)
            break;
        }
      }
      return num1;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0093(__FnPtr<void ()>* _param0, __FnPtr<void ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (int) num)();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static ModuleHandle \u0082\u0093() => typeof (\u0082\u0090).Module.ModuleHandle;

    [DebuggerStepThrough]
    internal static unsafe void \u0085(__FnPtr<void* ()>* _param0, __FnPtr<void* ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli(\u0082\u00BB.\u0083((__FnPtr<void* ()>) (int) num))();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe __FnPtr<void* ()> \u0083(__FnPtr<void* ()> _param0) => (__FnPtr<void* ()>) (IntPtr) \u0082\u00BB.\u0082\u0093().ResolveMethodHandle((int) _param0).GetFunctionPointer().ToPointer();

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0081\u00A4(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082\u00BB.\u0081\u00A9((\u0082\u00B2*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0082\u0099(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082\u00BB.\u0081\u00A9((\u0082\u00B2*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0082\u0092(
      __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> _param0,
      void* _param1,
      uint _param2,
      int _param3,
      __FnPtr<void (void*)> _param4)
    {
      try
      {
        void* voidPtr = _param1;
        int num1 = (int) _param2;
        int num2 = _param3;
        __FnPtr<void (void*)> local = _param4;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli(_param0)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
      }
      catch (Exception ex) when (\u0082\u00BB.\u0081\u00A9((\u0082\u00B2*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    internal static void \u0082\u0081()
    {
      if (\u0082\u00BB.\u0081å != 0)
        return;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u0082\u00BB.\u00BB((__FnPtr<int (\u0081î*)>) __methodptr(\u0081ú));
    }

    internal static int \u0081þ() => 0;

    internal static unsafe int \u0081ú(\u0081î* _param0) => 0;

    internal static unsafe Assembly \u0081õ(string _param0)
    {
      string str = _param0.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length).Trim();
      bool flag = str == "PvLogiciels.dotNetProtector.Runtime";
      byte[] numArray = !flag ? new byte[\u0082\u00BB.\u00A4()] : new byte[\u0082\u00BB.\u009D()];
      if (numArray == null || numArray.Length == 0)
        return (Assembly) null;
      GCHandle gcHandle = GCHandle.Alloc((object) numArray, GCHandleType.Pinned);
      byte* pointer = (byte*) Marshal.UnsafeAddrOfPinnedArrayElement((Array) numArray, 0).ToPointer();
      if (flag)
        \u0082\u00BB.ª(pointer);
      else
        \u0082\u00BB.\u00B3(pointer);
      gcHandle.Free();
      return Assembly.Load(numArray);
    }

    internal static unsafe void* \u0081ï(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      Module module = Assembly.GetExecutingAssembly().LoadModule("embedded.netmodule", numArray);
      AppDomain.CurrentDomain.SetData("PvLogiciels.dotNetProtector.embedded.netmodule", (object) module);
      return Marshal.GetHINSTANCE(module).ToPointer();
    }

    internal static unsafe void* \u0081â(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      return Marshal.GetHINSTANCE(Assembly.Load(numArray).GetLoadedModules()[0]).ToPointer();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0081Û(string[] _param0) => \u003CdotNetProtector\u003E.Main(_param0);

    internal static int \u0081Ö(string[] _param0)
    {
      Module data = (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");
      if ((object) data == null)
        return \u0082\u00BB.\u0081Û(_param0);
      Type type = data.GetType("<dotNetProtector>");
      if ((object) type == null)
        return \u0082\u00BB.\u0081Û(_param0);
      MethodBase method = (MethodBase) type.GetMethod("Main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      if ((object) method == null)
        return \u0082\u00BB.\u0081Û(_param0);
      object[] parameters = new object[1]
      {
        (object) _param0
      };
      return (int) method.Invoke((object) null, parameters);
    }

    internal static Assembly \u0081Ô(object _param0, ResolveEventArgs _param1)
    {
      string str = _param1.Name.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      int index = 0;
      if (0 < assemblies.Length)
      {
        Assembly assembly;
        do
        {
          assembly = assemblies[index];
          if (!(assembly.FullName == str))
            ++index;
          else
            goto label_5;
        }
        while (index < assemblies.Length);
        goto label_6;
label_5:
        return assembly;
      }
label_6:
      return (Assembly) null;
    }

    internal static Module \u0081Í(object _param0, ResolveEventArgs _param1) => (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0081Ê(string[] _param0)
    {
      PvLogiciels.dotNetProtector.Runtime.ExeInit(typeof (RuntimeInterop), IntPtr.Zero, 0);
      Assembly.GetExecutingAssembly().ModuleResolve += new ModuleResolveEventHandler(\u0082\u00BB.\u0081Í);
      return \u0082\u00BB.\u0081Ö(_param0);
    }

    [STAThread]
    internal static int \u0081É(string[] _param0)
    {
      \u0082\u00BB.\u00B6();
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0082\u00BB.\u0081Ô);
      return \u0082\u00BB.\u0081Ê(_param0);
    }

    internal static void \u0081È()
    {
    }

    internal static int \u0081Å() => 0;

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081\u00BE();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081º([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B7();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B2([In] uint obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u00B9([In] string obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u00B9([In] string obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00A1();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0095([In] Exception obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0085([In] EventHandler obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ö([In] __FnPtr<int (void*)> obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void ì();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int é();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void à([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int Ù([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe \u00AD* Ò([In] sbyte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* Ì();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int È([In] uint obj0, [In] \u0082\u00B2* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* Å();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Â(
      [In] int* obj0,
      [In] char*** obj1,
      [In] char*** obj2,
      [In] int obj3,
      [In] \u0082º* obj4);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00A9([In] \u0082\u00B2* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u00BB([In] __FnPtr<int (\u0081î*)> obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u00B6();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u00B3([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ª([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u00A4();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u009D();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0098([In] int obj0, [In] void* obj1, [In] void* obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0096([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0082\u0087([In] byte* obj0, [In] void** obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u008B([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081ø();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe uint \u0082([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00B9([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00AF([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00AB([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ø([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00A1([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0096([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0082\u008B([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0082([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00AC(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3,
      [In] byte obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00AC(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6,
      [In] byte obj7);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ð([In] byte* obj0, [In] void* obj1, [In] void* obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ð(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081è(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte** obj5);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081è(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte* obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081è(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] byte* obj5,
      [In] ushort obj6,
      [In] ushort obj7,
      [In] sbyte** obj8);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B4([In] byte* obj0, [In] uint* obj1, [In] byte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00D7([In] byte* obj0, [In] byte* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ñ([In] byte* obj0, [In] uint obj1, [In] ushort obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ñ(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte* obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ñ(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] byte* obj3,
      [In] ushort obj4,
      [In] ushort obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Ã([In] byte* obj0, [In] void* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ä([In] byte* obj0, [In] void* obj1, [In] sbyte* obj2, [In] byte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00BC([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2, [In] ulong* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00BC([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081µ(
      [In] byte* obj0,
      [In] void* obj1,
      [In] uint obj2,
      [In] ulong obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081µ([In] byte* obj0, [In] void* obj1, [In] uint obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u00A1([In] byte* obj0, [In] ulong obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ª([In] byte* obj0, [In] sbyte* obj1, [In] int obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00A5([In] byte* obj0, [In] sbyte* obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void Ý([In] byte* obj0, [In] sbyte* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u009B();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern ulong Ï();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern long Ç();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern ulong \u0081\u008C();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0086();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u0081(
      [In] byte* obj0,
      [In] void* obj1,
      [In] int* obj2,
      [In] sbyte* obj3,
      [In] int obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u0081([In] byte* obj0, [In] void* obj1, [In] int obj2, [In] int obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u00B7([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void ù();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* ô([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* î([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0095([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ã([In] void* obj0, [In] int obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int Õ();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0084([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u009A([In] void* obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00AE([In] void* obj0, [In] void* obj1, [In] int obj2, [In] void* obj3);
  }
}
