// Decompiled with JetBrains decompiler
// Type: k
// Assembly: Fugi, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BEDD3B0B-7024-4DCA-82E7-4DC806657EA8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan-Dropper.Win32.Dapato.adjp-c7222843a23fc031926828311c4204ba181271a1dde91017bc4695dc95b5fc46.exe

using System;
using System.Collections;
using System.IO;

internal sealed class k
{
  public sealed class a : Stream, IDisposable
  {
    private const int a = 8192;
    private Stream b;
    private bool c;
    private bool d;
    private k.b e;
    private byte[] f;
    private int g;

    public a(Stream a)
      : this(a, false)
    {
    }

    public a(Stream a1, bool a2)
    {
      this.b = (a1 == null ? 0 : 1) != 0 ? a1 : throw new ArgumentNullException();
label_4:
      int num = 1;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.e = new k.b(a1);
            num = 4;
            continue;
          case 1:
            this.c = a2;
            num = 2;
            continue;
          case 2:
            this.d = true;
            num = 3;
            continue;
          case 3:
            this.f = new byte[8192];
            num = 0;
            continue;
          case 4:
            goto label_9;
          default:
            goto label_4;
        }
      }
label_9:;
    }

    public Stream a => this.b;

    public override bool CanSeek => false;

    public override bool CanRead => false;

    public override bool CanWrite => true;

    public override long Length => throw new NotImplementedException();

    public override long Position
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();

    public override void SetLength(long value) => throw new NotImplementedException();

    private void a()
    {
      if (!this.d)
        throw new InvalidOperationException("Stream is closed.");
    }

    public override int Read(byte[] buffer, int offset, int count) => throw new NotSupportedException();

    public override void Write(byte[] buffer, int offset, int count)
    {
      if ((count >= 0 ? 0 : 1) != 0 || count > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (count));
      if (offset < 0 || offset > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (offset));
      if (offset + count > buffer.Length)
        throw new ArgumentException("offset + count out of buffer");
      this.a();
      if (this.g + count > 8192)
        this.b();
      if (count >= 8192)
      {
        int num;
        for (num = 0; count - num > 32768; num += 32768)
          this.e.a(buffer, offset + num, 32768, false);
        this.e.a(buffer, offset + num, count - num, false);
      }
      else
      {
        Array.Copy((Array) buffer, offset, (Array) this.f, this.g, count);
label_15:
        int num = 1;
        while (true)
        {
          switch (num)
          {
            case 0:
              if (this.g == 8192)
              {
                num = 2;
                continue;
              }
              goto label_19;
            case 1:
              this.g += count;
              num = 0;
              continue;
            case 2:
              goto label_20;
            default:
              goto label_15;
          }
        }
label_19:
        return;
label_20:
        this.b();
      }
    }

    private void b()
    {
      if (this.g <= 0)
        return;
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.e.a(this.f, 0, this.g, false);
            num = 1;
            continue;
          case 1:
            goto label_5;
          default:
            goto label_2;
        }
      }
label_5:
      this.g = 0;
    }

    public override void Flush()
    {
      this.a();
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (this.g > 0)
            {
              num = 1;
              continue;
            }
            goto label_6;
          case 1:
            goto label_5;
          default:
            goto label_2;
        }
      }
label_5:
      this.b();
label_6:
      this.e.a(true, false);
      this.a.Flush();
    }

    private void c()
    {
      if (this.g > 0)
      {
label_2:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.e.a(this.f, 0, this.g, true);
              num = 1;
              continue;
            case 1:
              goto label_4;
            default:
              goto label_2;
          }
        }
label_4:;
      }
      else
        this.e.a(false, true);
    }

    void IDisposable.Dispose()
    {
      if ((!this.d ? 1 : 0) == 0)
      {
        this.c();
label_3:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.f = (byte[]) null;
              num = 2;
              continue;
            case 1:
              if (!this.c)
              {
                num = 3;
                continue;
              }
              goto label_10;
            case 2:
              this.e = (k.b) null;
              num = 1;
              continue;
            case 3:
              this.b.Close();
              num = 4;
              continue;
            case 4:
              goto label_9;
            default:
              goto label_3;
          }
        }
label_9:
        this.b = (Stream) null;
label_10:
        this.d = false;
      }
      this.Close();
    }
  }

  private sealed class b
  {
    public const int a = 32768;
    private Stream b;
    private k.h c;
    private k.d d;

    public b(Stream a)
    {
      this.b = (a == null ? 0 : 1) != 0 ? a : throw new ArgumentNullException();
label_5:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.c = new k.h(a);
            num = 1;
            continue;
          case 1:
            this.d = new k.d();
            num = 2;
            continue;
          case 2:
            goto label_4;
          default:
            goto label_5;
        }
      }
label_4:;
    }

    public Stream a => this.b;

    internal void a(k.g a1, out int[] a2, out int[] a3, out int a4)
    {
      a2 = new int[286];
      a3 = new int[30];
      a4 = 0;
      int index1 = 0;
      int index2 = 0;
      if ((index2 == 0 ? 1 : 0) != 0)
        goto label_10;
label_1:
      ushort index3 = (ushort) a1.a[index1];
      if (index3 <= (ushort) 256)
      {
        ++a2[(int) index3];
        ++index1;
      }
      else
      {
        ++a2[(int) index3];
label_5:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              ++a3[(int) (ushort) a1.a[index1 + 2]];
              num = 2;
              continue;
            case 1:
              a4 += (int) (byte) a1.b[index2] + (int) (byte) a1.b[index2 + 1];
              num = 3;
              continue;
            case 2:
              index1 += 4;
              num = 1;
              continue;
            case 3:
              goto label_9;
            default:
              goto label_5;
          }
        }
label_9:
        index2 += 2;
      }
label_10:
      if (index1 < a1.a.Count)
        goto label_1;
    }

    public void a(bool a1, bool a2)
    {
      this.c.a(a2);
      if ((!a1 ? 1 : 0) == 0)
      {
        this.c.a(0, 2);
label_3:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              this.c.a();
              num = 2;
              continue;
            case 1:
              this.c.a((int) ushort.MaxValue, 16);
              num = 3;
              continue;
            case 2:
              this.c.a(0, 16);
              num = 1;
              continue;
            case 3:
              goto label_8;
            default:
              goto label_3;
          }
        }
      }
      else
      {
        this.c.a(1, 2);
        global::g g = global::f.r[256];
        this.c.b(g.a, g.b);
      }
label_8:
      if (!a2)
        return;
      this.c.a();
    }

    public void a(byte[] a1, int a2, int a3, bool a4)
    {
      if (a3 > 32768)
        throw new ArgumentOutOfRangeException();
      k.g a5 = this.d.a(a1, a2, a3);
      if ((a5 == null ? 0 : 1) == 0)
        throw new InvalidOperationException();
      if (a5.c != a3)
        throw new InvalidOperationException();
      a5.a();
      int[] a6;
      int[] a7;
      int a8;
      this.a(a5, out a6, out a7, out a8);
      int[] a9 = global::f.a(a6);
      int[] a10 = global::f.a(a7);
      int num1 = (4 + a3) * 8;
      int num2 = this.c.a >= 3 ? num1 + (this.c.a - 3) : num1 + (5 + this.c.a);
      int num3 = global::f.a(a9, a6) + global::f.a(a10, a7) + a8;
      int num4 = global::f.b(a9, a10) + a8;
      bool flag1 = num4 <= num3 || num2 <= num3;
      if (!flag1)
      {
        int num5 = num3 + this.a(a9, a10);
        flag1 = num4 <= num5 || num2 <= num5;
      }
      bool flag2 = num2 < num4;
      this.c.a(a4);
      if (flag2 && flag1)
      {
        this.c.a(0, 2);
label_11:
        int num6 = 3;
        int a11;
        int a12;
        while (true)
        {
          switch (num6)
          {
            case 0:
              this.c.a();
              num6 = 6;
              continue;
            case 1:
              this.c.a(a11, 16);
              num6 = 2;
              continue;
            case 2:
              this.c.a(a12, 16);
              num6 = 0;
              continue;
            case 3:
              this.c.a();
              num6 = 5;
              continue;
            case 4:
              a12 = ~a3 & (int) ushort.MaxValue;
              num6 = 1;
              continue;
            case 5:
              a11 = a3;
              num6 = 4;
              continue;
            case 6:
              this.a(a1, a2, a3);
              num6 = 7;
              continue;
            case 7:
              goto label_23;
            default:
              goto label_11;
          }
        }
      }
      else
      {
        global::g[] a13;
        global::g[] a14;
        if (flag1)
        {
          this.c.a(1, 2);
          a13 = global::f.r;
          a14 = global::f.s;
        }
        else
        {
          this.c.a(2, 2);
          this.a(a9, a10);
          a13 = global::f.a(a9);
          a14 = global::f.a(a10);
        }
        this.a(a5, a13, a14);
      }
label_23:
      if (!a4)
        return;
      this.c.a();
    }

    private void a(k.g a1, global::g[] a2, global::g[] a3)
    {
      int index1 = 0;
      int index2 = 0;
      if ((index2 == 0 ? 1 : 0) != 0)
        goto label_15;
label_1:
      int index3 = (int) (ushort) a1.a[index1];
      if (index3 <= 256)
      {
        global::g g = a2[index3];
        this.c.b(g.a, g.b);
        ++index1;
      }
      else
      {
        global::g g = a2[index3];
        this.c.b(g.a, g.b);
        if ((byte) a1.b[index2] > (byte) 0)
          this.c.a((int) (ushort) a1.a[index1 + 1], (int) (byte) a1.b[index2]);
        int index4 = index1 + 2;
label_7:
        int num = 3;
        while (true)
        {
          switch (num)
          {
            case 0:
              g = a3[(int) (ushort) a1.a[index4]];
              num = 2;
              continue;
            case 1:
              if ((byte) a1.b[index2] > (byte) 0)
              {
                num = 4;
                continue;
              }
              goto label_14;
            case 2:
              this.c.b(g.a, g.b);
              num = 1;
              continue;
            case 3:
              ++index2;
              num = 0;
              continue;
            case 4:
              goto label_13;
            default:
              goto label_7;
          }
        }
label_13:
        this.c.a((int) (ushort) a1.a[index4 + 1], (int) (byte) a1.b[index2]);
label_14:
        index1 = index4 + 2;
        ++index2;
      }
label_15:
      if (index1 < a1.a.Count)
        goto label_1;
    }

    private void a(byte[] a1, int a2, int a3) => this.a.Write(a1, a2, a3);

    private void a(int[] a1, int[] a2)
    {
      int[] a3 = new int[19];
      int num1 = 286;
      if ((num1 == 0 ? 0 : 1) != 0)
        goto label_2;
label_1:
      --num1;
label_2:
      if (num1 <= 257 || a1[num1 - 1] != 0)
      {
        int length = 30;
        while (length > 1 && a2[length - 1] == 0)
          --length;
        int[] numArray1 = new int[num1 + length];
        Array.Copy((Array) a1, 0, (Array) numArray1, 0, num1);
        Array.Copy((Array) a2, 0, (Array) numArray1, num1, length);
        int[] numArray2 = global::f.a(numArray1, 0, numArray1.Length);
        for (int index = 0; index < numArray2.Length; ++index)
        {
          ++a3[numArray2[index]];
          if (numArray2[index] >= 16)
            ++index;
        }
        int[] a4 = global::f.a(a3, 7);
        int[] u = global::f.u;
        int num2 = 19;
        while (num2 > 4 && a4[u[num2 - 1]] == 0)
          --num2;
        int a5 = num1 - 257;
label_16:
        int num3 = 2;
        int a6;
        int a7;
        global::g[] gArray;
        int index1;
        while (true)
        {
          switch (num3)
          {
            case 0:
              this.c.a(a5, 5);
              num3 = 5;
              continue;
            case 1:
              a6 = num2 - 4;
              num3 = 4;
              continue;
            case 2:
              a7 = length - 1;
              num3 = 1;
              continue;
            case 3:
              this.c.a(a6, 4);
              num3 = 6;
              continue;
            case 4:
              gArray = global::f.a(a4);
              num3 = 0;
              continue;
            case 5:
              this.c.a(a7, 5);
              num3 = 3;
              continue;
            case 6:
              index1 = 0;
              num3 = 7;
              continue;
            case 7:
              goto label_26;
            default:
              goto label_16;
          }
        }
label_26:
        for (; index1 < num2; ++index1)
          this.c.a(a4[u[index1]], 3);
        for (int index2 = 0; index2 < numArray2.Length; ++index2)
        {
          int a8 = numArray2[index2];
          global::g g = gArray[a8];
          this.c.b(g.a, g.b);
          if (a8 >= 16)
          {
            ++index2;
            this.c.a(numArray2[index2], global::f.a(a8));
          }
        }
      }
      else
        goto label_1;
    }

    private int a(int[] a1, int[] a2)
    {
      int[] a3 = new int[19];
      int num1 = 0;
      int a4 = 286;
      if ((a4 == 0 ? 0 : 1) != 0)
        goto label_2;
label_1:
      --a4;
label_2:
      if (a4 <= 257 || a1[a4 - 1] != 0)
      {
        int[] numArray1 = global::f.a(a1, 0, a4);
label_12:
        for (int index = 0; index < numArray1.Length; ++index)
        {
          ++a3[numArray1[index]];
label_6:
          int num2 = 0;
          while (true)
          {
            switch (num2)
            {
              case 0:
                if (numArray1[index] >= 16)
                {
                  num2 = 1;
                  continue;
                }
                goto label_12;
              case 1:
                num1 += global::f.a(numArray1[index]);
                num2 = 2;
                continue;
              case 2:
                goto label_10;
              default:
                goto label_6;
            }
          }
label_10:
          ++index;
        }
        int a5 = 30;
        while (a5 > 1 && a2[a5 - 1] == 0)
          --a5;
        int[] numArray2 = global::f.a(a2, 0, a5);
        for (int index = 0; index < numArray2.Length; ++index)
        {
          ++a3[numArray2[index]];
          if (numArray2[index] >= 16)
          {
            num1 += global::f.a(numArray2[index]);
            ++index;
          }
        }
        int[] a6 = global::f.a(a3);
        int num3 = global::f.a(a3, a6);
        int[] u = global::f.u;
        int num4 = 19;
        while (num4 > 4 && a6[u[num4 - 1]] == 0)
          --num4;
        return 14 + (num4 - 4 + 4) * 3 + num3 + num1;
      }
      goto label_1;
    }
  }

  private sealed class c
  {
    public static readonly k.c a;
    public int b;
    public int c;
    public int d;
    public int e;

    static c()
    {
      k.c c = new k.c();
label_2:
      int num = 2;
      while (true)
      {
        switch (num)
        {
          case 0:
            c.c = 32;
            num = 1;
            continue;
          case 1:
            c.d = 128;
            num = 3;
            continue;
          case 2:
            c.b = 8;
            num = 0;
            continue;
          case 3:
            c.e = 256;
            num = 4;
            continue;
          case 4:
            k.c.a = c;
            num = 5;
            continue;
          case 5:
            goto label_8;
          default:
            goto label_2;
        }
      }
label_8:;
    }
  }

  private sealed class d
  {
    private const int a = 258;
    private const int b = 32768;
    private k.f c;
    private k.e d;
    private k.c e;
    private int f;

    internal d()
      : this(k.c.a)
    {
    }

    internal d(k.c a)
    {
      this.e = a;
label_2:
      int num = 2;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.d = new k.e(32768);
            num = 1;
            continue;
          case 1:
            this.f = 0;
            num = 3;
            continue;
          case 2:
            this.c = new k.f(65536);
            num = 0;
            continue;
          case 3:
            goto label_6;
          default:
            goto label_2;
        }
      }
label_6:;
    }

    internal k.c a => this.e;

    public k.g a(byte[] a1, int a2, int a3)
    {
      if (this.c.b + a3 > this.c.a)
      {
        int a = this.c.b - 32768;
        this.c.a(a);
        if ((this.f >= a ? 0 : 1) == 0)
        {
          this.f -= a;
        }
        else
        {
          this.d.a(a - this.f);
          this.f = 0;
        }
      }
      int b = this.c.b;
label_6:
      int num = 1;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (this.f < b)
            {
              num = 2;
              continue;
            }
            goto label_11;
          case 1:
            this.c.a(a1, a2, a3);
            num = 0;
            continue;
          case 2:
            goto label_10;
          default:
            goto label_6;
        }
      }
label_10:
      this.d.a(this.c.a, this.f, b - this.f);
label_11:
      return this.a.d > 0 ? this.a(this.d, this.c.a, b, a3, out this.f) : this.b(this.c.a, b, a3);
    }

    private k.g b(byte[] a1, int a2, int a3)
    {
      k.g g = new k.g();
label_2:
      int num1 = 2;
      int index;
      while (true)
      {
        switch (num1)
        {
          case 0:
            index = 0;
            num1 = 1;
            continue;
          case 1:
            if (index != 0)
            {
              num1 = 3;
              continue;
            }
            goto label_8;
          case 2:
            g.a.Capacity = a3 + 1;
            num1 = 0;
            continue;
          case 3:
            goto label_7;
          default:
            goto label_2;
        }
      }
label_7:
      int num2 = 0;
      goto label_9;
label_8:
      num2 = 1;
label_9:
      if (num2 != 0)
        goto label_11;
label_10:
      g.a(a1[index]);
      ++index;
label_11:
      if (index >= a3)
        return g;
      goto label_10;
    }

    private k.g a(k.e a1, byte[] a2, int a3, int a4, out int a5)
    {
      k.g g = new k.g();
      object obj1 = (object) null;
      int a6 = 0;
      if ((a6 == 0 ? 1 : 0) != 0)
        goto label_18;
label_1:
      k.e.a a7 = a1.a(a2, a3 + a6);
      if (a7 != null)
      {
        object obj2;
        if (obj1 != null)
        {
          obj2 = obj1;
          obj1 = (object) null;
        }
        else
          obj2 = (object) this.a(a2, a3, a4, a6, a7, 3);
        k.d.a a8 = (k.d.a) obj2;
        bool flag = a8.b >= 3;
        if (flag && a6 < a4 - 3 && a8.b < this.e.c)
        {
          k.e.a a9 = a1.a(a2, a3 + a6 + 1);
          if (a9 != null)
          {
            k.d.a a10 = this.a(a2, a3, a4, a6 + 1, a9, a8.b + 1);
            if (a10.b > a8.b)
            {
              obj1 = (object) a10;
              flag = false;
            }
          }
        }
        if (flag)
        {
          g.a(a6 - a8.a, a8.b);
label_12:
          int num = 2;
          while (true)
          {
            switch (num)
            {
              case 0:
                a6 += a8.b;
                num = 1;
                continue;
              case 1:
                a1.a(a8.b - 1);
                num = 3;
                continue;
              case 2:
                a1.a(a2, a3 + a6);
                num = 0;
                continue;
              case 3:
                goto label_18;
              default:
                goto label_12;
            }
          }
        }
        else
        {
          g.a(a2[a3 + a6]);
          a1.a(a2, a3 + a6);
          ++a6;
        }
      }
      else
      {
        g.a(a2[a3 + a6]);
        a1.a(a2, a3 + a6);
        ++a6;
      }
label_18:
      if (a6 >= a4 - 2)
      {
        a5 = a3 + a6;
        for (; a6 < a4; ++a6)
          g.a(a2[a3 + a6]);
        return g;
      }
      goto label_1;
    }

    private k.d.a a(byte[] a1, int a2, int a3, int a4, k.e.a a5, int a6)
    {
      int e = this.e.e;
label_2:
      int num1 = 4;
      int num2;
      int num3;
      int num4;
      int num5;
      int num6;
      while (true)
      {
        switch (num1)
        {
          case 0:
            num2 = a2 + a4;
            num1 = 5;
            continue;
          case 1:
            num3 = -1;
            num1 = 3;
            continue;
          case 2:
            num4 = a6 - 1;
            num1 = 0;
            continue;
          case 3:
            num5 = 0;
            num1 = 2;
            continue;
          case 4:
            num6 = 0;
            num1 = 1;
            continue;
          case 5:
            goto label_17;
          default:
            goto label_2;
        }
      }
label_17:
      while (a5.a())
      {
        int num7 = 0;
        int num8 = a4 - a5.a;
        if (a4 + num4 < a3)
        {
          int num9 = a2 + num8;
          if ((int) a1[num9 + num4] == (int) a1[num2 + num4])
          {
            while (num7 < 258 && a4 + num7 < a3 && (int) a1[num9 + num7] == (int) a1[num2 + num7])
              ++num7;
            if ((num7 >= num6 ? 0 : 1) == 0)
            {
              num6 = num7;
              num4 = num7;
              num3 = num8;
              if (num6 >= this.e.d)
                break;
            }
            if (num6 >= this.e.b)
              e >>= 2;
          }
          if (++num5 >= e)
            break;
        }
        else
          break;
      }
      return new k.d.a() { b = num6, a = num3 };
    }

    private struct a
    {
      public int a;
      public int b;
    }
  }

  private sealed class e
  {
    private const int a = 16777216;
    private const int b = 256;
    private const ushort c = 65535;
    private const ushort d = 0;
    private int e;
    private ushort[] f;
    private int[] g;
    private int h;

    internal e(int a)
    {
      this.e = a;
label_2:
      int num1 = 0;
      int index;
      while (true)
      {
        switch (num1)
        {
          case 0:
            this.f = new ushort[this.e];
            num1 = 1;
            continue;
          case 1:
            this.g = new int[256];
            num1 = 3;
            continue;
          case 2:
            if (index != 0)
            {
              num1 = 4;
              continue;
            }
            goto label_9;
          case 3:
            index = 0;
            num1 = 2;
            continue;
          case 4:
            goto label_8;
          default:
            goto label_2;
        }
      }
label_8:
      int num2 = 0;
      goto label_10;
label_9:
      num2 = 1;
label_10:
      if (num2 != 0)
        goto label_12;
label_11:
      this.g[index] = (int) ushort.MaxValue;
      ++index;
label_12:
      if (index < 256)
        goto label_11;
    }

    internal k.e.a a(byte[] a1, int a2)
    {
      int index = k.e.a(a1, a2);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (this.g[index] != (int) ushort.MaxValue)
            {
              num = 1;
              continue;
            }
            goto label_7;
          case 1:
            if (this.h - this.g[index] > this.e)
            {
              num = 2;
              continue;
            }
            goto label_8;
          case 2:
            goto label_7;
          default:
            goto label_2;
        }
      }
label_7:
      return (k.e.a) null;
label_8:
      return new k.e.a(this, this.h - this.g[index]);
    }

    internal void a(byte[] a1, int a2)
    {
      int index1 = k.e.a(a1, a2);
      this.f[this.h % this.e] = this.g[index1] == (int) ushort.MaxValue || (this.h - this.g[index1] >= this.e ? 0 : 1) == 0 ? (ushort) 0 : (ushort) (this.h - this.g[index1]);
      this.g[index1] = this.h;
label_2:
      int num1 = 3;
      int num2;
      int index2;
      int num3;
      while (true)
      {
        switch (num1)
        {
          case 0:
            num2 = this.h - this.e;
            num1 = 4;
            continue;
          case 1:
            index2 = 0;
            num1 = 5;
            continue;
          case 2:
            if (num3 >= 16777216)
            {
              num1 = 0;
              continue;
            }
            goto label_14;
          case 3:
            num3 = ++this.h;
            num1 = 2;
            continue;
          case 4:
            num2 -= num2 % this.e;
            num1 = 1;
            continue;
          case 5:
            goto label_13;
          default:
            goto label_2;
        }
      }
label_14:
      return;
label_13:
      for (; index2 < this.g.Length; ++index2)
      {
        if (this.g[index2] >= num2)
          this.g[index2] -= num2;
        else
          this.g[index2] = 0;
      }
      this.h -= num2;
    }

    internal void a(byte[] a1, int a2, int a3)
    {
      int num1 = 0;
      if ((num1 == 0 ? 1 : 0) != 0)
        goto label_6;
      else
        goto label_3;
label_2:
      int num2;
      switch (num2)
      {
        case 0:
          goto label_4;
        case 1:
          ++num1;
          goto label_6;
      }
label_3:
      num2 = 0;
      goto label_2;
label_4:
      this.a(a1, a2 + num1);
      num2 = 1;
      goto label_2;
label_6:
      if (num1 < a3)
        goto label_4;
    }

    internal void a(int a) => this.h += a;

    private static int a(byte[] a1, int a2) => (int) (byte) ((uint) a1[a2] + (uint) a1[a2 + 1] + (uint) a1[a2 + 2]);

    internal sealed class a
    {
      private k.e a;
      private int b;
      private int c;

      internal a(k.e a1, int a2)
      {
        this.a = a1;
        this.b = a2;
      }

      internal int a => this.b;

      internal bool a()
      {
        if ((this.c == 0 ? 0 : 1) == 0)
        {
          this.c = 1;
          return true;
        }
        if (this.c == 1)
        {
          ushort num1 = this.a.f[(this.a.h - this.b) % this.a.e];
label_5:
          int num2 = 1;
          while (true)
          {
            switch (num2)
            {
              case 0:
                if (this.b <= this.a.e)
                {
                  num2 = 3;
                  continue;
                }
                goto label_12;
              case 1:
                if (num1 != (ushort) 0)
                {
                  num2 = 2;
                  continue;
                }
                goto label_12;
              case 2:
                this.b += (int) num1;
                num2 = 0;
                continue;
              case 3:
                goto label_11;
              default:
                goto label_5;
            }
          }
label_11:
          return true;
label_12:
          this.c = 2;
        }
        return false;
      }
    }
  }

  private sealed class f
  {
    private int a;
    private byte[] b;
    private int c;

    public f(int a)
    {
      this.a = a;
      this.b = new byte[a];
      this.c = 0;
    }

    public byte[] a => this.b;

    public int a => this.a;

    public int b => this.c;

    public void a(byte[] a1, int a2, int a3)
    {
      Array.Copy((Array) a1, a2, (Array) this.b, this.c, a3);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.c += a3;
            num = 1;
            continue;
          case 1:
            goto label_4;
          default:
            goto label_2;
        }
      }
label_4:;
    }

    public void a(int a)
    {
      Array.Copy((Array) this.b, a, (Array) this.b, 0, this.b - a);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.c -= a;
            num = 1;
            continue;
          case 1:
            goto label_4;
          default:
            goto label_2;
        }
      }
label_4:;
    }
  }

  private sealed class g
  {
    internal ArrayList a = new ArrayList();
    internal ArrayList b = new ArrayList();
    internal int c;

    public void a(byte a)
    {
      this.a.Add((object) (ushort) a);
      ++this.c;
    }

    public void a(int a1, int a2)
    {
      if ((a1 >= 1 ? 0 : 1) != 0 || a1 > 32768)
        throw new ArgumentOutOfRangeException();
      if (a2 < 3 || a2 > 258)
        throw new ArgumentOutOfRangeException();
      int a3;
      int a4;
      int a5;
      global::f.a(a2, out a3, out a4, out a5);
label_6:
      int num = 6;
      int a6;
      int a7;
      int a8;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.a.Add((object) (ushort) a4);
            num = 4;
            continue;
          case 1:
            this.a.Add((object) (ushort) a6);
            num = 7;
            continue;
          case 2:
            this.a.Add((object) (ushort) a3);
            num = 0;
            continue;
          case 3:
            this.b.Add((object) (byte) a7);
            num = 5;
            continue;
          case 4:
            this.b.Add((object) (byte) a5);
            num = 1;
            continue;
          case 5:
            this.c += a2;
            num = 8;
            continue;
          case 6:
            global::f.b(a1, out a6, out a8, out a7);
            num = 2;
            continue;
          case 7:
            this.a.Add((object) (ushort) a8);
            num = 3;
            continue;
          case 8:
            goto label_15;
          default:
            goto label_6;
        }
      }
label_15:;
    }

    internal void a() => this.a.Add((object) (ushort) 256);
  }

  private sealed class h
  {
    private uint a;
    private int b;
    private Stream c;

    internal h(Stream a) => this.c = a;

    internal Stream a => this.c;

    internal int a => (32 - this.b) % 8;

    internal void a(bool a) => this.a(a ? 1 : 0, 1);

    internal void a(int a1, int a2)
    {
      uint num1 = this.a | checked ((uint) a1) << this.b;
      int num2;
      for (num2 = this.b + a2; num2 >= 8; num2 -= 8)
      {
        this.a.WriteByte((byte) num1);
        num1 >>= 8;
      }
label_5:
      int num3 = 0;
      while (true)
      {
        switch (num3)
        {
          case 0:
            this.a = num1;
            num3 = 1;
            continue;
          case 1:
            this.b = num2;
            num3 = 2;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:;
    }

    internal void b(int a1, int a2)
    {
      int a = 0;
label_7:
      for (int index = a2 - 1; index >= 0; --index)
      {
        a <<= 1;
label_3:
        int num = 0;
        while (true)
        {
          switch (num)
          {
            case 0:
              a |= a1 & 1;
              num = 1;
              continue;
            case 1:
              a1 >>= 1;
              num = 2;
              continue;
            case 2:
              goto label_7;
            default:
              goto label_3;
          }
        }
      }
      this.a(a, a2);
    }

    internal void a()
    {
      if (this.b <= 0)
        return;
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.a.WriteByte((byte) this.a);
            num = 1;
            continue;
          case 1:
            this.a = 0U;
            num = 2;
            continue;
          case 2:
            goto label_6;
          default:
            goto label_2;
        }
      }
label_6:
      this.b = 0;
    }
  }
}
